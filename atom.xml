<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-30T05:59:40.338Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Class的继承</title>
    <link href="http://example.com/2020/12/29/Class2/"/>
    <id>http://example.com/2020/12/29/Class2/</id>
    <published>2020-12-29T06:53:04.000Z</published>
    <updated>2020-12-30T05:59:40.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>Class可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承,要清晰和方便很多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Pointwo extends Point&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Pointwo extends Point&#123;</span><br><span class="line">    constructor(x,y,color)&#123;</span><br><span class="line">        super(x,y)&#x2F;&#x2F;调用父类的constructor(x,y)</span><br><span class="line">        this.color &#x3D; color</span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line">        return this.color + &#39;&#39; +super.toString()&#x2F;&#x2F;调用父类的toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码中，constructor方法和toString方法之中，都出现了super关键字，他在这里表示父类的构造函数，用来新建父类的this对象</span><br><span class="line">子类必须在constructor方法中调用super方法，否则新建实例时会报错，这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后对其进行加工，加上子类自己的实例属性和方法，如果不调用super方法，子类就得不到this对象</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123; &#x2F;* ... *&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cp &#x3D; new ColorPoint(); &#x2F;&#x2F; ReferenceError</span><br><span class="line">上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。</span><br><span class="line"></span><br><span class="line">ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</span><br><span class="line"></span><br><span class="line">如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(...args) &#123;</span><br><span class="line">    super(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    this.color &#x3D; color; &#x2F;&#x2F; ReferenceError</span><br><span class="line">    super(x, y);</span><br><span class="line">    this.color &#x3D; color; &#x2F;&#x2F; 正确</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。</span><br><span class="line"></span><br><span class="line">下面是生成子类实例的代码。</span><br><span class="line">let cp &#x3D; new ColorPoint(25, 8, &#39;green&#39;);</span><br><span class="line"></span><br><span class="line">cp instanceof ColorPoint &#x2F;&#x2F; true</span><br><span class="line">cp instanceof Point &#x2F;&#x2F; true</span><br><span class="line">上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后，父类的静态方法，也会被子类继承。</span><br></pre></td></tr></table></figure><p>class A {<br>  static hello() {<br>    console.log(‘hello world’);<br>  }<br>}</p><p>class B extends A {<br>}</p><p>B.hello()  // hello world<br>上面代码中，hello()是A类的静态方法，B继承A，也继承了A的静态方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.Object.getPrototypeOf()</span><br><span class="line">Object.getPrototypeOf()方法可以用来从子类上获取父类</span><br></pre></td></tr></table></figure><p>Object.getPrototypeOf(ColorPoint) === Point//true<br>因此，可以使用这个方法判断，一个类是否继承了另一个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.super关键字</span><br><span class="line">super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同</span><br><span class="line">第一种情况，super作为函数用时，代表父类的构造函数。ES6要求，子类的构造函数必须执行一次super函数。</span><br></pre></td></tr></table></figure><p>class A {}</p><p>class B extends A {<br>  constructor() {<br>    super();<br>  }<br>}<br>上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p><p>注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    console.log(new.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">new A() &#x2F;&#x2F; A</span><br><span class="line">new B() &#x2F;&#x2F; B</span><br><span class="line">上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。</span><br><span class="line"></span><br><span class="line">作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  m() &#123;</span><br><span class="line">    super(); &#x2F;&#x2F; 报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，super()用在B类的m方法之中，就会造成语法错误。</span><br></pre></td></tr></table></figure><p>第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    p()&#123;</span><br><span class="line">        return 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super()</span><br><span class="line">        console.log(super.p())&#x2F;&#x2F;&#x2F;2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; new B()</span><br><span class="line">代码中，子类B当中的super.p(),就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype,所以super.p()就相当于A.prototype.p()</span><br><span class="line">注意：由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.p &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  get m() &#123;</span><br><span class="line">    return super.p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">b.m &#x2F;&#x2F; undefined</span><br><span class="line">上面代码中，p是父类A实例的属性，super.p就引用不到它。</span><br></pre></td></tr></table></figure><p>如果属性定义在父类的原型对象上，super就可以取到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line">A.prototype.x &#x3D; 2;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super.x) &#x2F;&#x2F; 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">代码中,属性x是定义在A.prototype上面的，所以super.x可以取到它的值</span><br></pre></td></tr></table></figure><p>ES6规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.x &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    super.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">b.m() &#x2F;&#x2F; 2</span><br><span class="line">代码中，super.print()虽然调用的是A.prototype.print(),但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1.也就是说，实际上执行的是super.print.call(this)</span><br></pre></td></tr></table></figure><p>由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.x &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x &#x3D; 2;</span><br><span class="line">    super.x &#x3D; 3;</span><br><span class="line">    console.log(super.x); &#x2F;&#x2F; undefined</span><br><span class="line">    console.log(this.x); &#x2F;&#x2F; 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">代码中，super.x赋值为3，这时等同于对this.x赋值为3.而当读取super.x的时候，读的是A.prototype.x,所以返回undefined</span><br></pre></td></tr></table></figure><p>如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">    static myMethod(msg)&#123;</span><br><span class="line">        console.log(&#39;static&#39;,msg)</span><br><span class="line">    &#125;</span><br><span class="line">    myMethod(msg)&#123;</span><br><span class="line">        console.log(&#39;instance&#39;,msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent&#123;</span><br><span class="line">    static myMethod(msg)&#123;</span><br><span class="line">        super.myMethod(msg)</span><br><span class="line">    &#125;</span><br><span class="line">    myMethod(msg)&#123;</span><br><span class="line">        super.myMethod(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Child.myMethod(1))</span><br><span class="line">var child &#x3D; new Child()</span><br><span class="line">console.log(child.myMethod(2))</span><br><span class="line">上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</span><br></pre></td></tr></table></figure><p>另外，在子类的静态方法中通过super调用父类方法时，方法内部的this指向当前的子类，而不是子类的实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.x &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  static print() &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line">  static m() &#123;</span><br><span class="line">    super.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.x &#x3D; 3;</span><br><span class="line">B.m() &#x2F;&#x2F; 3</span><br><span class="line">上面代码中，静态方法B.m里面，super.print指向父类的静态方法。这个方法里面的this指向的是B，而不是B的实例。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</span><br><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super); &#x2F;&#x2F; 报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super.valueOf() instanceof B); &#x2F;&#x2F; true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super使得this指向B的实例，所以super.valueOf()返回的是一个B的实例。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &quot;MyObject: &quot; + super.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.toString(); &#x2F;&#x2F; MyObject: [object Object]</span><br></pre></td></tr></table></figure><p>4.类的 prototype 属性和__proto__属性<br>大多数浏览器的ES5实现中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性,因此同时存在两条继承链<br>(1) 子类的__proto__属性，表示构造函数的继承，总是指向父类。<br>(2) 子类的prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">B.__proto__ &#x3D;&#x3D;&#x3D; A &#x2F;&#x2F;true</span><br><span class="line">B.prototype.__proto__ &#x3D;&#x3D;&#x3D; A.prototype &#x2F;&#x2F;true</span><br><span class="line">代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性</span><br></pre></td></tr></table></figure><p>这样的结果是因为，类的继承是按照下面的模式实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class B&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Object.setPrototypeOf(B.prototype,A.prototype)&#x2F;&#x2F;B的实例继承A的实例</span><br><span class="line">Object.setPrototypeOf(B,A)&#x2F;&#x2F;B继承A的静态属性</span><br><span class="line">const b &#x3D; new B()</span><br><span class="line">《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf &#x3D; function (obj, proto) &#123;</span><br><span class="line">  obj.__proto__ &#x3D; proto;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line">因此就得到了上面这个结果</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">B.prototype.__proto__ &#x3D; A.prototype;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(B, A);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">B.__proto__ &#x3D; A;</span><br><span class="line">这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B.prototype &#x3D; Object.create(A.prototype);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">B.prototype.__proto__ &#x3D; A.prototype;</span><br></pre></td></tr></table></figure><p>extends关键字后面可以跟多种类型的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class B extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。</span><br></pre></td></tr></table></figure><p>下面，讨论两种情况。第一种，子类继承Object类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A extends Object &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ &#x3D;&#x3D;&#x3D; Object &#x2F;&#x2F; true</span><br><span class="line">A.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; true</span><br><span class="line">这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。</span><br></pre></td></tr></table></figure><p>第二种情况，不存在任何继承。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ &#x3D;&#x3D;&#x3D; Function.prototype &#x2F;&#x2F; true</span><br><span class="line">A.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; true</span><br><span class="line">这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。</span><br></pre></td></tr></table></figure><p>实例的 <strong>proto</strong> 属性<br>子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Point(2, 3);</span><br><span class="line">var p2 &#x3D; new ColorPoint(2, 3, &#39;red&#39;);</span><br><span class="line"></span><br><span class="line">p2.__proto__ &#x3D;&#x3D;&#x3D; p1.__proto__ &#x2F;&#x2F; false</span><br><span class="line">p2.__proto__.__proto__ &#x3D;&#x3D;&#x3D; p1.__proto__ &#x2F;&#x2F; true</span><br><span class="line">上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。</span><br></pre></td></tr></table></figure><p>因此，通过子类实例的<strong>proto</strong>.__proto__属性，可以修改父类实例的行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p2.__proto__.__proto__.printName &#x3D; function () &#123;</span><br><span class="line">  console.log(&#39;Ha&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() &#x2F;&#x2F; &quot;Ha&quot;</span><br><span class="line">上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h1&gt;&lt;p&gt;Class可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承,要清晰和方便很多。&lt;/p&gt;
&lt;figur</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hook中的useState、useEffect</title>
    <link href="http://example.com/2020/12/26/Hook/"/>
    <id>http://example.com/2020/12/26/Hook/</id>
    <published>2020-12-26T01:02:04.000Z</published>
    <updated>2020-12-27T11:13:49.548Z</updated>
    
    <content type="html"><![CDATA[<p>Hook 是React 16.8的新增特性。它可以让你在不编写 class的情况下使用 state 以及其他的 React特性。<br>   Hook是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数<br>   Hook 不能在 class 组件中使用<br>   <code>const [state, setState] = useState(initialState)</code><br>   返回一个 state,以及更新 state 的函数<br>   当 state 为引用类型，修改时注意要合并其他值，不然会发生错误<br>   多个 state 最好分开写<br>   setState 也可以接收一个函数<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">    function Home()&#123;</span><br><span class="line">        const [count, setCount] &#x3D; useState(0)</span><br><span class="line">        &#x2F;&#x2F;也可以在state里写对象</span><br><span class="line">        const [person, setPerson] &#x3D; useState(&#123;</span><br><span class="line">            name:&#39;大黄&#39;,</span><br><span class="line">            age:&#39;18&#39;,</span><br><span class="line">            sex:&#39;女&#39;</span><br><span class="line">        &#125;)</span><br><span class="line">        const [num,setNum] &#x3D; useState(100)</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                我是todolist</span><br><span class="line">                count:&#123;count&#125;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setCount(count+1)&#125;&#125;&gt;加+&lt;&#x2F;button&gt;</span><br><span class="line">                &#123;&#x2F;* setCount和class组件setState是一样的都是修改state的状态的*&#x2F;&#125;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    name:&#123;person.name&#125;</span><br><span class="line">                    age:&#123;person.age&#125;</span><br><span class="line">                    sex:&#123;person.sex&#125;</span><br><span class="line">                    &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setPerson(&#123;age:19&#125;)&#125;&#125;&gt;给大黄过年&lt;&#x2F;button&gt;</span><br><span class="line">                    &#123;&#x2F;* 这里当我们点击了按钮调用setState，只修改了age,虽然年龄变成了19，但是其他属性都为空了，所以说</span><br><span class="line">                        在调用setState时，如果它是个引用类型时我们要它另外值合并一下</span><br><span class="line">                        onClick&#x3D;&#123;()&#x3D;&gt;&#123;setPerson(&#123;age:19,name:person.name,sex:person.sex&#125;)&#125;&#125;</span><br><span class="line">                        这样写就没问题了</span><br><span class="line">                    *&#x2F;&#125;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    计数：&#123;num&#125;</span><br><span class="line">                    &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setNum((oval)&#x3D;&gt;&#123;console.log(oval);return oval+1&#125;)&#125;&#125;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">                    &#123;&#x2F;* setState还可以接收一个函数 *&#x2F;&#125;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    export default Home</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F;useEffect!!</span><br><span class="line">    useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;参数是个函数：也叫副作用函数</span><br><span class="line">         return ()&#x3D;&gt;&#123;&#125;&#x2F;&#x2F;返回函数 返回的函数式可选的  可以不写返回函数</span><br><span class="line">     &#125;,[])&#x2F;&#x2F;这里的数组是依赖参数   依赖也是可选的</span><br><span class="line">    作用函数：</span><br><span class="line">     1.当useEffect ,没有依赖参数时，副作用函数，会在组件挂载完成及组件更新完成时执行</span><br><span class="line">     2.当有依赖参数副作用函数，会在组件挂载完成及改依赖参数修改，引起的组件更新完成之后执行</span><br><span class="line">     3.当依赖参数为空数组时，会在组件挂载完成之后执行</span><br><span class="line">     4.返回函数在组件更新完成，或即将写在执行，一般返回函数用在即将卸载时</span><br><span class="line">     useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;当没有依赖参数和返回函数的时候，现在就相当于class组件的componentDidMount、componentUpdate生命周期</span><br><span class="line">    console.log(1,&#39;useEffect&#39;)&#x2F;&#x2F;一直触发btn，一直在打印</span><br><span class="line">&#125;)</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;当依赖参数为空和没有返回函数时，只执行了一次，后面在触发btn时，不在执行.相当于componentDidMount</span><br><span class="line">    console.log(2,&#39;useEffect&#39;)</span><br><span class="line">&#125;,[])</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(3,&#39;useEffect&#39;)</span><br><span class="line">&#125;,[name])&#x2F;&#x2F;在有依赖参数时，组件挂载完会执行一次，在后面触发btn时，如果依赖参数没有发生改变，不会再打印</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">    return ()&#x3D;&gt;&#123;</span><br><span class="line">        console.log(4,&#39;useEffect&#39;)</span><br><span class="line">    &#125;&#x2F;&#x2F;当没有依赖，有返回函数的时候，初次挂载完返回函数不会执行，但是当触发btn时，就是组件发生改变，它就会执行返回函数的代码</span><br><span class="line">&#125;,)&#x2F;&#x2F;如果此处有依赖，但不空，那就当依赖的参数发生改变的时候，返回函数内的代码也会执行</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">    return ()&#x3D;&gt;&#123;</span><br><span class="line">        console.log(&#39;更新或者卸载&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[count])&#x2F;&#x2F;也可以有依赖参数并且会更新用返回函数进行卸载或更新</span><br><span class="line">&#x2F;&#x2F;缺点：挂载前和更新前的生命周期要用到别的方法来配合使用useEffect。这里更多的是挂载完和更新完</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hook 是React 16.8的新增特性。它可以让你在不编写 class的情况下使用 state 以及其他的 React特性。&lt;br&gt;   Hook是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数&lt;br&gt;   Hook 不能在 class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/12/25/hello-world/"/>
    <id>http://example.com/2020/12/25/hello-world/</id>
    <published>2020-12-25T01:36:20.562Z</published>
    <updated>2020-12-25T01:36:20.562Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>手写Promise</title>
    <link href="http://example.com/2018/05/25/%E6%89%8B%E5%86%99Promise/"/>
    <id>http://example.com/2018/05/25/%E6%89%8B%E5%86%99Promise/</id>
    <published>2018-05-25T14:10:50.000Z</published>
    <updated>2020-12-27T12:35:16.339Z</updated>
    
    <content type="html"><![CDATA[<p><font> 手写Promise  主要是解决回调地狱的问题，在ES6中出现了promise来解决这个问题，但是同样也带来了多个.then()的问题<br>    //随着es7 async和await到来可以说彻底解决回调地狱。<br>    new Promise() //是谁执行了？直接new一个Promise是内置构造Promise执行了，但是它会报错。因为这里缺一个回调函数，平常大家也都是这么用的<br>    new Promise(()=&gt;{<br>       console.log(‘你大爷’)//‘你大爷’会执行吗？：这里new了一个Promose,Promise执行一次，那里面的回调函数也会执行，所以‘你大爷’成功被打印<br>    })<br>    function fn(callBack){</p><pre><code>&#125;new fn(()=&gt;&#123;&#125;)//fn执行，但是里面的回调并没有，Promise的回调会执行。//new Promise 是内置构造函数Promise执行一次//Promise的回调函数也会执行一次，这个回调函数会给我们提供两个形参（函数）：成功、失败//Promise的回调函数，又有两个参数分别是：resolve、reject两个函数//Promise类的实例没有then方法，应该是原型对象的方法var obj = new Promise((resolve,rejecct)=&gt;&#123;     console.log(resolve,reject)//两个函数&#125;)//obj是Promise的一个实例// 手写function myPromise(callBack)&#123;//接受传进来的回调函数    //状态属性    this.status=&#39;pending&#39;    //回调函数    callBack(resolve.bind(this),reject.bing(this))    //定义一个成功的函数    function resolve(hello,           params)&#123;        //那么console.log(hello)肯定是执行的（很早演示时写）        //修改状态（后写）        if(this.status===&#39;pending&#39;)&#123;//如果出事状态为pengding,            this.status=&#39;success&#39;//那就把它改成success成功            //这里还有一个上下文的问题。成功时resolve是怎么调用的？是函数名+小括号，也就是window.            //但这里就不该用window，因为将来获取服务器的数据实在.then()里的来获取。所以我们在初始化时就要给            //resolve和reject绑死这个类的实例：resolve.bind(this)  reject.bing(this) 走起上面绑死↑            //否则你在调用resolve和reject时他们就会指向window            //为什么绑死上下文为这个类的实例？因为我们要借用这个类的实例的成功和失败的方法74行里面成功与失败的回调            //所以↓            this.successCallBack(params)//这个是谁？它就是then的第一个参数也就是成功的回调，所以把参数直接注进来就行了            //失败同样        &#125;    &#125;    //定义一个失败的函数    function reject(err)&#123;        if(this.status===&#39;pending&#39;)&#123;            this.status=&#39;faile&#39;            this.faileCallBack(err)        &#125;    &#125;&#125;//调用new myPromise(()=&gt;&#123;//并且传进去一个回调函数。但是我们在实际运用中肯定要传2个参数进去。resolve,reject,并且37行回调也要接受这个2个函数    //console.log(&#39;我是Promise&#39;)//这里肯定会执行。打印。    //假如这里调用并传参resolve(&#39;hello&#39;)    //处理异步,一般promise就是处理异步的    setTimeout(()=&gt;&#123;        resolve(&#39;我是promise&#39;)    &#125;)&#125;)//假如我们是在处理异步请求那么肯定要在这.then()。但是能直接.then()吗？要注意.then()是在原型上面的。虽然链式语法可以这么写，但是这里并没有这个方法。.then()应该是原型上面类的原型的方法.then((data)=&gt;&#123;    console.log(data)&#125;,()=&gt;&#123;&#125;)//一般我们在调用then()的时候肯定要传2个参数进去，下面接收，就是相当于将then方法里面成功与失败的回调函数当做当前类的实例即可，当前类是谁？promise//所以原型上定义一个then的方法，应该是myPromise.prototype.then=function(success,faile)&#123;//接收上面调用then时传进来的来个函数。就是将then方法里面成功与失败的回到函数作为当前类的实例即可    this.successCallBack=success//相当于then传进一个成功的函数给了success,就是给myPromise的实例动态添加了属性就是success这个成功的箭头函数。还有一个失败的同样     this.faileCallBack=faile    //then()的两个函数相当于作为这个实例的两个方法&#125;//53行异步成功后执行，就是相当于调用了41行那个方法。失败同样//因为promise有3中状态，pending、成功、失败。所以此时我去上面给类定义个状态的属性，走起↑//如果说异步解决成功就调用resolve方法 。resolve就是41行函数执行。但是我们都是在then()来获取成功或失败的数据，(其实就是调用this.successCallBack，this.faileCallBack)。所以走起去上面↑，就是修改promise的状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(()&#x3D;&gt;&#123;</span><br><span class="line">    window.myPromise&#x3D;function(callBack)&#123;</span><br><span class="line">        &#x2F;&#x2F;状态属性</span><br><span class="line">        this.status&#x3D;&#39;pending&#39;</span><br><span class="line">        &#x2F;&#x2F;回调函数</span><br><span class="line">        callBack(resolve.bind(this),reject.bind(this))</span><br><span class="line">        &#x2F;&#x2F; 成功</span><br><span class="line">        function resolve(params)&#123;</span><br><span class="line">            if(this.status&#x3D;&#x3D;&#x3D;&#39;pending&#39;)&#123;</span><br><span class="line">                this.status&#x3D;&#39;success&#39;</span><br><span class="line">                this.successCallBack(params)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 失败</span><br><span class="line">        function reject(err)&#123;</span><br><span class="line">            if(this.status&#x3D;&#x3D;&#x3D;&#39;pending&#39;)&#123;</span><br><span class="line">                this.status&#x3D;&#39;faile&#39;</span><br><span class="line">                this.successCallBack(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;原型上定义一个then的方法</span><br><span class="line">    myPromise.prototype.then&#x3D;function(success,faile)&#123;</span><br><span class="line">        this.successCallBack&#x3D;success</span><br><span class="line">        this.faileCallBack&#x3D;faile</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">var obj &#x3D; new myPromise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        resolve(&#39;你真好&#39;)</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;).then((data)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(data)&#x2F;&#x2F;成功执行</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;font&gt; 手写Promise  主要是解决回调地狱的问题，在ES6中出现了promise来解决这个问题，但是同样也带来了多个.then()的问题&lt;br&gt;    //随着es7 async和await到来可以说彻底解决回调地狱。&lt;br&gt;    new Promise() </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Class的基本语法</title>
    <link href="http://example.com/2018/05/15/Class1/"/>
    <id>http://example.com/2018/05/15/Class1/</id>
    <published>2018-05-15T14:02:45.000Z</published>
    <updated>2020-12-29T06:52:30.506Z</updated>
    
    <content type="html"><![CDATA[<p>class的基本语法:<br>一.类的由来<br>JS中生成实力对象的传统方法是通过构造函数，下面请看一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Point(x,y)&#123;</span><br><span class="line">    this.x&#x3D;x</span><br><span class="line">    this.y&#x3D;y</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.toString&#x3D;function ()&#123;</span><br><span class="line">    return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39;</span><br><span class="line">&#125;</span><br><span class="line">var p &#x3D; new Point(1,2)</span><br><span class="line">console.log(p)</span><br></pre></td></tr></table></figure><p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</p><p>基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">    constructor(x,y)&#123;</span><br><span class="line">        this.x&#x3D;x</span><br><span class="line">        this.y&#x3D;y</span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line">            return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p &#x3D;new Point(1,2)</span><br><span class="line">console.log(p)</span><br></pre></td></tr></table></figure><p>这个是定义了一个类，有一个constructor()方法，就是构造方法而this关键字就是实力的对象。这种新的Class写法，最开始ES5的构造函数Point是一样的。</p><p>Point类除了构造方法，还定义了一个toString方法。注意，这里定义toString()方法，是不用加上function关键字的。直接定义就可以，并且不用逗号隔开，加了会报错。</p><p>ES6的类，完全可以看做构造函数的另一种写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(typeof Point)&#x2F;&#x2F;function 说明类的数据类型是函数，类本身就指向构造函数</span><br><span class="line">console.log(Point&#x3D;&#x3D;&#x3D;Point.prototype.constructor)&#x2F;&#x2F;true</span><br><span class="line">使用的时候也是直接对类使用new 命令，跟构造函数的用法完全一致。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Bar&#123;</span><br><span class="line">    todo()&#123;</span><br><span class="line">        console.log(&#39;类&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const b &#x3D; new Bar()</span><br><span class="line">b.todo()&#x2F;&#x2F;&#39;类&#39;</span><br><span class="line">构造函数的prototype属性，在ES6的 类上面继续存在。事实上，类的所有方法都定义在类的 prototype属性上面</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">        constructor() &#123;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        toString() &#123;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        toValue() &#123;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 等同于</span><br><span class="line"></span><br><span class="line">        Point.prototype &#x3D; &#123;</span><br><span class="line">        constructor() &#123;&#125;,</span><br><span class="line">        toString() &#123;&#125;,</span><br><span class="line">        toValue() &#123;&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        上面代码中，所有的方法，其实都是定义在Point.prototype上面</span><br><span class="line">        因此，在类的实例上面调用方法，其实就是调用原型上的方法</span><br></pre></td></tr></table></figure><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class B&#123;&#125;</span><br><span class="line">const b &#x3D; new B()</span><br><span class="line">console.log(b.constructor &#x3D;&#x3D;&#x3D; B.prototype.constructor)&#x2F;&#x2F;true</span><br><span class="line">b是B类的实例，b的constructor()方法就是B类原型的constructor()方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。</span><br><span class="line">Object.assign()方法可以很方便地一次向类天机多个方法。比如：</span><br><span class="line">class Point&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Object.assign(Point.prototype,&#123;</span><br><span class="line">    toString()&#123;&#125;,</span><br><span class="line">    toValue()&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prototype对象的constructor()属性，直接指向&#39;类&#39;的本身，这与ES5的行为是一致的。</span><br><span class="line">Point.prototype.constructor&#x3D;&#x3D;&#x3D;Point &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>另外，类的内部所有定义的方法，都是不可枚举的(non-enumerabal)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">    constructor(x,y)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.keys(Point.prototype))&#x2F;&#x2F;[]</span><br><span class="line">console.log(Object.getOwnPropertyNames(Point.prototype))&#x2F;&#x2F;[&#39;constructor&#39;,&#39;toString&#39;]</span><br><span class="line">这里，toString()方法是Point类 内部定义的方法，它是不可枚举的。这一点与ES5是不一样的</span><br></pre></td></tr></table></figure></code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    var Point &#x3D; function (x,y)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.toString &#x3D; function ()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.keys(Point.prototype))&#x2F;&#x2F;[&#39;toString&#39;]</span><br><span class="line">console.log(Object.getOwnPropertyNames(Point.prototype))&#x2F;&#x2F;[&#39;constructor&#39;,&#39;toString&#39;]</span><br><span class="line">这是ES5 的写法，toString()方法就是可枚举的。</span><br></pre></td></tr></table></figure><p>Constructor()方法<br>    constructor()方法是类的默认方法，是通过new 命令生成对象实例时，自动调用该方法。一个类必须有constructor()<br>    方法，如果没有显示定义，一个空德constructor()方法也会被默认添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Ponit&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;等同于</span><br><span class="line">    class Point&#123;</span><br><span class="line">        constructor()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">这里，定义了一个空的类Point,JS引擎会自动给他添加一个空的constructor()方法。</span><br><span class="line">constructor()方法默认返回实例对象(即this),完全可以指定返回另一个对象</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        return Object.create(null)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Foo() instanceof Foo)&#x2F;&#x2F;false</span><br><span class="line">这里，constructor()函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。</span><br><span class="line">类必须使用new调用，否则会报错，这是它跟普通构造函数的一个主要区别，后者不用new也可以执行</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        return Object.create(null)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo()&#x2F;&#x2F;Class constructor Foo cannot be invoked without &#39;new&#39;</span><br></pre></td></tr></table></figure><p>类的实例！<br>    生成类的实例的写法，与ES5 完全一样，也是使用 new命令。如果没有用 new，像函数那样调用class,将会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> var point &#x3D; Point(2,3)&#x2F;&#x2F;报错</span><br><span class="line"> var point &#x3D; new Point(2,3)&#x2F;&#x2F;正确</span><br></pre></td></tr></table></figure><p>与ES5 一样，实例的属性除非显示定义在其本身(即定义在this上)，否则都是定义在原型上(即定义在class上)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">    constructor(x,y)&#123;</span><br><span class="line">        this.x&#x3D;x</span><br><span class="line">        this.y&#x3D;y</span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line">        return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var point &#x3D; new Point(2,3)</span><br><span class="line">console.log(point.toString(2,3))&#x2F;&#x2F;(2,3)</span><br><span class="line">console.log(point.hasOwnProperty(&#39;x&#39;))&#x2F;&#x2F;true</span><br><span class="line">console.log(point.hasOwnProperty(&#39;y&#39;))&#x2F;&#x2F;true</span><br><span class="line">console.log(point.hasOwnProperty(&#39;toString&#39;))&#x2F;&#x2F;false</span><br><span class="line">console.log(point.__proto__.hasOwnProperty(&#39;toString&#39;))&#x2F;&#x2F;true</span><br><span class="line">上面代码中，x和y都是实例对象point自身属性(因为定义在this变量上)，所以hasOwnProperty()方法返回true，而toString()</span><br><span class="line">是原型对象的属性(因为定义在Point类上)，所以hasOwnProperty()方法返回false,这些都与ES5的行为保持一致</span><br></pre></td></tr></table></figure><p>与ES5一样，类的所有实例共享一个原型对象！！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Point(2,3)</span><br><span class="line">var p2 &#x3D; new Point(1,3)</span><br><span class="line">p1.__proto&#x3D;&#x3D;&#x3D;p2.__proto__&#x2F;&#x2F;true</span><br><span class="line">上面代码中。p1和p2都是Point的实例，他们的原型都是Point.prototype,所以__proto__属性是相等的。</span><br><span class="line">这也意味着，可以通过实例的__proto__属性为&#39;类&#39;添加方法</span><br></pre></td></tr></table></figure><p><strong>proto</strong> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Point(2,3);</span><br><span class="line">var p2 &#x3D; new Point(3,2);</span><br><span class="line"></span><br><span class="line">p1.__proto__.printName &#x3D; function () &#123; return &#39;Oops&#39; &#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class="line">p2.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class="line"></span><br><span class="line">var p3 &#x3D; new Point(4,2);</span><br><span class="line">p3.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class="line">上面代码在p1的原型上添加了一个printName()方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</span><br></pre></td></tr></table></figure><p>取值函(getter)和存值函数(setter)<br>与ES5一样，在’类’的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MyClass&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    get prop()&#123;</span><br><span class="line">        return &#39;getter&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    set prop(value)&#123;</span><br><span class="line">        console.log(&#39;setter:&#39;+value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let inst &#x3D; new MyClass()</span><br><span class="line">console.log(inst.props&#x3D;123)&#x2F;&#x2F;&#39;setter:123&#39;</span><br><span class="line">console.log(inst.prop)&#x2F;&#x2F;&#39;getter&#39;</span><br><span class="line">上面，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了</span><br></pre></td></tr></table></figure><p>存值函数和取值函数式设置在属性的 Desscriptor对象上的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class CustomHTMLElement &#123;</span><br><span class="line">    constructor(element)&#123;</span><br><span class="line">        this.element &#x3D; element</span><br><span class="line">    &#125;</span><br><span class="line">    get html()&#123;</span><br><span class="line">        return thi.element.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">    set html(value)&#123;</span><br><span class="line">        this.element.innerHTML&#x3D;value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var descriptor &#x3D; Object.getOwnPropertyDescriptor(</span><br><span class="line">    CustomHTMLElement.proptotype,&#39;html&#39;</span><br><span class="line">)</span><br><span class="line">&#39;get&#39; in descriptor&#x2F;&#x2F;true</span><br><span class="line">&#39;set&#39; in descriptor&#x2F;&#x2F;true</span><br><span class="line">上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。</span><br></pre></td></tr></table></figure><p>属性表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let nethodName &#x3D; &#39;getArea&#39;</span><br><span class="line">class Square &#123;</span><br><span class="line">    constructor(length)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    [methodName]()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码中，Square类的方法名getArea,是从表达式得到的。</span><br></pre></td></tr></table></figure><p>Class 表达式<br>与函数一样，类也可以使用表达式的形式定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> const MyClass &#x3D; class Me&#123;</span><br><span class="line">    getClassName()&#123;</span><br><span class="line">        return Me.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这里使用表达式定义了一个类，类的名字是Me,但是Me只在Class的内部可用，指代当前类。在Class外部，这个类只能用myClass引用</span><br><span class="line">let inst &#x3D; new MyClass()</span><br><span class="line">console.log(inst.getClassName())&#x2F;&#x2F;Me</span><br><span class="line">Me.name&#x2F;&#x2F;Me is not defined</span><br><span class="line">这里就可以说明，Me只在Class内部有定义</span><br><span class="line"></span><br><span class="line">如果类的内部没有用到的话，可以省略Me,也就是可以下面的形式</span><br><span class="line">const MyClass &#x3D; class &#123;&#x2F;&#x2F;....&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">采用Class 表达式，可以写出立即执行的Class</span><br><span class="line">let person &#x3D; new class&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(&#39;李华&#39;)</span><br><span class="line">person.sayName()</span><br><span class="line">这里 person是一个立即执行的类的实例</span><br></pre></td></tr></table></figure><p>注意点<br>（1）严格模式</p><p>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。<br>（2）不存在提升<br>累不存在变量提升，这一点与ES5完全不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Foo()</span><br><span class="line">class Foo&#123;&#125;</span><br><span class="line">上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承者有关，必须保证子类在父类之后定义。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let Foo &#x3D; class&#123;&#125;</span><br><span class="line">    class Bar extends Foo&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。</span><br></pre></td></tr></table></figure><p>（3）name 属性<br>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;&#125;</span><br><span class="line">Point.name&#x2F;&#x2F;&#39;Point&#39;</span><br><span class="line">name属性总是返回紧跟在class关键字后面的类。</span><br></pre></td></tr></table></figure><p>（4）Generator 方法<br>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    constructor(...args)&#123;</span><br><span class="line">        this.args &#x3D; args</span><br><span class="line">    &#125;</span><br><span class="line">    *[Symbol.iterator]()&#123;</span><br><span class="line">        for(let arg of this.args)&#123;</span><br><span class="line">            yield arg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(let x of new Foo(&#39;hello&#39;,&#39;world&#39;))&#123;</span><br><span class="line">    console.log(x)</span><br><span class="line">&#125;</span><br><span class="line">上面的代码中，Foo类的Symbol.interator方法前有一个星号，表示该方法是一个Generator 函数。Symbol.interator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。</span><br></pre></td></tr></table></figure><p>5）this 的指向<br>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Logger&#123;</span><br><span class="line">    printName(name&#x3D;&#39;there&#39;)&#123;</span><br><span class="line">        this.print(&#96;Hello $&#123;name&#125;&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">    print(text)&#123;</span><br><span class="line">        console.log(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const logger &#x3D; new Logger()</span><br><span class="line">const &#123; printName&#125; &#x3D; logger</span><br><span class="line">console.log(printName())&#x2F;&#x2F;Cannot read property &#39;print&#39; of undefined</span><br><span class="line">上面代码中，printName方法中的this，默认指向Logger类的实例，但是。如果将这个方法提取出来单独使用，this会指向该方法运行是所在的环境(由于class内部是严格模式，所以this实际指向的是undefined),从而导致找不到print方法而报错。</span><br><span class="line">一个比较简单的解决方法是，在构造函数中绑定this。这样就不会找不到print方法了。</span><br><span class="line">class Logger &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.printName &#x3D; this.printName.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">另一种解决方法是使用箭头函数。</span><br><span class="line">class Obj&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.getThis &#x3D; () &#x3D;&gt; this</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const myObj &#x3D; new Obj()</span><br><span class="line">myObj.getThis() &#x3D;&#x3D;&#x3D; myObj&#x2F;&#x2F;true</span><br><span class="line">箭头函数内部的this总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，实在构造函数执行的时候，这时，箭头函数所在的运行环境，肯定是实例对象，所以this会总是指向实例对象</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。</span><br><span class="line">function selfish (target) &#123;</span><br><span class="line">  const cache &#x3D; new WeakMap();</span><br><span class="line">  const handler &#x3D; &#123;</span><br><span class="line">    get (target, key) &#123;</span><br><span class="line">      const value &#x3D; Reflect.get(target, key);</span><br><span class="line">      if (typeof value !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        return value;</span><br><span class="line">      &#125;</span><br><span class="line">      if (!cache.has(value)) &#123;</span><br><span class="line">        cache.set(value, value.bind(target));</span><br><span class="line">      &#125;</span><br><span class="line">      return cache.get(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  const proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">  return proxy;</span><br><span class="line">&#125;</span><br><span class="line">const logger &#x3D; selfish(new Logger());</span><br></pre></td></tr></table></figure><p>2.静态方法<br>类相当于实例的原型。所有在类中定义的方法，都会被实例继承，如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为‘静态方法’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    static classMethod()&#123;</span><br><span class="line">        return &#39;hello&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Foo.classMethod())&#x2F;&#x2F;&#39;hello&#39;</span><br><span class="line">var foo &#x3D; new Foo()</span><br><span class="line">console.log(foo.classMethod())&#x2F;&#x2F;foo.classMethod is not a function</span><br><span class="line">上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用</span><br><span class="line">(Foo.classMethod()),而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法</span><br></pre></td></tr></table></figure><p>注意：如果静态方法包含this关键字，这个this指的是类，而不是实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    static bar()&#123;</span><br><span class="line">        this.baz()</span><br><span class="line">    &#125;</span><br><span class="line">    static baz()&#123;</span><br><span class="line">        console.log(&#39;hello&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    baz()&#123;</span><br><span class="line">        console.log(&#39;world&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    console.log(Foo.bar())&#x2F;&#x2F;hello</span><br><span class="line"></span><br><span class="line">上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo的类，而不是Foo的实例，等同于调用Foo.baz.另外，从这个例子还可以看出，静态方法可以与非静态方法重名</span><br></pre></td></tr></table></figure><p>父类的静态方法，可以被子类继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    static classMethod()&#123;</span><br><span class="line">        return &#39;hello&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Bar extends Foo&#123;&#125;</span><br><span class="line">console.log(Bar.classMethod())&#x2F;&#x2F;hello</span><br><span class="line">这里，父类Foo有一个静态方法，子类Bar可以调用这个方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">静态方法也是可以从super对象上调用的</span><br><span class="line">class Foo&#123;</span><br><span class="line">    static classMethod()&#123;</span><br><span class="line">        return &#39;hello&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Bar extends Foo&#123;</span><br><span class="line">    static classMethod()&#123;</span><br><span class="line">        return super.classMethod()+&#39;,too&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Bar.classMethod())&#x2F;&#x2F;hello,too</span><br></pre></td></tr></table></figure><p>3.实例属性的新写法<br>实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class IncreasingCounter&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this._count &#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">    get value()&#123;</span><br><span class="line">        console.log(&#39;Getting the current value&#39;)</span><br><span class="line">        return this._count</span><br><span class="line">    &#125;</span><br><span class="line">    increment()&#123;</span><br><span class="line">        this._count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码中，实例属性this._count定义在constructor()方法里面，另一种写法是，这个属性也可以定义在类的最顶层，其他都不变</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class IncreasingCounter&#123;</span><br><span class="line">    _count &#x3D; 0</span><br><span class="line">    get value()&#123;</span><br><span class="line">        console.log(&#39;Getter the current value&#39;)</span><br><span class="line">        return this._count</span><br><span class="line">    &#125;</span><br><span class="line">    increment()&#123;</span><br><span class="line">        this._count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码中，实例属性_count与取值函数value()和increment()方法，处于同一层级。这时，不需要在实例属性前面加上this。</span><br><span class="line">这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class foo&#123;</span><br><span class="line">    bar &#x3D; &#39;hello&#39;</span><br><span class="line">    baz &#x3D; &#39;world&#39;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码中，一眼就能看出，foo类有两个实例属性，一目了然。另外，写起来也比较简洁</span><br></pre></td></tr></table></figure><p>4.静态属性<br>静态属性指的是Class 本身的属性，即Class.porpName,而不是定义在实例对象(this)上的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop &#x3D; 1</span><br><span class="line">Foo.prop &#x2F;&#x2F;1</span><br><span class="line">上面的写法为Foo类定义了一个静态属性prop</span><br></pre></td></tr></table></figure><p>目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性。写法是在实例属性的前面，加上static关键字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyClass&#123;</span><br><span class="line">    static myStaticProp &#x3D; 42</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        console.log(MyClass.myStaticProp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">new MyClass()</span><br><span class="line">这个新写法大大方便了静态属性的表达</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;&#x2F;&#x2F;老写法</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop &#x3D;1</span><br><span class="line">class Foo&#123;&#x2F;&#x2F;新写法</span><br><span class="line">    static prop &#x3D;1</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，老写法的静态属性定义在类的外部，整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative）,而不是赋值处理，语义更好。</span><br></pre></td></tr></table></figure><p>5.私有方法和私有属性<br>现在的解决方案<br>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问，这是常见需求，有利于代码的封装，但ES6不提供，只能通过变通方法模拟实现。<br>一种做法是在命名上加以区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Widget&#123;</span><br><span class="line">    &#x2F;&#x2F;公有方法</span><br><span class="line">    foo(baz)&#123;</span><br><span class="line">        this._bar(baz)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;私有属性</span><br><span class="line">    _bar(baz)&#123;</span><br><span class="line">        return this.snaf &#x3D; baz</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，_bar()方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是这种命名是不保险的。在类的外部，还是可以调用到这个方法</span><br></pre></td></tr></table></figure><p>另一种方法就是索性将私有方法移出类，因为类内部的所有方法都是对外可见的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    bar.call(this, baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar(baz) &#123;</span><br><span class="line">  return this.snaf &#x3D; baz;</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，foo是公开方法，内部调用了bar.call(this, baz)。这使得bar()实际上成为了当前类的私有方法。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;class的基本语法:&lt;br&gt;一.类的由来&lt;br&gt;JS中生成实力对象的传统方法是通过构造函数，下面请看一个例子&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
</feed>
