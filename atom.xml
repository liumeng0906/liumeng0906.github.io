<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-30T11:00:42.499Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js严格模式</title>
    <link href="http://example.com/2021/06/09/js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/06/09/js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-06-09T10:47:35.000Z</published>
    <updated>2020-12-30T11:00:42.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-严格模式-use-strict"><a href="#JavaScript-严格模式-use-strict" class="headerlink" title="JavaScript 严格模式(use strict)"></a>JavaScript 严格模式(use strict)</h1><h3 id="使用-“use-strict”-指令"><a href="#使用-“use-strict”-指令" class="headerlink" title="使用 “use strict” 指令"></a>使用 “use strict” 指令</h3><p>“use strict” 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。</p><p>它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。</p><p>“use strict” 的目的是指定代码在严格条件下执行。</p><p>严格模式下你不能使用未声明的变量。<br>支持严格模式的浏览器:<br>Internet Explorer 10 +、 Firefox 4+ Chrome 13+、 Safari 5.1+、 Opera 12+。</p><h3 id="严格模式声明"><a href="#严格模式声明" class="headerlink" title="严格模式声明"></a>严格模式声明</h3><p>严格模式通过在脚本或者函数的头部添加 ‘use static;表达式来声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">x &#x3D; 3.14;       &#x2F;&#x2F; 报错 (x 未定义)</span><br><span class="line">严格模式下，需要用var let 或者 const 来声明</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">myFunction();</span><br><span class="line"></span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    y &#x3D; 3.14;   &#x2F;&#x2F; 报错 (y 未定义)</span><br><span class="line">&#125;</span><br><span class="line">在函数内部声明是局部作用域 (只在函数内使用严格模式):</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; 3.14;       &#x2F;&#x2F; 不报错</span><br><span class="line">myFunction();</span><br><span class="line"></span><br><span class="line">function myFunction() &#123;</span><br><span class="line">   &quot;use strict&quot;;</span><br><span class="line">    y &#x3D; 3.14;   &#x2F;&#x2F; 报错 (y 未定义)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么使用严格模式:</p><p>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;<br>消除代码运行的一些不安全之处，保证代码运行的安全；<br>提高编译器效率，增加运行速度；<br>为未来新版本的Javascript做好铺垫。<br>“严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。</p><p>另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var x &#x3D; 3.14;</span><br><span class="line">delete x;      </span><br><span class="line">不允许删除变量或对象</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function x(p1, p1) &#123;&#125;;   </span><br><span class="line">不允许变量重名</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var x &#x3D; 010;             &#x2F;&#x2F; 报错</span><br><span class="line">不允许使用八进制</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var x &#x3D; \010;            &#x2F;&#x2F; 报错</span><br><span class="line">不允许使用转义字符:</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &quot;x&quot;, &#123;value:0, writable:false&#125;);</span><br><span class="line"></span><br><span class="line">obj.x &#x3D; 3.14;            &#x2F;&#x2F; 报错</span><br><span class="line">不允许对只读属性赋值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var obj &#x3D; &#123;get x() &#123;return 0&#125; &#125;;</span><br><span class="line"></span><br><span class="line">obj.x &#x3D; 3.14;            &#x2F;&#x2F; 报错</span><br><span class="line">不允许对一个使用getter方法读取的属性进行赋值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">delete Object.prototype; &#x2F;&#x2F; 报错</span><br><span class="line">不允许删除一个不允许删除的属性</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var eval &#x3D; 3.14;         &#x2F;&#x2F; 报错</span><br><span class="line">变量名不能使用 &quot;eval&quot; 字符串:</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var arguments &#x3D; 3.14;    &#x2F;&#x2F; 报错</span><br><span class="line">变量名不能使用 &quot;arguments&quot; 字符串</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">with (Math)&#123;x &#x3D; cos(2)&#125;; &#x2F;&#x2F; 报错\</span><br><span class="line">不允许使用一下语句</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">eval (&quot;var x &#x3D; 2&quot;);</span><br><span class="line">alert (x);               &#x2F;&#x2F; 报错</span><br><span class="line">由于一些安全原因，在作用域 eval() 创建的变量不能被调用：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">禁止this关键字指向全局对象。</span><br><span class="line">function f()&#123;</span><br><span class="line">    return !this;</span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F; 返回false，因为&quot;this&quot;指向全局对象，&quot;!this&quot;就是false</span><br><span class="line"></span><br><span class="line">function f()&#123; </span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    return !this;</span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F; 返回true，因为严格模式下，this的值为undefined，所以&quot;!this&quot;为true。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。</span><br><span class="line">function f()&#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    this.a &#x3D; 1;</span><br><span class="line">&#125;;</span><br><span class="line">f();&#x2F;&#x2F; 报错，this未定义</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript-严格模式-use-strict&quot;&gt;&lt;a href=&quot;#JavaScript-严格模式-use-strict&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 严格模式(use strict)&quot;&gt;&lt;/a&gt;JavaScr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HtmlCss</title>
    <link href="http://example.com/2021/02/23/HtmlCss/"/>
    <id>http://example.com/2021/02/23/HtmlCss/</id>
    <published>2021-02-23T01:41:31.000Z</published>
    <updated>2021-02-23T01:46:44.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、css和html-部分"><a href="#一、css和html-部分" class="headerlink" title="一、css和html 部分"></a>一、css和html 部分</h2><h3 id="一、css"><a href="#一、css" class="headerlink" title="一、css"></a>一、css</h3><h4 id="1、css-盒模型"><a href="#1、css-盒模型" class="headerlink" title="1、css 盒模型"></a>1、css 盒模型</h4><pre><code>css盒模型分为标准盒模型和怪异盒模型/IE盒模型基础盒模型：content(内容) + border + padding + margin怪异盒模型/IE盒模型：content (content + border + padding) + margin正常情况下padding和border的设置会影响元素宽高的计算box-sizing: content-box (称为标准盒模型)     width = 元素内容的宽度box-sizing: border-box (称为怪异盒模型/IE盒模型)    width = 元素内容的宽度 + padding + border</code></pre><h4 id="2、box-sizing常用的属性有哪些？分别有什么作用？"><a href="#2、box-sizing常用的属性有哪些？分别有什么作用？" class="headerlink" title="2、box-sizing常用的属性有哪些？分别有什么作用？"></a>2、box-sizing常用的属性有哪些？分别有什么作用？</h4><pre><code>box-sizing: content-box|border-box|inherit;content-box:宽度和高度分别应用到元素的内容框。border-box:通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</code></pre><h4 id="3、清除浮动的方式有哪些"><a href="#3、清除浮动的方式有哪些" class="headerlink" title="3、清除浮动的方式有哪些"></a>3、清除浮动的方式有哪些</h4><pre><code>（1）父级div定义height。（2）结尾处加空div标签clear:both。如：.clear &#123;clear:both &#125;（3）父级div定义伪类:after和zoom。 如： .clearfix:before,.clearfix:after &#123; content: &#39;&#39;; display: table; &#125;  .clearfix:after &#123; clear: both &#125;  .clearfix &#123; *zoom: 1; /*此处是为ie6、7处理的方式 */&#125;（4）父级div定义overflow:hidden。（5）父级div定义overflow:auto。（6）父级div也浮动，需要定义宽度。（7）父级div定义display:table。（8）结尾处加br标签clear:both。</code></pre><h4 id="4、说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8-以下）"><a href="#4、说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8-以下）" class="headerlink" title="4、说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8 以下）"></a>4、说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8 以下）</h4><p>行内元素：会在水平方向排列，不能包含块级元素，设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效。<br>（行内元素 : span,a,label,input,img,strong,em;）</p><p>块级元素：各占据一行，垂直方向排列。从新行开始结束接着一个断行。（块级元素：div,p,h1,form,ul,li;）<br>兼容性：display:inline-block;*display:inline;*zoom:1;</p><h4 id="5、css-选择器有哪些"><a href="#5、css-选择器有哪些" class="headerlink" title="5、css 选择器有哪些"></a>5、css 选择器有哪些</h4><pre><code>id选择器（#id）类选择器（.class）标签选择器（div、p、li）子代选择器（ul&gt;li）后代选择器（ul li）通配符选择器（*）属性选择器（input[type=&quot;text&quot;]、p[class]）伪类选择器（li:first-child、li:nth-child(n)）相邻兄弟选择器（div+p）通用兄弟选择器（div~p）群组选择器（div,span,li,p）相同权重下：内联样式（标签内部） &gt; 嵌入样式（当前文件style） &gt; 外部样式（外部文件）</code></pre><blockquote><p>可以继承的属性：</p></blockquote><pre><code>可继承的样式： font-size font-family color, UL LI DL DD DT;不可继承的样式：border padding margin width height ;优先级：!important &gt; id &gt; class &gt; tagimportant 比 内联优先级高,但内联比 id 要高</code></pre><h4 id="6、内容水平垂直居中有哪些方法"><a href="#6、内容水平垂直居中有哪些方法" class="headerlink" title="6、内容水平垂直居中有哪些方法"></a>6、内容水平垂直居中有哪些方法</h4><pre><code>文本居中：text-align:center; height:100px; line-height:100px;已知宽高：如width:20px;height:20px 父级position:relative 内容position:absolute; left: 50%; top: 50%; margin-left:-10px; margin-top: -10px;不知宽高：父级position:relative 内容position:absolute; left: 50%; top: 50%; transform: translate(-50%, -50%)父级display:flex; align-items: center; justify-content: center; (css3属性)父级display:table; 子级 display: table-cell; vertical-align: middle;</code></pre><h4 id="7、display-none-和-visibility-hidden-有什么区别"><a href="#7、display-none-和-visibility-hidden-有什么区别" class="headerlink" title="7、display: none 和 visibility: hidden 有什么区别"></a>7、display: none 和 visibility: hidden 有什么区别</h4><p>display: none 隐藏 不占空间 （回流 + 重绘）<br>visibility: hidden 隐藏 保留原有空间 （重绘）</p><h4 id="8-回流与重绘"><a href="#8-回流与重绘" class="headerlink" title="8.回流与重绘"></a>8.回流与重绘</h4><h5 id="一、什么是回流"><a href="#一、什么是回流" class="headerlink" title="一、什么是回流?"></a>一、什么是回流?</h5><pre><code>当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。每个页面都至少发生一次回流，也就是页面第一次加载的时候。</code></pre><h5 id="二、什么是重绘"><a href="#二、什么是重绘" class="headerlink" title="二、什么是重绘?"></a>二、什么是重绘?</h5><pre><code>当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。</code></pre><h5 id="三、两者的区别"><a href="#三、两者的区别" class="headerlink" title="三、两者的区别?"></a>三、两者的区别?</h5><p>他们的区别很大：<br>回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流<br>当页面布局和几何属性改变时就需要回流<br>比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变</p><h5 id="四、什么时候会发生回流？"><a href="#四、什么时候会发生回流？" class="headerlink" title="四、什么时候会发生回流？"></a>四、什么时候会发生回流？</h5><p>1、添加或者删除可见的DOM元素的时候<br>2、元素的位置发生改变<br>3、元素尺寸改变<br>4、内容改变<br>5、页面第一次渲染的时候</p><h5 id="五、如何减少回流和重绘？"><a href="#五、如何减少回流和重绘？" class="headerlink" title="五、如何减少回流和重绘？"></a>五、如何减少回流和重绘？</h5><ol><li>使用 transform 替代 top</li><li>使用 visibility 替换 display: none。因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>不要把节点的属性值放在一个循环里当成循环里的变量</li><li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用requestAnimationFrame</li><li>CSS 选择符从右往左匹配查找，避免节点层级过多</li></ol><h4 id="9、BFC（Block-Formatting-Context）-是什么？应用？"><a href="#9、BFC（Block-Formatting-Context）-是什么？应用？" class="headerlink" title="9、BFC（Block Formatting Context） 是什么？应用？"></a>9、BFC（Block Formatting Context） 是什么？应用？</h4><p>BFC 就是 块级格式上下文 的格式，创建了BFC的元素就是一个独立的盒子，不过只有BLock-level box可以参与创建BFC，它规定了内部的Bloc-level Box 如何布局，并且与这个独立盒子里的布局不受外部影响，当然它也不会影响到外面的元素。<br>应用场景：<br>    解决margin叠加的问题<br>    用于布局（overflow: hidden）,BFC不会与浮动盒子叠加。<br>    用于清除浮动，计算BFC高度</p><h4 id="10、列出display的值-说明他们的作用。position的值-relative和absolute分别是相对于谁进行定位的"><a href="#10、列出display的值-说明他们的作用。position的值-relative和absolute分别是相对于谁进行定位的" class="headerlink" title="10、列出display的值,说明他们的作用。position的值,relative和absolute分别是相对于谁进行定位的?"></a>10、列出display的值,说明他们的作用。position的值,relative和absolute分别是相对于谁进行定位的?</h4><pre><code>block 象块类型元素一样显示。inline 缺省值。象行内元素类型一样显示。inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。list-item 象块类型元素一样显示，并添加样式列表标记。absolute     生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。 fixed （老IE不支持）    生成绝对定位的元素，相对于浏览器窗口进行定位。 relative     生成相对定位的元素，相对于其在普通流中的位置进行定位。  static  默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。 inherit 规定从父元素继承 position 属性的值。</code></pre><h4 id="11、CSS3新特性有哪些？"><a href="#11、CSS3新特性有哪些？" class="headerlink" title="11、CSS3新特性有哪些？"></a>11、CSS3新特性有哪些？</h4><pre><code>1.颜色：新增RGBA，HSLA模式2.文字阴影（text-shadow、）3.边框： 圆角（border-radius）边框阴影： box-shadow4.盒子模型：box-sizing5.背景：background-size 设置背景图片的尺寸background-origin 设置背景图片的原点background-clip 设置背景图片的裁切区域，以”，”分隔可以设置多背景，用于自适应布局6.渐变：linear-gradient、radial-gradient7.过渡：transition，可实现动画8.自定义动画9.在CSS3中唯一引入的伪元素是 ：selection.10.媒体查询，多栏布局11.border-image12.2D转换：transform：translate(x，y) rotate(x，y) skew(x，y) scale(x，y)13.3D转换</code></pre><h4 id="12、-css3新增的伪类"><a href="#12、-css3新增的伪类" class="headerlink" title="12、 css3新增的伪类"></a>12、 css3新增的伪类</h4><pre><code>p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :enabled、:disabled 控制表单控件的禁用状态。:checked，单选框或复选框被选中。html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？</code></pre><h4 id="13、css3中单位px-em-rem-vh-vw-vmin-vmax的区别"><a href="#13、css3中单位px-em-rem-vh-vw-vmin-vmax的区别" class="headerlink" title="13、css3中单位px,em,rem,vh,vw,vmin,vmax的区别"></a>13、css3中单位px,em,rem,vh,vw,vmin,vmax的区别</h4><p>px：绝对单位，页面按精确像素展示</p><p>em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。</p><p>rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。</p><p>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。<br>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。<br>vmin：vw和vh中较小的那个。<br>vmax：vw和vh中较大的那个。</p><p>vw, vh, vmin, vmax：IE9+局部支持，chrome/firefox/safari/opera支持，ios safari 8+支持，android browser4.4+支持，chrome for android39支持</p><p>viewport的概念</p><p>移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域.</p><p>就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。</p><h4 id="14、CSS隐藏元素的几种方法-至少说出三种"><a href="#14、CSS隐藏元素的几种方法-至少说出三种" class="headerlink" title="14、CSS隐藏元素的几种方法(至少说出三种)"></a>14、CSS隐藏元素的几种方法(至少说出三种)</h4><p>Opacity:元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互;<br>Visibility:与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏;<br>Display:display 设为 none 任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在;<br>Position:不会影响布局，能让元素保持可以操作;<br>Clip-path:clip-path 属性还没有在 IE 或者 Edge 下被完全支持。如果要在你的 clip-path 中使用外部的 SVG 文件，浏览器支持度还要低;</p><h4 id="15、解释下CSS-sprites-以及你要如何在页面或网站中使用它"><a href="#15、解释下CSS-sprites-以及你要如何在页面或网站中使用它" class="headerlink" title="15、解释下CSS  sprites,以及你要如何在页面或网站中使用它"></a>15、解释下CSS  sprites,以及你要如何在页面或网站中使用它</h4><p>CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了(<code>http2</code>)。</p><h4 id="16、讨论CSS-hacks-条件引用或者其他"><a href="#16、讨论CSS-hacks-条件引用或者其他" class="headerlink" title="16、讨论CSS hacks, 条件引用或者其他"></a>16、讨论CSS hacks, 条件引用或者其他</h4><ul><li>hacks</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_width针对于ie6。*width,+width针对于ie6,7。</span><br><span class="line">color: red\9;&#x2F;*IE8以及以下版本浏览器*&#x2F;（但是测试可以兼容到ie10。</span><br><span class="line">*+html与*html是IE特有的标签, firefox暂不支持.而*+html又为IE7特有标签（但是测试*html兼容ie6-10。*+兼容ie7-10）。</span><br><span class="line">!important 在IE中会被忽视，ie6,7,8不识别，ie9+（包括ie9）是识别的。</span><br></pre></td></tr></table></figure><ul><li>条件引用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if !IE]&gt;&lt;!--&gt; 除IE外都可识别 &lt;!--&lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if IE 6]&gt; 仅IE6可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if lt IE 6]&gt; IE6以及IE6以下版本可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if gte IE 6]&gt; IE6以及IE6以上版本可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if IE 7]&gt; 仅IE7可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if lt IE 7]&gt; IE7以及IE7以下版本可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if IE 9]&gt; 仅IE9可识别 &lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><h4 id="17、css预编译"><a href="#17、css预编译" class="headerlink" title="17、css预编译"></a>17、css预编译</h4><p>就是预先编译处理CSS。它扩展了 CSS 语言，增加了变量、Mixin、函数等编程的特性，使 CSS 更易维护和扩展。CSS预编译的工作原理是提供便捷的语法和特性供开发者编写源代码，随后经过专门的编译工具将源码转化为CSS语法。</p><p>它从这几个方面提升了CSS开发的效率：增强编程能力；增强可复用性；增强可维护性；更便于解决浏览器兼容性。</p><h5 id="为什么要用css预编译"><a href="#为什么要用css预编译" class="headerlink" title="为什么要用css预编译"></a>为什么要用css预编译</h5><pre><code>优点：    可以提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大提高了开发效率。缺点：    调试更麻烦；    容易造成后代选择器的滥用</code></pre><h5 id="css的缺点"><a href="#css的缺点" class="headerlink" title="css的缺点"></a>css的缺点</h5><p>语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器；<br>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</p><h5 id="主流CSS预编译器的介绍"><a href="#主流CSS预编译器的介绍" class="headerlink" title="主流CSS预编译器的介绍"></a>主流CSS预编译器的介绍</h5><p>1.Sass</p><p>2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持和compass这一最强大的CSS框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS。<br>其实现在的Sass已经有了两套语法规则：一个依旧是用缩进作为分隔符来区分代码块的；另一套规则和CSS一样采用了大括号（｛｝）作为分隔符。后一种语法规则又名SCSS，在Sass3之后的版本都支持这种语法规则。</p><pre><code>优点：    用户多，更容易找到会用scss的开发，更容易找到scss的学习资源；    可编程能力比较强，支持函数，列表，对象，判断，循环等；    相比less有更多的功能；    Bootstrap/Foundation等使用scss；    丰富的sass库：Compass/Bourbon；缺点：    安装node-sass会经常失败或者报错，需要使用cnpm或者手工安装</code></pre><p>Sass中文文档：<a href="http://sass.bootcss.com/">http://sass.bootcss.com/</a></p><p>2.Less</p><p>2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手，在ruby社区之外支持者远超过SASS，其缺点是比起SASS来，可编程功能不够，不过优点是简单和兼容CSS，反过来也影响了SASS演变到了SCSS的时代，著名的Twitter Bootstrap就是采用LESS做底层语言的。</p><pre><code>优点：    可以在浏览器中运行，实现主题定制功能；缺点：    编程能力弱，不直接支持对象，循环，判断等；    @variable 变量命名和css的@import/media/keyframes等含义容易混淆；    mixin/extend的语法比较奇怪；    mixin的参数如果遇到多参数和列表参数值的时候容易混淆；</code></pre><p>Less中文文档：<a href="https://less.bootcss.com/">https://less.bootcss.com/</a></p><p>3.Stylus</p><p>2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，在此社区之内有一定支持者，在广泛的意义上人气还完全不如SASS和LESS<br>Stylus被称为是一种革命性的新语言，提供一个高效、动态、和使用表达方式来生成CSS，以供浏览器使用。Stylus同时支持缩进和CSS常规样式书写规则。</p><pre><code>优点：    来自NodeJS社区，所以和NodeJS走得很近，与JavaScript联系非常紧密。还有专门JavaScript API：    http://learnboost.github.io/stylus/docs/js.html    支持Ruby之类等等框架3.更多更强大的支持和功能缺点：    人气不高，教程较少</code></pre><p>Stylus官方文档：<a href="http://stylus-lang.com/">http://stylus-lang.com/</a><br>Stylus 中文文档：<a href="https://www.zhangxinxu.com/jq/stylus/">https://www.zhangxinxu.com/jq/stylus/</a></p><h5 id="Sass和Less的比较"><a href="#Sass和Less的比较" class="headerlink" title="Sass和Less的比较"></a>Sass和Less的比较</h5><p>不同之处</p><p>1、Less环境较Sass简单</p><pre><code>Cass的安装需要安装Ruby环境，Less基于JavaScript，是需要引入Less.js来处理代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放在项目中，有less.app、SimpleLess、CodeKit.app这样的工具，也有在线编辑地址。</code></pre><p>2、Less使用较Sass简单</p><pre><code>LESS 并没有裁剪 CSS 原有的特性，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。只要你了解 CSS 基础就可以很容易上手。</code></pre><p>3、从功能出发，Sass较Less略强大一些</p><pre><code>①sass有变量和作用域。- $variable，like php；- #｛$variable｝like ruby；- 变量有全局和局部之分，并且有优先级。②sass有函数的概念；- @function和@return以及函数参数（还有不定参）可以让你像js开发那样封装你想要的逻辑。-@mixin类似function但缺少像function的编程逻辑，更多的是提高css代码段的复用性和模块化，这个用的人也是最多的。-ruby提供了非常丰富的内置原生api。③进程控制：-条件：@if @else；-循环遍历：@for @each @while-继承：@extend-引用：@import④数据结构：-$list类型=数组；-$map类型=object；其余的也有string、number、function等类型</code></pre><p>4、Less与Sass处理机制不一样</p><pre><code>前者是通过客户端处理的，后者是通过服务端处理，相比较之下前者解析会比后者慢一点</code></pre><p>5、关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。</p><p>相同之处</p><p>Less和Sass在语法上有些共性，比如下面这些：</p><pre><code>1、混入(Mixins)——class中的class；2、参数混入——可以传递参数的class，就像函数一样；3、嵌套规则——Class中嵌套class，从而减少重复的代码；4、运算——CSS中用上数学；5、颜色功能——可以编辑颜色；6、名字空间(namespace)——分组样式，从而可以被调用；7、作用域——局部修改样式；8、JavaScript 赋值——在CSS中使用JavaScript表达式赋值。</code></pre><h4 id="为什么选择使用Sass而不是Less？"><a href="#为什么选择使用Sass而不是Less？" class="headerlink" title="为什么选择使用Sass而不是Less？"></a>为什么选择使用Sass而不是Less？</h4><pre><code>1、Sass在市面上有一些成熟的框架，比如说Compass，而且有很多框架也在使用Sass，比如说Foundation。2、就国外讨论的热度来说，Sass绝对优于LESS。3、就学习教程来说，Sass的教程要优于LESS。在国内LESS集中的教程是LESS中文官网，而Sass的中文教程，慢慢在国内也较为普遍。4、Sass也是成熟的CSS预处理器之一，而且有一个稳定，强大的团队在维护。5、同时还有Scss对sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用&#123;&#125;取代了原来的缩进。6、bootstrap（Web框架）最新推出的版本4，使用的就是Sass。</code></pre><h3 id="二、html"><a href="#二、html" class="headerlink" title="二、html"></a>二、html</h3><h4 id="1、常用那几种浏览器测试？有哪些内核-Layout-Engine"><a href="#1、常用那几种浏览器测试？有哪些内核-Layout-Engine" class="headerlink" title="1、常用那几种浏览器测试？有哪些内核(Layout Engine)?"></a>1、常用那几种浏览器测试？有哪些内核(Layout Engine)?</h4><p>浏览器：IE，Chrome，FireFox，Safari，Opera。<br>　　 内核：Trident，Gecko，Presto，Webkit。</p><h4 id="2、HTML5-为什么只需要写-lt-DOCTYPE-html-gt-？"><a href="#2、HTML5-为什么只需要写-lt-DOCTYPE-html-gt-？" class="headerlink" title="2、HTML5 为什么只需要写&lt;!　DOCTYPE html&gt; ？"></a>2、HTML5 为什么只需要写&lt;!　DOCTYPE html&gt; ？</h4><p>　　HTML5不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p><h4 id="3、页面导入样式时，使用link和-import有什么区别？"><a href="#3、页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="3、页面导入样式时，使用link和@import有什么区别？"></a>3、页面导入样式时，使用link和@import有什么区别？</h4><p>　　（1）本质的差别：link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;<br>　　（2）加载顺序的差别：页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;所以在 @import加载CSS的时候，一开始会没有样式。<br>　　（3）兼容性的差别：import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。<br>　　（4）使用DOM文档对象模型控制样式的差别：当使用JavaScript控制DOM区改变样式的时候，只能使用link标签，而@import是不可以的。<br>　　（5）作用不同：link是属于XHTML，除了可以加载css,还可以定义RSS等其它事务，而@import是属于css范畴，只能加载css。<br>　　（6）权重不同：link方式的权重高于@import的权重值。<br>　　（7）标签不同：import在html使用的时候需要标签，而link在html使用的时候不需要标签。</p><h4 id="4、在HTML当中引用CSS的三种使用方式有哪些？它们之间的区别是什么？"><a href="#4、在HTML当中引用CSS的三种使用方式有哪些？它们之间的区别是什么？" class="headerlink" title="4、在HTML当中引用CSS的三种使用方式有哪些？它们之间的区别是什么？"></a>4、在HTML当中引用CSS的三种使用方式有哪些？它们之间的区别是什么？</h4><p>在HTML当中引用CSS的三种使用方式：<br>    1） 第一种是内联样式表，样式通过style属性内嵌在css的样式当中，写在标签当中。<br>    2） 第二种是内部样式表，通过style标签将CSS的样式写在style属性当中，链入内部的CSS文件。<br>    3） 第三种是外部样式表，通过link标签或者是在style中通过@import的方式引入外部的CSS样式文件。<br>它们之间的区别：<br>    1） 优先级不同，内联样式表的优先级最高，而内部样式表和外部样式表的优先级与书写顺序有关，后书写的优先级高。<br>    2） 作用域不同，内联样式表的作用域最小，只能应用于当前的元素，内部样式表的作用域其次，只能应用于当前的HTML文件，最后是外部样式表的作用域最大，能够适用于所有链接的HTML文件。<br>    3）书写顺序不同，内联样式表写在标签当中，内部样式表写在style标签中来链入内部的CSS文件，外部样式表是通过link或者是@import的方式来链入外部的CSS文件。</p><h4 id="4、html5有哪些新特性？"><a href="#4、html5有哪些新特性？" class="headerlink" title="4、html5有哪些新特性？"></a>4、html5有哪些新特性？</h4><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p><pre><code>(1)拖拽释放(Drag and drop) API(2)视频和音频  用于媒介回放的 video 和 audio 元素;(3)画布(Canvas) API(4)地理(Geolocation) API(5)本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;(6)sessionStorage 的数据在浏览器关闭后自动删除;(7)语意化更好的内容标签，比如 （article、footer、header、nav、section、aside）;(8)表单控件，calendar、date、time、email、url、search;(9)新的技术webworker, websocket, Geolocation;</code></pre><p>IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式</p><h4 id="5、简述一下你对HTML语义化的理解？"><a href="#5、简述一下你对HTML语义化的理解？" class="headerlink" title="5、简述一下你对HTML语义化的理解？"></a>5、简述一下你对HTML语义化的理解？</h4><pre><code>用正确的标签做正确的事情。html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</code></pre><h4 id="6、如何实现浏览器内多个标签页之间的通信"><a href="#6、如何实现浏览器内多个标签页之间的通信" class="headerlink" title="6、如何实现浏览器内多个标签页之间的通信?"></a>6、如何实现浏览器内多个标签页之间的通信?</h4><p>调用localstorge、cookies等本地存储方式</p><h4 id="7、webSocket如何兼容低浏览器？"><a href="#7、webSocket如何兼容低浏览器？" class="headerlink" title="7、webSocket如何兼容低浏览器？"></a>7、webSocket如何兼容低浏览器？</h4><p>Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR</p><h4 id="8、请写出一些前端性能优化的方式"><a href="#8、请写出一些前端性能优化的方式" class="headerlink" title="8、请写出一些前端性能优化的方式"></a>8、请写出一些前端性能优化的方式</h4><pre><code>1.减少dom操作2.部署前，图片压缩，代码压缩3.优化js代码结构，减少冗余代码4.减少http请求，合理设置 HTTP缓存5.使用内容分发cdn加速6.静态资源缓存7.图片延迟加载</code></pre><h4 id="9、iframe的优缺点？"><a href="#9、iframe的优缺点？" class="headerlink" title="9、iframe的优缺点？"></a>9、iframe的优缺点？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.&lt;iframe&gt;优点：</span><br><span class="line">    解决加载缓慢的第三方内容如图标和广告等的加载问题</span><br><span class="line">    Security sandbox</span><br><span class="line">    并行加载脚本</span><br><span class="line">2.&lt;iframe&gt;的缺点：</span><br><span class="line">    *iframe会阻塞主页面的Onload事件；</span><br><span class="line">    *即时内容为空，加载也需要时间</span><br><span class="line">    *没有语意</span><br><span class="line">iframe会阻塞主页面的Onload事件；</span><br><span class="line">搜索引擎的检索程序无法解读这种页面，不利于SEO;</span><br><span class="line">iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</span><br><span class="line">使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。</span><br></pre></td></tr></table></figure><h4 id="10、输入URL回车后的过程"><a href="#10、输入URL回车后的过程" class="headerlink" title="10、输入URL回车后的过程"></a>10、输入URL回车后的过程</h4><p>1.读取缓存：<br>搜索自身的 DNS 缓存。(如果 DNS 缓存中找到IP 地址就跳过了接下来查找 IP 地址步骤，直接访问该 IP 地址。)<br>2.DNS 解析:将域名解析成 IP 地址<br>3.TCP 连接：TCP 三次握手，简易描述三次握手<br>客户端：服务端你在么？<br>服务端：客户端我在，你要连接我么？<br>客户端：是的服务端，我要链接。<br>连接打通，可以开始请求来<br>4.发送 HTTP 请求<br>5.服务器处理请求并返回 HTTP 报文<br>6.浏览器解析渲染页面<br>7.断开连接：TCP 四次挥手</p><p>关于第六步浏览器解析渲染页面又可以聊聊如果返回的是html页面<br>根据 HTML 解析出 DOM 树<br>根据 CSS 解析生成 CSS 规则树<br>结合 DOM 树和 CSS 规则树，生成渲染树<br>根据渲染树计算每一个节点的信息<br>根据计算好的信息绘制页面</p><p>第二种说法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.浏览器查找域名的 IP 地址</span><br><span class="line">2.这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存…</span><br><span class="line">3.浏览器向 web 服务器发送一个 HTTP 请求</span><br><span class="line">4.服务器的永久重定向响应（从 http:&#x2F;&#x2F;example.com 到 http:&#x2F;&#x2F;www.example.com）</span><br><span class="line">5.浏览器跟踪重定向地址</span><br><span class="line">6.服务器处理请求</span><br><span class="line">7.服务器返回一个 HTTP 响应</span><br><span class="line">8.浏览器显示 HTML</span><br><span class="line">9.浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）</span><br><span class="line">10.浏览器发送异步请求</span><br></pre></td></tr></table></figure><h4 id="11、网页布局有哪几种，有什么区别"><a href="#11、网页布局有哪几种，有什么区别" class="headerlink" title="11、网页布局有哪几种，有什么区别"></a>11、网页布局有哪几种，有什么区别</h4><p>静态、自适应、流式、响应式四种网页布局<br>静态布局：意思就是不管浏览器尺寸具体是多少，网页布局就按照当时写代码的布局来布置；<br>自适应布局：就是说你看到的页面，里面元素的位置会变化而大小不会变化；<br>流式布局：你看到的页面，元素的大小会变化而位置不会变化——这就导致如果屏幕太大或者太小都会导致元素无法正常显示。<br>自适应布局：每个屏幕分辨率下面会有一个布局样式，同时位置会变而且大小也会变。</p><h4 id="12、怎么让Chrome支持小于12px-的文字？"><a href="#12、怎么让Chrome支持小于12px-的文字？" class="headerlink" title="12、怎么让Chrome支持小于12px 的文字？"></a>12、怎么让Chrome支持小于12px 的文字？</h4><p>这个我们在做移动端的时候，设计师图片上的文字假如是10px，我们实现在网页上之后。往往设计师回来找我们，这个字体能小一些吗？我设计的是10px？为啥是12px?其实我们都知道，谷歌Chrome最小字体是12px，不管你设置成8px还是10px，在浏览器中只会显示12px，那么如何解决这个坑爹的问题呢？</p><p>我们的做法是：</p><p>针对谷歌浏览器内核，加webkit前缀，用transform:scale()这个属性进行缩放！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;pspan&#123;font-size:10px;-webkit-transform:scale(0.8);display:block;&#125;&lt;&#x2F;style&gt;&lt;p&gt;&lt;span&gt;haorooms博客测试10px&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><h4 id="13、Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#13、Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="13、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>13、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h4><p>（1）、&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器以何种模式来渲染文档。<br>（2）、严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。<br>（3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。<br>（4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</p><h4 id="14、Doctype文档类型？"><a href="#14、Doctype文档类型？" class="headerlink" title="14、Doctype文档类型？"></a>14、Doctype文档类型？</h4><p>该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。<br> HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。<br> XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。<br>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks<br> （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p><h4 id="15、HTML与XHTML——二者有什么区别"><a href="#15、HTML与XHTML——二者有什么区别" class="headerlink" title="15、HTML与XHTML——二者有什么区别"></a>15、HTML与XHTML——二者有什么区别</h4><pre><code>1.所有的标记都必须要有一个相应的结束标记2.所有标签的元素和属性的名字都必须使用小写3.所有的XML标记都必须合理嵌套4.所有的属性必须用引号&quot;&quot;括起来5.把所有&lt;和&amp;特殊符号用编码表示6.给所有属性赋一个值7.不要在注释内容中使“--”8.图片必须有说明文字</code></pre><h4 id="16、常见兼容性问题？"><a href="#16、常见兼容性问题？" class="headerlink" title="16、常见兼容性问题？"></a>16、常见兼容性问题？</h4><ul><li>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.</li><li>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</li><li>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 </li><li>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）<br>#box{ float:left; width:10px; margin:0 0 0 100px;}<br> 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</li><li>渐进识别的方式，从总体中逐渐排除局部。<br>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。<br>接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。<br>css<pre><code>.bb&#123; background-color:#f1ee18;/*所有识别*/.background-color:#00deff\9; /*IE6、7、8识别*/+background-color:#a200ff;/*IE6、7识别*/_background-color:#1e0bd1;/*IE6识别*/ &#125; </code></pre></li><li>IE下,可以使用获取常规属性的方法来获取自定义属性,<br>也可以使用getAttribute()获取自定义属性;<br>Firefox下,只能使用getAttribute()获取自定义属性.<br>解决方法:统一通过getAttribute()获取自定义属性.</li><li>IE下,event对象有x,y属性,但是没有pageX,pageY属性;<br>Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.</li><li>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</li><li>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,<br>可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.</li><li>超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:<br>L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}</li><li>怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在可以使用<a href="http://www.w3.org/TR/html5/single-page.html">html5</a>推荐的写法：<code>&lt;doctype html&gt;</code></li><li>上下margin重合问题<br>ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。<br>解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</li><li>ie6对png图片格式支持不好(引用一段脚本处理)</li></ul><h4 id="17、线程与进程的区别"><a href="#17、线程与进程的区别" class="headerlink" title="17、线程与进程的区别"></a>17、线程与进程的区别</h4><p>一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p><h4 id="18、如何对网站的文件和资源进行优化？"><a href="#18、如何对网站的文件和资源进行优化？" class="headerlink" title="18、如何对网站的文件和资源进行优化？"></a>18、如何对网站的文件和资源进行优化？</h4><p>期待的解决方案包括：<br> 文件合并<br> 文件最小化/文件压缩<br> 使用 CDN 托管<br> 缓存的使用（多个域名来提供缓存）<br> 其他</p><h4 id="19、请说出三种减少页面加载时间的方法。"><a href="#19、请说出三种减少页面加载时间的方法。" class="headerlink" title="19、请说出三种减少页面加载时间的方法。"></a>19、请说出三种减少页面加载时间的方法。</h4><p>1.优化图片<br> 2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）<br> 3.优化CSS（压缩合并css，如margin-top,margin-left…)<br> 4.网址后加斜杠（如<a href="http://www.campr.com/%E7%9B%AE%E5%BD%95%EF%BC%8C%E4%BC%9A%E5%88%A4%E6%96%AD%E8%BF%99%E4%B8%AA%E2%80%9C%E7%9B%AE%E5%BD%95%E6%98%AF%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%88%96%E8%80%85%E6%98%AF%E7%9B%AE%E5%BD%95%E3%80%82%EF%BC%89">www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。）</a><br> 5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。<br>当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）<br>6.减少http请求（合并文件，合并图片）。</p><h4 id="20、什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？"><a href="#20、什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？" class="headerlink" title="20、什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？"></a>20、什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FOUC - Flash Of Unstyled Content 文档样式闪烁</span><br><span class="line"> &lt;style type&#x3D;&quot;text&#x2F;css&quot; media&#x3D;&quot;all&quot;&gt;@import &quot;..&#x2F;fouc.css&quot;;&lt;&#x2F;style&gt; </span><br><span class="line">而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，</span><br><span class="line">因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。</span><br><span class="line">解决方法简单的出奇，只要在&lt;head&gt;之间加入一个&lt;link&gt;或者&lt;script&gt;元素就可以了。</span><br></pre></td></tr></table></figure><h4 id="21、在form表单中，get方式和post方式提交数据的区别是什么？如何判断在实际开发中的应用？"><a href="#21、在form表单中，get方式和post方式提交数据的区别是什么？如何判断在实际开发中的应用？" class="headerlink" title="21、在form表单中，get方式和post方式提交数据的区别是什么？如何判断在实际开发中的应用？"></a>21、在form表单中，get方式和post方式提交数据的区别是什么？如何判断在实际开发中的应用？</h4><p>get方式和post方式提交数据的区别：<br>1） 大小不同，get方式传输的数据量较小，而post可以传输大量的数据。<br>2） 安全程度不同，get方式传输数据能够被别人轻易的看到数据内容，所以安全程度较低，而post则可以很好的隐藏。<br>3） 速度不同，post方式速度较慢，而get方式速度较快。<br>4） 在服务器上的作用不同，get是从服务器上获取数据，而post是向服务器上传送数据。</p><p>在实际开发中的应用：<br>1）在重要数据进行传输数据的时候，用post的方式进行提交数据。<br>2）在做数据查询的时候，用get的方式进行提交数据。<br>3）在做增加、删除和修改数据的时候，用post的方式进行提交数据。</p><h4 id="22、在input表单控件中，value和placeholder的区别是什么？"><a href="#22、在input表单控件中，value和placeholder的区别是什么？" class="headerlink" title="22、在input表单控件中，value和placeholder的区别是什么？"></a>22、在input表单控件中，value和placeholder的区别是什么？</h4><p>placeholder: 表示在输入框中显示的提示信息，用户点击之后，提示信息就会消失。<br>value: 叫做默认值，当用户想要在输入框中输入信息的时候，必须先手动的删除value的值 。</p><h2 id="二、js-部分"><a href="#二、js-部分" class="headerlink" title="二、js 部分"></a>二、js 部分</h2><h3 id="1、js是什么语言"><a href="#1、js是什么语言" class="headerlink" title="1、js是什么语言"></a>1、js是什么语言</h3><p>js是一种运行在浏览器的脚本语言，这种语言主要的功能是可以制作出动态的页面的效果<br>我们可以通过js+css+html布局来形成我们现在可以访问展示的页面</p><p>js语言是弱语言类型， 因此我们在项目开发中当我们随意更改某个变量的数据类型后<br>有可能会导致其他引用这个变量的方法中报错等等。</p><h3 id="1、js-的基本数据类型有哪些，基本数据类型和复杂数据类型的区别"><a href="#1、js-的基本数据类型有哪些，基本数据类型和复杂数据类型的区别" class="headerlink" title="1、js 的基本数据类型有哪些，基本数据类型和复杂数据类型的区别"></a>1、js 的基本数据类型有哪些，基本数据类型和复杂数据类型的区别</h3><p>String、Number、Boolean、Null、undefined</p><p>Object为复杂数据类型</p><p>基本数据类型把数据名和值直接存储在栈当中</p><p>复杂数据类型在栈中存储数据名和一个堆的地址，在堆中存储属性和值，访问时先从栈中获取地址再到堆中取相应的值</p><h3 id="2、-和-有什么区别"><a href="#2、-和-有什么区别" class="headerlink" title="2、== 和 === 有什么区别"></a>2、== 和 === 有什么区别</h3><p>==用于一般比较 比较时可以转换数据类型 </p><p>===用于严格比较 比较时只要类型不匹配就返回false</p><h3 id="3、split-和-join-的区别"><a href="#3、split-和-join-的区别" class="headerlink" title="3、split () 和 join () 的区别"></a>3、split () 和 join () 的区别</h3><p>split() 字符串转数组 如：var str = “hello?word?welcome”  console.log(str.split(“？”)) 返回值为 [“hello”, “word”, “welcome”]</p><p>join() 数组转字符串 如：var arr = new Array() arr[0] = “hello” arr[1] = “world” arr[3] = “welcome” arr.join(“、”)  返回值为 “hello、world、welcome”</p><h3 id="4、call-、bind-、apply-区别"><a href="#4、call-、bind-、apply-区别" class="headerlink" title="4、call ()、bind ()、apply () 区别"></a>4、call ()、bind ()、apply () 区别</h3><p>三者都是可以改变this的指向</p><p>bind() 返回对应函数便于稍后调用；call()、apply()则是立即调用</p><p>call() call(thisArg, case1, case2, case3,…) 第一个参数是对象 后面是字符串</p><p>apply() apply(thisArg, [case1, case2, case3,…]) 第一个参数是对象  后面是数组</p><h3 id="5、数组有哪些操作方法"><a href="#5、数组有哪些操作方法" class="headerlink" title="5、数组有哪些操作方法"></a>5、数组有哪些操作方法</h3><p>unshift()  把参数添加到数组开头<br>shift() 把数组的第一个元素删除<br>push() 向数组末尾添加一个或多个元素<br>pop() 把数组的最后一个元素删除<br>concat() 连接两个或多个数组<br>join() 数组转成字符串<br>reverse() 数组倒叙<br>slice() 截取后返回新数组 [‘H’,’el’,’lo’,’wo’,’rld!’].slice(1,3) 返回 [“el”, “lo”]<br>splice() 添加或删除数组中的元素，这种方法会改变原始数组<br>sort() 数组元素排序<br>filter() 筛选数组<br>Map()  循环数组的每一项</p><h3 id="6、什么是闭包"><a href="#6、什么是闭包" class="headerlink" title="6、什么是闭包"></a>6、什么是闭包</h3><p>可以调用其它函数内部变量的函数<br>简单来说就是函数嵌套函数，内部函数引用来外部函数的变量，从而导致来垃圾回收机制没有生效，变量被保存来下来。<br>也就是所谓的内存泄漏，然后由于内存泄漏又会导致你项目逐渐变得卡顿等等问题。因此要避免内存泄漏。</p><p>优点：避免变量污染、加强了封装性，逻辑性比较强代码的可读性高；加载到内存中执行效率高；</p><p>缺点：在内存中，造成了内存浪费，如果滥用闭包是灾难性的；</p><h3 id="7、null-和-undefined-的区别"><a href="#7、null-和-undefined-的区别" class="headerlink" title="7、null 和 undefined 的区别"></a>7、null 和 undefined 的区别</h3><p>null表示没有对象，该处不该有值，转为数值时为0</p><p>undefined表示缺少值，该处应该有值，但是未定义，转为数值时为NaN</p><h3 id="8、什么是变量提升"><a href="#8、什么是变量提升" class="headerlink" title="8、什么是变量提升"></a>8、什么是变量提升</h3><p>变量提升是js的默认行为，变量提升会将所有变量声明移动到当前作用域的顶部，并可以在声明之前使用该变量，初始化不会被提升，提升的仅作用于变量的声明</p><h3 id="9、什么是事件委托"><a href="#9、什么是事件委托" class="headerlink" title="9、什么是事件委托"></a>9、什么是事件委托</h3><p>利用事件冒泡的原理，把原本需要绑定的事件委托给父元素，让父元素负责事件监听</p><h3 id="10、深拷贝和浅拷贝"><a href="#10、深拷贝和浅拷贝" class="headerlink" title="10、深拷贝和浅拷贝"></a>10、深拷贝和浅拷贝</h3><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p><pre><code>通过ES6新特性Object.assign()与扩展运算符来达到浅拷贝的目的</code></pre><p>深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象</p><pre><code>通过利用JSON.parse(JSON.stringify(Object))来达到深拷贝的目的但是JSON深拷贝的缺点是undefined和function还有symbol类型是无法进行深拷贝的如有需要可以自己手动封装函数来达到目的</code></pre><h3 id="11、async-与-defer-区别"><a href="#11、async-与-defer-区别" class="headerlink" title="11、async 与 defer 区别"></a>11、async 与 defer 区别</h3><p>异步(async) 脚本将在其加载完成后立即执行，而 延迟(defer) 脚本将等待 HTML 解析完成后，并按加载顺序执行。</p><h3 id="12、cookies，sessionStorage-和-localStorage-有什么区别？"><a href="#12、cookies，sessionStorage-和-localStorage-有什么区别？" class="headerlink" title="12、cookies，sessionStorage 和 localStorage 有什么区别？"></a>12、cookies，sessionStorage 和 localStorage 有什么区别？</h3><p>cookies可以和服务端交互，数据大小不会超过4k，设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭，使用方法需要自己封装不够友好;</p><p>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存，虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大，有封装好的方法，可以直接存取值</p><p>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除。</p><h3 id="13、数组去重有哪些方法"><a href="#13、数组去重有哪些方法" class="headerlink" title="13、数组去重有哪些方法"></a>13、数组去重有哪些方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Set()  如：var arr &#x3D; [1,2,3,9,6,3,1,2,6] new set(arr)</span><br></pre></td></tr></table></figure><h4 id="1-利用冒泡-for-循环嵌套，然后-splice-去重-如："><a href="#1-利用冒泡-for-循环嵌套，然后-splice-去重-如：" class="headerlink" title="1.利用冒泡 for 循环嵌套，然后 splice () 去重 如："></a>1.利用冒泡 for 循环嵌套，然后 splice () 去重 如：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr)&#123;            </span><br><span class="line">        for(var i&#x3D;0; i&lt;arr.length; i++)&#123;</span><br><span class="line">            for(var j&#x3D;i+1; j&lt;arr.length; j++)&#123;</span><br><span class="line">                if(arr[i]&#x3D;&#x3D;arr[j])&#123;         &#x2F;&#x2F;第一个等同于第二个，splice方法删除第二个</span><br><span class="line">                    arr.splice(j,1);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line">console.log(unique(arr))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-indexOf-去重-如："><a href="#2-indexOf-去重-如：" class="headerlink" title="2.indexOf () 去重 如："></a>2.indexOf () 去重 如：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#39;type error!&#39;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array &#x3D; [];</span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (array .indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">            array .push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line">    console.log(unique(arr))</span><br></pre></td></tr></table></figure><h4 id="3-sort-去重-如："><a href="#3-sort-去重-如：" class="headerlink" title="3.sort () 去重 如："></a>3.sort () 去重 如：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log(&#39;type error!&#39;) return; &#125; arr &#x3D; arr.sort() var arrry&#x3D; [arr[0]]; for (var i &#x3D; 1; i &lt; arr.length; i++) &#123; if (arr[i] !&#x3D;&#x3D; arr[i-1]) &#123; arrry.push(arr[i]); &#125; &#125; return arrry; &#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line"></span><br><span class="line">console.log(unique(arr))</span><br></pre></td></tr></table></figure><h4 id="4-filter-去重-如"><a href="#4-filter-去重-如" class="headerlink" title="4.filter () 去重 如:"></a>4.filter () 去重 如:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123; return arr.filter(function(item, index, arr) &#123; return arr.indexOf(item, 0) &#x3D;&#x3D;&#x3D; index; &#125;); &#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line"></span><br><span class="line">console.log(unique(arr))</span><br></pre></td></tr></table></figure><h3 id="14、GET-和-POST-有什么区别"><a href="#14、GET-和-POST-有什么区别" class="headerlink" title="14、GET 和 POST 有什么区别"></a>14、GET 和 POST 有什么区别</h3><pre><code>GET请求在浏览器回退和刷新时是无害的，而POST请求会告知用户数据会被重新提交；GET请求可以收藏为书签，POST请求不可以收藏为书签；GET请求可以被缓存，POST请求不可以被缓存，除非在响应头中包含合适的Cache-Control/Expires字段，但是不建议缓存POST请求，其不满足幂等性，每次调用都会对服务器资源造成影响；GET请求一般不具有请求体，因此只能进行url编码，而POST请求支持多种编码方式。GET请求的参数可以被保留在浏览器的历史中，POST请求不会被保留；GET请求因为是向URL添加数据，不同的浏览器厂商，代理服务器，web服务器都可能会有自己的长度限制，而POST请求无长度限制；GET请求只允许ASCII字符，POST请求无限制，支持二进制数据；GET请求的安全性较差，数据被暴露在浏览器的URL中，所以不能用来传递敏感信息，POST请求的安全性较好，数据不会暴露在URL中；GET请求具有幂等性(多次请求不会对资源造成影响)，POST请求不幂等；GET请求一般不具有请求体，请求中一般不包含100-continue 协议，所以只会发一次请求，而POST请求在发送数据到服务端之前允许双方&quot;握手&quot;，客户端先发送Expect:100-continue消息，询问服务端是否愿意接收数据，接收到服务端正确的100-continue应答后才会将请求体发送给服务端，服务端再响应200返回数据。</code></pre><h3 id="15、跨域有几种解决方案"><a href="#15、跨域有几种解决方案" class="headerlink" title="15、跨域有几种解决方案"></a>15、跨域有几种解决方案</h3><p>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。<br>为来防止CSRF攻击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.JSONP</span><br><span class="line">    JSONP 的原理很简单，就是利用 &lt;script&gt; 标签没有跨域限制的漏洞。</span><br><span class="line">    通过 &lt;script&gt; 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。</span><br><span class="line">    &lt;script src&#x3D;&quot;http:&#x2F;&#x2F;domain&#x2F;api?param1&#x3D;a&amp;param2&#x3D;b&amp;callback&#x3D;jsonp&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function jsonp(data) &#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">    JSONP 使用简单且兼容性不错，但是只限于 get 请求。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2.CORS</span><br><span class="line">    CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。</span><br><span class="line">3.document.domain</span><br><span class="line">    该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。</span><br><span class="line">    只需要给页面添加 document.domain &#x3D; &#39;test.com&#39; 表示二级域名都相同就可以实现跨域</span><br><span class="line">4.webpack配置proxyTable设置开发环境跨域</span><br><span class="line">5.nginx代理跨域</span><br><span class="line">6.iframe跨域</span><br><span class="line">7.postMessage</span><br><span class="line">    这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</span><br></pre></td></tr></table></figure><h3 id="16、typeof-和-instanceof-有什么区别"><a href="#16、typeof-和-instanceof-有什么区别" class="headerlink" title="16、typeof 和 instanceof 有什么区别"></a>16、typeof 和 instanceof 有什么区别</h3><pre><code>typeof 判断一个数据是什么数据类型；一般只能返回如下几个结果：&quot;number&quot;、&quot;string&quot;、&quot;boolean&quot;、&quot;object&quot;、&quot;function&quot; 和 &quot;undefined&quot;。instanceof 判断一个对象是否在另一个对象的原型链上</code></pre><h3 id="17、原型"><a href="#17、原型" class="headerlink" title="17、原型"></a>17、原型</h3><p>构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象。<br>每个函数都有prototype(原型)属性，这个属性是一个指针，指向一个对象，<br>这个对象的用途是包含特定类型的所有实例共享的属性和方法，即这个原型对象是用来给实例共享属性和方法的。<br>而每个实例内部都有一个指向原型对象的指针。</p><h3 id="18、"><a href="#18、" class="headerlink" title="18、/"></a>18、/</h3><h3 id="19、"><a href="#19、" class="headerlink" title="19、/"></a>19、/</h3><h3 id="20、"><a href="#20、" class="headerlink" title="20、/"></a>20、/</h3><h3 id="21、"><a href="#21、" class="headerlink" title="21、/"></a>21、/</h3><h2 id="三、vue-部分"><a href="#三、vue-部分" class="headerlink" title="三、vue 部分"></a>三、vue 部分</h2><h3 id="1、vue-的生命周期以及页面初次加载会触发哪些钩子"><a href="#1、vue-的生命周期以及页面初次加载会触发哪些钩子" class="headerlink" title="1、vue 的生命周期以及页面初次加载会触发哪些钩子"></a>1、vue 的生命周期以及页面初次加载会触发哪些钩子</h3><p>beforeCreate<br>created<br>beforeMount<br>mounted<br>beforeUpdate<br>updated<br>beforeDestroy<br>destroyed<br>第一次会触发前四个钩子</p><h3 id="2、v-if-和-v-for-哪一个优先级高"><a href="#2、v-if-和-v-for-哪一个优先级高" class="headerlink" title="2、v-if 和 v-for 哪一个优先级高"></a>2、v-if 和 v-for 哪一个优先级高</h3><p>v-for优先级高</p><h3 id="3、v-if-和-v-show-有什么异同"><a href="#3、v-if-和-v-show-有什么异同" class="headerlink" title="3、v-if 和 v-show 有什么异同"></a>3、v-if 和 v-show 有什么异同</h3><p>两者都可以控制元素的显示和隐藏</p><p>v-if 是动态的向DOM树内添加或者删除DOM元素，若初始值为false，就不会编译了。而且v-if不停的销毁和创建比较消耗性能。</p><p>v-show 是通过控制css中的display设置为none，控制隐藏，只会编译一次</p><h3 id="4、vue-中-data-为什么必须是一个函数"><a href="#4、vue-中-data-为什么必须是一个函数" class="headerlink" title="4、vue 中 data 为什么必须是一个函数"></a>4、vue 中 data 为什么必须是一个函数</h3><p>防止组件在重复使用时，数据互相干扰，使用函数将产生新作用域，所以同一个组件在不同位置被使用时，不适用同一份数据</p><h3 id="5、v-for-里面-key-的作用"><a href="#5、v-for-里面-key-的作用" class="headerlink" title="5、v-for 里面 key 的作用"></a>5、v-for 里面 key 的作用</h3><p>key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度，具有唯一性</p><h3 id="6、传值方式有哪些"><a href="#6、传值方式有哪些" class="headerlink" title="6、传值方式有哪些"></a>6、传值方式有哪些</h3><p>父传子 在子元素中用 props 接收<br>子传父 在子元素中用 $emit 传值<br>同级传值 使用路由query/params传参 如 this.$router.push({path: ‘/‘, query: {参数名: ‘参数值’})  使用this.$route.query.参数名 接收<br>本地存储传值</p><h3 id="7、初始化页面闪动问题"><a href="#7、初始化页面闪动问题" class="headerlink" title="7、初始化页面闪动问题"></a>7、初始化页面闪动问题</h3><p>在css里加上[v-cloak] {display: none;}<br>如果没有彻底解决问题，则在根元素加上 style=“display: none;” :style=”{display: ‘block’}”</p><h3 id="8、route和route和-router-的区别"><a href="#8、route和route和-router-的区别" class="headerlink" title="8、route和route和 router 的区别"></a>8、route和route和 router 的区别</h3><p>$router是VueRouter的实例，在script标签中想要导航到不同的URL,使用$router.push方法。返回上一个历史history用$router.to(-1)<br>$route为当前router跳转对象。里面可以获取当前路由的name,path,query,parmas等。</p><h3 id="9、vuex-有哪几种状态"><a href="#9、vuex-有哪几种状态" class="headerlink" title="9、vuex 有哪几种状态"></a>9、vuex 有哪几种状态</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态<br>并以相应的规则保证状态以一种可预测的方式发生变化。</p><pre><code>state 基本数据(数据源存放地)Getter 过滤/计数。store 的计算属性 返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation 必须是同步函数Action 类似于 mutation 提交的是 mutation，而不是直接变更状态。 可以包含任意异步操作。Module 将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割</code></pre><h3 id="10、vue-router-有几种模式"><a href="#10、vue-router-有几种模式" class="headerlink" title="10、vue-router 有几种模式"></a>10、vue-router 有几种模式</h3><pre><code>hash模式 地址栏URL中的#符号，不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。history模式 利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法，这两个方法应用于浏览器的历史记录站，在当前已有的back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改是，虽然改变了当前的URL，但你浏览器不会立即向后端发送请求。history模式，会出现404 的情况，需要后台配置。</code></pre><h3 id="11、vue-实现数据双向绑定的原理"><a href="#11、vue-实现数据双向绑定的原理" class="headerlink" title="11、vue 实现数据双向绑定的原理"></a>11、vue 实现数据双向绑定的原理</h3><p>采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。即数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变</p><h3 id="12、路由跳转的原理以及方式"><a href="#12、路由跳转的原理以及方式" class="headerlink" title="12、路由跳转的原理以及方式"></a>12、路由跳转的原理以及方式</h3><p>路由就是根据不同的url地址展示不同的内容或页面<br>静态路由是在路由器中设置的固定的路由表。<br>动态路由是网络中的路由器之间相互通信，传递路由信息，利用收到的路由信息更新路由器表的过程。</p><p>this.$router.push({name:’master’,params:{id:’参数’}});<br>//name和params搭配，刷新的话，参数会消失<br>this.$router.push({path:’/master’,query:{id:’参数’}});<br>//path和query搭配，刷新页面的话，url中的参数不会丢失,query中的参数成了url中的一部分<br>this.$router.push()<br>跳转到不同的url，但这个方法回向history栈添加一个记录，点击后退会返回到上一个页面。<br>this.$router.replace()<br>描述：同样是跳转到指定的url，但是这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。<br>this.$router.go(n)<br>相对于当前页面向前或向后跳转多少个页面,类似 window.history.go(n)。n可为正数可为负数。正数返回上一个页面</p><h3 id="13、Vue路由守卫有哪些，怎么设置，使用场景等"><a href="#13、Vue路由守卫有哪些，怎么设置，使用场景等" class="headerlink" title="13、Vue路由守卫有哪些，怎么设置，使用场景等"></a>13、Vue路由守卫有哪些，怎么设置，使用场景等</h3><pre><code>常用的两个路由守卫：router.beforeEach 和 router.afterEach每个守卫方法接收三个参数：to: Route: 即将要进入的目标 路由对象from: Route: 当前导航正要离开的路由next: Function: 一定要调用该方法来 resolve 这个钩子。在项目中，一般在beforeEach这个钩子函数中进行路由跳转的一些信息判断。判断是否登录，是否拿到对应的路由权限等等。</code></pre><h3 id="13、computed-和-watch-有什么区别"><a href="#13、computed-和-watch-有什么区别" class="headerlink" title="13、computed 和 watch 有什么区别"></a>13、computed 和 watch 有什么区别</h3><p>computed是多条数据影响一个数据，而watch，则是一个数据影响多个数据</p><p>computed 支持缓存，只有数据发生变化才会重新进行计算，不支持异步。 购物车商品结算</p><p>watch 不支持缓存，支持异步，默认初次不会执行。 搜索数据 </p><p>immediate 选项为 true，可以立即执行一次方法<br>deep: true 深度监听 方法 下面的属性层层遍历，都加上监听事件</p><h3 id="14、VUE-里-data-为什么是函数"><a href="#14、VUE-里-data-为什么是函数" class="headerlink" title="14、VUE 里 data 为什么是函数"></a>14、VUE 里 data 为什么是函数</h3><p>组件中的data写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。</p><h2 id="四、其它"><a href="#四、其它" class="headerlink" title="四、其它"></a>四、其它</h2><h3 id="1、什么是-MVC-和-MVVM"><a href="#1、什么是-MVC-和-MVVM" class="headerlink" title="1、什么是 MVC 和 MVVM"></a>1、什么是 MVC 和 MVVM</h3><p>MVC模式：Controller负责将Model的数据用View显示出来</p><p>M：Model（数据模型），用于存放数据<br>V：View（视图），也就是用户界面<br>C：Controller是Model和View的协调者</p><p>MVVM模式：VM双向绑定，在 MVVM 框架中，View(视图) 和 Model(数据) 是不可以直接通讯的</p><p>M：Movel（数据模型）<br>V：View<br>VM：ViewModel 是一个同步View 和 Model的对象</p><h3 id="2、页面导入样式时，使用-link-和-import-有什么区别？"><a href="#2、页面导入样式时，使用-link-和-import-有什么区别？" class="headerlink" title="2、页面导入样式时，使用 link 和 @import 有什么区别？"></a>2、页面导入样式时，使用 link 和 @import 有什么区别？</h3><p>link属于XHTML标签，除了加载CSS外，还能用于定义RSS,定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;</p><p>页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</p><p>import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;</p><h3 id="3、优雅降级和渐进增强"><a href="#3、优雅降级和渐进增强" class="headerlink" title="3、优雅降级和渐进增强"></a>3、优雅降级和渐进增强</h3><p>渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p><p>优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p><p>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</p><h3 id="4、浏览器页面有哪三层构成，分别是什么，作用是什么？"><a href="#4、浏览器页面有哪三层构成，分别是什么，作用是什么？" class="headerlink" title="4、浏览器页面有哪三层构成，分别是什么，作用是什么？"></a>4、浏览器页面有哪三层构成，分别是什么，作用是什么？</h3><p>构成：结构层、表示层、行为层</p><p>分别是：HTML、CSS、JavaScript</p><p>作用：HTML实现页面结构，CSS完成页面的表现与风格，JavaScript实现一些客户端的功能与业务。</p><h3 id="5、页面重构怎么操作？"><a href="#5、页面重构怎么操作？" class="headerlink" title="5、页面重构怎么操作？"></a>5、页面重构怎么操作？</h3><p>页面重构是指：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。</p><p>编写css、让页面结构更合理化，提升用户体验，实现良好的页面效果和提升性能。</p><h3 id="6、前端性能优化"><a href="#6、前端性能优化" class="headerlink" title="6、前端性能优化"></a>6、前端性能优化</h3><p>避免使用css表达式，避免使用高级选择器，通配选择器。</p><p>缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等</p><p>css放在顶部，js放在底部</p><p>减少@import导入css（同步操作）</p><p>合并样式和脚本</p><p>使用css图片精灵，图片懒加载</p><p>减少http请求</p><p>初始首屏之外的图片资源按需加载，静态资源延迟加载。</p><p>压缩文件，开启GZIP，</p><p>少用全局变量，合理使用闭包</p><p>用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能</p><p>避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率</p><h3 id="7、http-请求过程"><a href="#7、http-请求过程" class="headerlink" title="7、http 请求过程"></a>7、http 请求过程</h3><p>HTTP是超文本传输协议，它是TCP/IP协议的一个应用层协议，用于定义WEB浏览器与WEB服务器之间交换数据的过程以及通迅的格式</p><pre><code>域名解析发起TCP的3次握手建立TCP连接后发起http请求服务器端响应http请求，浏览器得到html代码浏览器解析html代码，并请求html代码中的资源浏览器对页面进行渲染呈现给用户</code></pre><h3 id="8、HTTP-常见状态码"><a href="#8、HTTP-常见状态码" class="headerlink" title="8、HTTP 常见状态码"></a>8、HTTP 常见状态码</h3><pre><code>200 OK 客户端请求成功。301 Moved Permanently 请求永久重定向。302 Moved Temporarily 请求临时重定向。304 Not Modified 文件未修改，可以直接使用缓存的文件。400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。401 Unauthorized 请求未经授权，无法访问。403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。404 Not Found 请求的资源不存在，比如输入了错误的URL。500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</code></pre><h3 id="9、一个完整的-url-包括哪几部分"><a href="#9、一个完整的-url-包括哪几部分" class="headerlink" title="9、一个完整的 url 包括哪几部分"></a>9、一个完整的 url 包括哪几部分</h3><p>协议部分、域名部分、端口部分、虚拟目录部分、文件名部分、参数部分、锚部分</p><h3 id="10、webpack配置入口出口"><a href="#10、webpack配置入口出口" class="headerlink" title="10、webpack配置入口出口"></a>10、webpack配置入口出口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    &#x2F;&#x2F;入口文件的配置项</span><br><span class="line">    entry:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;出口文件的配置项</span><br><span class="line">    output:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;模块：例如解读CSS,图片如何转换，压缩</span><br><span class="line">    module:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;插件，用于生产模版和各项功能</span><br><span class="line">    plugins:[],</span><br><span class="line">    &#x2F;&#x2F;配置webpack开发服务功能</span><br><span class="line">    devServer:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11、webpack3和webpack4区别"><a href="#11、webpack3和webpack4区别" class="headerlink" title="11、webpack3和webpack4区别"></a>11、webpack3和webpack4区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.mode</span><br><span class="line"> </span><br><span class="line">webpack增加了一个mode配置，只有两种值development | production。对不同的环境他会启用不同的配置。</span><br><span class="line"> </span><br><span class="line">2.CommonsChunkPlugin</span><br><span class="line"> </span><br><span class="line">CommonChunksPlugin已经从webpack4中移除。</span><br><span class="line">可使用optimization.splitChunks进行模块划分（提取公用代码）。</span><br><span class="line">但是需要注意一个问题，默认配置只会对异步请求的模块进行提取拆分，如果要对entry进行拆分</span><br><span class="line">需要设置optimization.splitChunks.chunks &#x3D; &#39;all&#39;。</span><br><span class="line"> </span><br><span class="line">3.webpack4使用MiniCssExtractPlugin取代ExtractTextWebpackPlugin。</span><br><span class="line"> </span><br><span class="line">4.代码分割。</span><br><span class="line"> </span><br><span class="line">使用动态import，而不是用system.import或者require.ensure</span><br><span class="line"> </span><br><span class="line">5.vue-loader。</span><br><span class="line"> </span><br><span class="line">使用vue-loader插件为.vue文件中的各部分使用相对应的loader，比如css-loader等</span><br><span class="line"> </span><br><span class="line">6.UglifyJsPlugin</span><br><span class="line"> </span><br><span class="line">现在也不需要使用这个plugin了，只需要使用optimization.minimize为true就行，production mode下面自动为true</span><br><span class="line"> </span><br><span class="line">optimization.minimizer可以配置你自己的压缩程序</span><br></pre></td></tr></table></figure><h3 id="12、es6新特性"><a href="#12、es6新特性" class="headerlink" title="12、es6新特性"></a>12、es6新特性</h3><p>1.ES6引入来严格模式<br>    变量必须声明后在使用<br>    函数的参数不能有同名属性, 否则报错<br>    不能使用with语句 (说实话我基本没用过)<br>    不能对只读属性赋值, 否则报错<br>    不能使用前缀0表示八进制数,否则报错 (说实话我基本没用过)<br>    不能删除不可删除的数据, 否则报错<br>    不能删除变量delete prop, 会报错, 只能删除属性delete global[prop]<br>    eval不会在它的外层作用域引入变量<br>    eval和arguments不能被重新赋值<br>    arguments不会自动反映函数参数的变化<br>    不能使用arguments.caller (说实话我基本没用过)<br>    不能使用arguments.callee (说实话我基本没用过)<br>    禁止this指向全局对象<br>    不能使用fn.caller和fn.arguments获取函数调用的堆栈 (说实话我基本没用过)<br>    增加了保留字（比如protected、static和interface）</p><p>2.关于let和const新增的变量声明</p><p>3.变量的解构赋值</p><p>4.字符串的扩展<br>    includes()：返回布尔值，表示是否找到了参数字符串。<br>    startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。<br>    endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。<br>5.数值的扩展<br>    Number.isFinite()用来检查一个数值是否为有限的（finite）。<br>    Number.isNaN()用来检查一个值是否为NaN。<br>6.函数的扩展<br>    函数参数指定默认值<br>7.数组的扩展<br>    扩展运算符<br>8.对象的扩展<br>    对象的解构<br>9.新增symbol数据类型</p><p>10.Set 和 Map 数据结构<br>    ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。</p><pre><code>Map它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</code></pre><p>11.Proxy<br>    Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问<br>    都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<br>    Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。<br>    Vue3.0使用了proxy<br>12.Promise<br>    Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。<br>    特点是：<br>        对象的状态不受外界影响。<br>        一旦状态改变，就不会再变，任何时候都可以得到这个结果。<br>13.async 函数<br>    async函数对 Generator 函数的区别：<br>    （1）内置执行器。<br>    Generator 函数的执行必须靠执行器，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。<br>    （2）更好的语义。<br>    async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。<br>    （3）正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。<br>    （4）返回值是 Promise。<br>    async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。<br>14.Class<br>    class跟let、const一样：不存在变量提升、不能重复声明…<br>    ES6 的class可以看作只是一个语法糖，它的绝大部分功能<br>    ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。<br>15.Module<br>    ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。<br>    import和export命令以及export和export default的区别</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、css和html-部分&quot;&gt;&lt;a href=&quot;#一、css和html-部分&quot; class=&quot;headerlink&quot; title=&quot;一、css和html 部分&quot;&gt;&lt;/a&gt;一、css和html 部分&lt;/h2&gt;&lt;h3 id=&quot;一、css&quot;&gt;&lt;a href=&quot;#一、cs</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hook中的API</title>
    <link href="http://example.com/2020/12/26/Hook/"/>
    <id>http://example.com/2020/12/26/Hook/</id>
    <published>2020-12-26T01:02:04.000Z</published>
    <updated>2020-12-30T10:41:37.558Z</updated>
    
    <content type="html"><![CDATA[<p>Hook 是React 16.8的新增特性。它可以让你在不编写 class的情况下使用 state 以及其他的 React特性。<br>   Hook是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数<br>   Hook 不能在 class 组件中使用<br>   <code>const [state, setState] = useState(initialState)</code><br>   返回一个 state,以及更新 state 的函数<br>   当 state 为引用类型，修改时注意要合并其他值，不然会发生错误<br>   多个 state 最好分开写<br>   setState 也可以接收一个函数</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function Home()&#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(0)</span><br><span class="line">    &#x2F;&#x2F;也可以在state里写对象</span><br><span class="line">    const [person, setPerson] &#x3D; useState(&#123;</span><br><span class="line">        name:&#39;大黄&#39;,</span><br><span class="line">        age:&#39;18&#39;,</span><br><span class="line">        sex:&#39;女&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">    const [num,setNum] &#x3D; useState(100)</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            我是todolist</span><br><span class="line">            count:&#123;count&#125;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setCount(count+1)&#125;&#125;&gt;加+&lt;&#x2F;button&gt;</span><br><span class="line">            &#123;&#x2F;* setCount和class组件setState是一样的都是修改state的状态的*&#x2F;&#125;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                name:&#123;person.name&#125;</span><br><span class="line">                age:&#123;person.age&#125;</span><br><span class="line">                sex:&#123;person.sex&#125;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setPerson(&#123;age:19&#125;)&#125;&#125;&gt;给大黄过年&lt;&#x2F;button&gt;</span><br><span class="line">                &#123;&#x2F;* 这里当我们点击了按钮调用setState，只修改了age,虽然年龄变成了19，但是其他属性都为空了，所以说</span><br><span class="line">                    在调用setState时，如果它是个引用类型时我们要它另外值合并一下</span><br><span class="line">                    onClick&#x3D;&#123;()&#x3D;&gt;&#123;setPerson(&#123;age:19,name:person.name,sex:person.sex&#125;)&#125;&#125;</span><br><span class="line">                    这样写就没问题了</span><br><span class="line">                *&#x2F;&#125;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                计数：&#123;num&#125;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setNum((oval)&#x3D;&gt;&#123;console.log(oval);return oval+1&#125;)&#125;&#125;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">                &#123;&#x2F;* setState还可以接收一个函数 *&#x2F;&#125;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">export default Home</span><br></pre></td></tr></table></figure><h1 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;参数是个函数：也叫副作用函数</span><br><span class="line">         return ()&#x3D;&gt;&#123;&#125;&#x2F;&#x2F;返回函数 返回的函数式可选的  可以不写返回函数</span><br><span class="line">     &#125;,[])&#x2F;&#x2F;这里的数组是依赖参数   依赖也是可选的</span><br><span class="line">    作用函数：</span><br><span class="line">     1.当useEffect ,没有依赖参数时，副作用函数，会在组件挂载完成及组件更新完成时执行</span><br><span class="line">     2.当有依赖参数副作用函数，会在组件挂载完成及改依赖参数修改，引起的组件更新完成之后执行</span><br><span class="line">     3.当依赖参数为空数组时，会在组件挂载完成之后执行</span><br><span class="line">     4.返回函数在组件更新完成，或即将写在执行，一般返回函数用在即将卸载时</span><br><span class="line">     useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;当没有依赖参数和返回函数的时候，现在就相当于class组件的componentDidMount、componentUpdate生命周期</span><br><span class="line">    console.log(1,&#39;useEffect&#39;)&#x2F;&#x2F;一直触发btn，一直在打印</span><br><span class="line">&#125;)</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;当依赖参数为空和没有返回函数时，只执行了一次，后面在触发btn时，不在执行.相当于componentDidMount</span><br><span class="line">    console.log(2,&#39;useEffect&#39;)</span><br><span class="line">&#125;,[])</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(3,&#39;useEffect&#39;)</span><br><span class="line">&#125;,[name])&#x2F;&#x2F;在有依赖参数时，组件挂载完会执行一次，在后面触发btn时，如果依赖参数没有发生改变，不会再打印</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">    return ()&#x3D;&gt;&#123;</span><br><span class="line">        console.log(4,&#39;useEffect&#39;)</span><br><span class="line">    &#125;&#x2F;&#x2F;当没有依赖，有返回函数的时候，初次挂载完返回函数不会执行，但是当触发btn时，就是组件发生改变，它就会执行返回函数的代码</span><br><span class="line">&#125;,)&#x2F;&#x2F;如果此处有依赖，但不空，那就当依赖的参数发生改变的时候，返回函数内的代码也会执行</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">    return ()&#x3D;&gt;&#123;</span><br><span class="line">        console.log(&#39;更新或者卸载&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[count])&#x2F;&#x2F;也可以有依赖参数并且会更新用返回函数进行卸载或更新</span><br><span class="line">&#x2F;&#x2F;缺点：挂载前和更新前的生命周期要用到别的方法来配合使用useEffect。这里更多的是挂载完和更新完</span><br></pre></td></tr></table></figure><h1 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h1><p>其函数签名与useEffect相同，但它会在所有的DOM变更之后同步调用effect。可以使用它来读取DOM布局并同步触发重渲染，在浏览器执行绘制之前，useLayoutEffect内部的更新计划将不同步刷新</p><h1 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">一个简单的传参案例基本就能明白useContext是在干神马。</span><br><span class="line">import React,&#123;createContext, useContext&#125; from &#39;react&#39;</span><br><span class="line">const DemoContext &#x3D; createContext(&#123;data:&#39;hello&#39;&#125;)</span><br><span class="line">function A ()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;DemoContext.Provider value&#x3D;&#123;&#123;data:value&#125;&#125;&gt;</span><br><span class="line">            &lt;B&gt;&lt;&#x2F;B&gt;</span><br><span class="line">        &lt;&#x2F;DemoContext.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">function B()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            儿子组件</span><br><span class="line">            &lt;C&gt;&lt;&#x2F;C&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">function C()&#123;</span><br><span class="line">    const text &#x3D; useContext(DemoContext)</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            孙子组件</span><br><span class="line">            &#123;</span><br><span class="line">                text.data</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">export default A</span><br></pre></td></tr></table></figure><h1 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">在我们的需要处理的数据足够简单时，用useState就能完成。如果数据比较复杂了那么就可以考虑用useReducer</span><br><span class="line">这个先说下useReducer跟Store没关系，他只是借用了store的那套思想</span><br><span class="line">直接上案例</span><br><span class="line">import React, &#123; useState, useEffect, useReducer, useRef &#125; from &#39;react&#39;</span><br><span class="line">import &#123; withRouter &#125; from &#39;react-router-dom&#39;</span><br><span class="line">import &#123; connect &#125; from &#39;react-redux&#39;</span><br><span class="line">import s from &#39;.&#x2F;index.module.scss&#39;</span><br><span class="line">let init &#x3D; &#123; list: [&#123;</span><br><span class="line">    id:1,</span><br><span class="line">    name:&#39;澳门豆捞&#39;,</span><br><span class="line">    open:1</span><br><span class="line">&#125;] &#125;</span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &#39;add&#39;:</span><br><span class="line">            let arr &#x3D; JSON.parse(JSON.stringify(state.list)) </span><br><span class="line">            arr.push(&#123;</span><br><span class="line">                id: state.list.length &gt; 0 ? state.list[state.list.length-1].id + 1 : 1,</span><br><span class="line">                name: action.name,</span><br><span class="line">                open: 1,</span><br><span class="line">            &#125;)</span><br><span class="line">            return &#123;list:arr&#125;</span><br><span class="line">        case &#39;close&#39;:</span><br><span class="line">           for(let i&#x3D;0;i&lt;state.list.length;i++)&#123;</span><br><span class="line">               if(state.list[i].id&#x3D;&#x3D;action.id)&#123;</span><br><span class="line">                   state.list[i].open&#x3D;2</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return JSON.parse(JSON.stringify(state))</span><br><span class="line">        case &#39;open&#39;:</span><br><span class="line">           for(let i&#x3D;0;i&lt;state.list.length;i++)&#123;</span><br><span class="line">               if(state.list[i].id&#x3D;&#x3D;action.id)&#123;</span><br><span class="line">                   state.list[i].open&#x3D;1</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return JSON.parse(JSON.stringify(state))</span><br><span class="line">        case &#39;set&#39;:</span><br><span class="line">           for(let i&#x3D;0;i&lt;state.list.length;i++)&#123;</span><br><span class="line">               if(state.list[i].id&#x3D;&#x3D;action.id)&#123;</span><br><span class="line">                   state.list[i].open&#x3D;3</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return JSON.parse(JSON.stringify(state))</span><br><span class="line">        case &#39;del&#39;:</span><br><span class="line">           for(let i&#x3D;0;i&lt;state.list.length;i++)&#123;</span><br><span class="line">               if(state.list[i].id&#x3D;&#x3D;action.id)&#123;</span><br><span class="line">                   state.list.splice(i,1)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return JSON.parse(JSON.stringify(state))</span><br><span class="line">        default:</span><br><span class="line">            return state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Homet(props) &#123;</span><br><span class="line">    const inp &#x3D; useRef(null)</span><br><span class="line">    const [state, dispatch] &#x3D; useReducer(reducer, init)</span><br><span class="line">    function btn() &#123;</span><br><span class="line">        if (!inp.current.value) &#123;</span><br><span class="line">            alert(&#39;输入不能为空&#39;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: &#39;add&#39;,</span><br><span class="line">                name: inp.current.value,</span><br><span class="line">            &#125;)</span><br><span class="line">            inp.current.value&#x3D;null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div className&#x3D;&#123;s.homet&#125;&gt;</span><br><span class="line">            &lt;div className&#x3D;&#123;s.head&#125;&gt;</span><br><span class="line">                &lt;span&gt;Todo后台管理&lt;&#x2F;span&gt;</span><br><span class="line">                &lt;div className&#x3D;&#123;s.inpBox&#125;&gt;</span><br><span class="line">                    &lt;input ref&#x3D;&#123;inp&#125; placeholder&#x3D;&#39;请输入内容&#39; &#x2F;&gt;</span><br><span class="line">                    &lt;button onClick&#x3D;&#123;() &#x3D;&gt; btn()&#125; className&#x3D;&#123;s.btn&#125;&gt;添加&lt;&#x2F;button&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div className&#x3D;&#123;s.cont&#125;&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    state.list.length &gt; 0 ? state.list.map((item, i) &#x3D;&gt; &lt;div className&#x3D;&#123;s.item&#125; key&#x3D;&#123;i&#125;&gt;</span><br><span class="line">                        &lt;img &#x2F;&gt;</span><br><span class="line">                        &lt;div className&#x3D;&#123;s.all&#125;&gt;</span><br><span class="line">                            &lt;span className&#x3D;&#123;s.name&#125;&gt;&#123;item.name&#125;&lt;&#x2F;span&gt;</span><br><span class="line">                            &lt;span&gt;&#123;item.open &#x3D;&#x3D; 1 ? &#39;营业中&#39; : item.open &#x3D;&#x3D; 2 ? &#39;已打烊&#39; : &#39;装修中&#39;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">                        &lt;&#x2F;div&gt;</span><br><span class="line">                        &lt;div className&#x3D;&#123;s.del&#125;&gt;</span><br><span class="line">                            &#123;</span><br><span class="line">                                item.open &#x3D;&#x3D; 1 ? &lt;div className&#x3D;&#123;s.btnBox&#125;&gt;</span><br><span class="line">                                    &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;close&#39;,id:item.id&#125;)&#125; className&#x3D;&#123;s.margin&#125;&gt;打烊&lt;&#x2F;button&gt;</span><br><span class="line">                                    &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;set&#39;,id:item.id&#125;)&#125;&gt;装修&lt;&#x2F;button&gt;</span><br><span class="line">                                &lt;&#x2F;div&gt; : item.open &#x3D;&#x3D; 2 ? &lt;div className&#x3D;&#123;s.btnBox&#125;&gt;</span><br><span class="line">                                    &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;open&#39;,id:item.id&#125;)&#125; className&#x3D;&#123;s.margin&#125;&gt;营业&lt;&#x2F;button&gt;</span><br><span class="line">                                    &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;set&#39;,id:item.id&#125;)&#125;&gt;装修&lt;&#x2F;button&gt;</span><br><span class="line">                                &lt;&#x2F;div&gt; : &lt;div className&#x3D;&#123;s.btnBox&#125;&gt;</span><br><span class="line">                                            &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;open&#39;,id:item.id&#125;)&#125; className&#x3D;&#123;s.margin&#125;&gt;营业&lt;&#x2F;button&gt;</span><br><span class="line">                                            &lt;button&gt;待完成&lt;&#x2F;button&gt;</span><br><span class="line">                                        &lt;&#x2F;div&gt;</span><br><span class="line">                            &#125;</span><br><span class="line">                            &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;del&#39;,id:item.id&#125;)&#125; className&#x3D;&#123;s.shan&#125;&gt;删除&lt;&#x2F;button&gt;</span><br><span class="line">                        &lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;) : &lt;span className&#x3D;&#123;s.no&#125;&gt;暂无数据&lt;&#x2F;span&gt;</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">let mapStateToProps &#x3D; (state) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(state)</span><br><span class="line">    return &#123;</span><br><span class="line">        list: state.list.list</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let mapDispatchToProps &#x3D; (dispatch) &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Homet &#x3D; withRouter(Homet)</span><br><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(Homet)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hook 是React 16.8的新增特性。它可以让你在不编写 class的情况下使用 state 以及其他的 React特性。&lt;br&gt;   Hook是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数&lt;br&gt;   Hook 不能在 class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/12/25/hello-world/"/>
    <id>http://example.com/2020/12/25/hello-world/</id>
    <published>2020-12-25T01:36:20.562Z</published>
    <updated>2020-12-25T01:36:20.562Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简易防抖节流</title>
    <link href="http://example.com/2019/03/12/%E7%AE%80%E6%98%93%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>http://example.com/2019/03/12/%E7%AE%80%E6%98%93%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</id>
    <published>2019-03-12T10:28:25.000Z</published>
    <updated>2021-01-12T11:32:57.251Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var inp &#x3D; document.querySelector(&#39;.inp&#39;)</span><br><span class="line">    function fn(callBack,num)&#123;</span><br><span class="line">        let timer ;</span><br><span class="line">        return function ()&#123;</span><br><span class="line">            if(timer) clearTimeout(timer)</span><br><span class="line">            timer &#x3D; setTimeout(callBack,num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function handel()&#123;</span><br><span class="line">        console.log(&#39;函数防抖&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    inp.addEventListener(&#39;keyup&#39;,fn(handel,1000))</span><br></pre></td></tr></table></figure><h3 id="节流-在N秒内函数执行一次"><a href="#节流-在N秒内函数执行一次" class="headerlink" title="节流 在N秒内函数执行一次"></a>节流 在N秒内函数执行一次</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var inp &#x3D; document.queruSelector(&#39;.inp&#39;)</span><br><span class="line">    function fn(callBack,num)&#123;</span><br><span class="line">        let lock &#x3D; true</span><br><span class="line">        return function ()&#123;</span><br><span class="line">            lock &#x3D; false</span><br><span class="line">            setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">                lock&#x3D;true</span><br><span class="line">                callBack</span><br><span class="line">            &#125;,num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function handel()&#123;</span><br><span class="line">        console.log(&#39;节流&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    inp.addEventListener(&#39;click&#39;,fn(handel,1000))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;函数防抖&quot;&gt;&lt;a href=&quot;#函数防抖&quot; class=&quot;headerlink&quot; title=&quot;函数防抖&quot;&gt;&lt;/a&gt;函数防抖&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>history</title>
    <link href="http://example.com/2018/11/28/history/"/>
    <id>http://example.com/2018/11/28/history/</id>
    <published>2018-11-28T09:43:06.000Z</published>
    <updated>2021-01-28T10:00:22.160Z</updated>
    
    <content type="html"><![CDATA[<h4 id="history-接口允许操作浏览器的曾经在标签页或者框架里访问的绘画历史记录。"><a href="#history-接口允许操作浏览器的曾经在标签页或者框架里访问的绘画历史记录。" class="headerlink" title="history:接口允许操作浏览器的曾经在标签页或者框架里访问的绘画历史记录。"></a>history:接口允许操作浏览器的曾经在标签页或者框架里访问的绘画历史记录。</h4><p>history不继承任何接口。就是它不需要别的接口来调用它，想使用它直接使用就行。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol><li>history.length :它返回一个整数，该整数表示会话历史中元素的数目，包括当前加载的页。</li><li>history.scrollRestorration:允许Web应用程序在历史导航上显式地设置默认滚动恢复行为。此属性可以是自动的或者手动的</li><li>history.state:返回一个表示历史堆栈顶部的状态的值，这是一种可以不必等待popstate事件而查看状态的事件<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3></li><li>history.back() 在浏览器历史记录里前往上一页，用户可点击浏览器左上角的返回 等同于 history.go(-1)</li><li>history.forward() 在浏览器历史记录里前往下一页，用户可点击浏览器左上角的前进 等同于history.go(1)</li><li>history.pushState() 按指定的名称和URL（如果提供该参数）将数据push进会话历史栈，数据被DOM进行不透明处理；你可以指定任何可以被序列化的javascript对象。注意到Firefox现在忽略了这个title参数</li><li>history.replaceState() 按指定的数据，名称和URL(如果提供该参数)，更新历史栈上最新的入口。这个数据被DOM 进行了不透明处理。你可以指定任何可以被序列化的javascript对象。注意到Firefox现在忽略了这个title参数</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;history-接口允许操作浏览器的曾经在标签页或者框架里访问的绘画历史记录。&quot;&gt;&lt;a href=&quot;#history-接口允许操作浏览器的曾经在标签页或者框架里访问的绘画历史记录。&quot; class=&quot;headerlink&quot; title=&quot;history:接口允许操作</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Proxy</title>
    <link href="http://example.com/2018/10/11/Proxy/"/>
    <id>http://example.com/2018/10/11/Proxy/</id>
    <published>2018-10-11T12:54:45.000Z</published>
    <updated>2021-01-28T09:43:51.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="async函数默认返回一个Promise对象"><a href="#async函数默认返回一个Promise对象" class="headerlink" title="async函数默认返回一个Promise对象"></a>async函数默认返回一个Promise对象</h2><h3 id="proxy-对对象操作进行拦截"><a href="#proxy-对对象操作进行拦截" class="headerlink" title="proxy 对对象操作进行拦截"></a>proxy 对对象操作进行拦截</h3><h4 id="new-Proxy-接受两个参数，第一个是目标对象，另一个是拦截方法"><a href="#new-Proxy-接受两个参数，第一个是目标对象，另一个是拦截方法" class="headerlink" title="new Proxy()接受两个参数，第一个是目标对象，另一个是拦截方法"></a>new Proxy()接受两个参数，第一个是目标对象，另一个是拦截方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">        name:&#39;hello&#39;,</span><br><span class="line">        age:&#39;18&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;相当于proxy1代理了obj,需要通过proxy1 去操作代理的obj</span><br><span class="line">    let proxy1 &#x3D; new Proxy(obj,&#123;</span><br><span class="line">        get(target,key,proxy)&#123;&#x2F;&#x2F;get 方法只要是对对象进行获取操作就会触发get方法</span><br><span class="line">            console.log(arguments)&#x2F;&#x2F;得到target:目标对象和key:name属性名，以及proxy实例</span><br><span class="line">            &#x2F;&#x2F;这里return什么，就会返回什么，如果没有return，就是undefined</span><br><span class="line">            console.log(&#39;触发了&#39;)</span><br><span class="line">            return target[key]&#x2F;&#x2F;返回属性name的值</span><br><span class="line">    &#125;&#125;)</span><br><span class="line">    console.log(proxy1.name)&#x2F;&#x2F;&#39;触发了&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proxy 用于修改某些操作默认行为，等同于在语言层面做出修改，所以属于一种‘元编程’(meta progrmming),即对编程语言进行编程。</span><br><span class="line">Proxy 可以理解成，在目标对象之前架设一层‘拦截’，外界对该对象的访问，都必须先通过这层拦截，因此提供一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由他来‘代理’某些操作，可以译为‘代理器’。</span><br></pre></td></tr></table></figure><h3 id="为什么需要-Proxy"><a href="#为什么需要-Proxy" class="headerlink" title="为什么需要 Proxy"></a>为什么需要 Proxy</h3><p>1.被代理的对象不想直接被访问<br>2.控制和修改被代理对象的行为（调用属性、属性赋值、方法调用等等），使之可以进行访问控制和增加功能。</p><p>API 概览如下：</p><p>get(target, propKey, receiver)：拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’] 。<br>set(target, propKey, value, receiver)：拦截对象属性的设置，比如 proxy.foo = v 或 proxy[‘foo’] = v ，返回一个布尔值。<br>has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。<br>deleteProperty(target, propKey)：拦截 delete proxy[propKey]的操作，返回一个布尔值。<br>ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy) 、 Object.getOwnPropertySymbols(proxy) 、 Object.keys(proxy) 、 for…in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。<br>getOwnPropertyDescriptor(target, propKey)：拦截 Object.getOwnPropertyDescriptor(proxy, propKey) ，返回属性的描述对象。<br>defineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc） 、<br>Object.defineProperties(proxy, propDescs)，返回一个布尔值。<br>preventExtensions(target)：拦截 Object.preventExtensions(proxy) ，返回一个布尔值。<br>getPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy)，返回一个对象 。<br>isExtensible(target)：拦截 Object.isExtensible(proxy) ，返回一个布尔值。<br>setPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto) ，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。<br>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如 proxy(…args)、proxy.call(object, …args)、proxy.apply(…)`。<br>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(…args) 。</p><h4 id="最常用的一般就是-get-和set"><a href="#最常用的一般就是-get-和set" class="headerlink" title="最常用的一般就是 get()和set()"></a>最常用的一般就是 get()和set()</h4><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p><p>get方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">  name: &quot;张三&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var proxy &#x3D; new Proxy(person, &#123;</span><br><span class="line">  get: function(target, propKey) &#123;</span><br><span class="line">    if (propKey in target) &#123;</span><br><span class="line">      return target[propKey];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new ReferenceError(&quot;Prop name \&quot;&quot; + propKey + &quot;\&quot; does not exist.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name &#x2F;&#x2F; &quot;张三&quot;</span><br><span class="line">proxy.age &#x2F;&#x2F; 抛出一个错误</span><br><span class="line">上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">get方法可以继承。</span><br><span class="line">let proto &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get(target, propertyKey, receiver) &#123;</span><br><span class="line">    console.log(&#39;GET &#39; + propertyKey);</span><br><span class="line">    return target[propertyKey];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let obj &#x3D; Object.create(proto);</span><br><span class="line">obj.foo &#x2F;&#x2F; &quot;GET foo&quot;</span><br><span class="line">上面代码中，拦截操作定义在Prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">下面的例子使用get拦截，实现数组读取负数的索引。</span><br><span class="line">function createArray(...elements) &#123;</span><br><span class="line">  let handler &#x3D; &#123;</span><br><span class="line">    get(target, propKey, receiver) &#123;</span><br><span class="line">      let index &#x3D; Number(propKey);</span><br><span class="line">      if (index &lt; 0) &#123;</span><br><span class="line">        propKey &#x3D; String(target.length + index);</span><br><span class="line">      &#125;</span><br><span class="line">      return Reflect.get(target, propKey, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  let target &#x3D; [];</span><br><span class="line">  target.push(...elements);</span><br><span class="line">  return new Proxy(target, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr &#x3D; createArray(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);</span><br><span class="line">arr[-1] &#x2F;&#x2F; c</span><br><span class="line">上面代码中，数组的位置参数是-1，就会输出数组的倒数第一个成员。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。</span><br><span class="line">var pipe &#x3D; function (value) &#123;</span><br><span class="line">  var funcStack &#x3D; [];</span><br><span class="line">  var oproxy &#x3D; new Proxy(&#123;&#125; , &#123;</span><br><span class="line">    get : function (pipeObject, fnName) &#123;</span><br><span class="line">      if (fnName &#x3D;&#x3D;&#x3D; &#39;get&#39;) &#123;</span><br><span class="line">        return funcStack.reduce(function (val, fn) &#123;</span><br><span class="line">          return fn(val);</span><br><span class="line">        &#125;,value);</span><br><span class="line">      &#125;</span><br><span class="line">      funcStack.push(window[fnName]);</span><br><span class="line">      return oproxy;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return oproxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var double &#x3D; n &#x3D;&gt; n * 2;</span><br><span class="line">var pow    &#x3D; n &#x3D;&gt; n * n;</span><br><span class="line">var reverseInt &#x3D; n &#x3D;&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0;</span><br><span class="line"></span><br><span class="line">pipe(3).double.pow.reverseInt.get; &#x2F;&#x2F; 63</span><br><span class="line">上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">下面的例子则是利用get拦截，实现一个生成各种 DOM 节点的通用函数dom。</span><br><span class="line">const dom &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get(target, property) &#123;</span><br><span class="line">    return function(attrs &#x3D; &#123;&#125;, ...children) &#123;</span><br><span class="line">      const el &#x3D; document.createElement(property);</span><br><span class="line">      for (let prop of Object.keys(attrs)) &#123;</span><br><span class="line">        el.setAttribute(prop, attrs[prop]);</span><br><span class="line">      &#125;</span><br><span class="line">      for (let child of children) &#123;</span><br><span class="line">        if (typeof child &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">          child &#x3D; document.createTextNode(child);</span><br><span class="line">        &#125;</span><br><span class="line">        el.appendChild(child);</span><br><span class="line">      &#125;</span><br><span class="line">      return el;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const el &#x3D; dom.div(&#123;&#125;,</span><br><span class="line">  &#39;Hello, my name is &#39;,</span><br><span class="line">  dom.a(&#123;href: &#39;&#x2F;&#x2F;example.com&#39;&#125;, &#39;Mark&#39;),</span><br><span class="line">  &#39;. I like:&#39;,</span><br><span class="line">  dom.ul(&#123;&#125;,</span><br><span class="line">    dom.li(&#123;&#125;, &#39;The web&#39;),</span><br><span class="line">    dom.li(&#123;&#125;, &#39;Food&#39;),</span><br><span class="line">    dom.li(&#123;&#125;, &#39;…actually that\&#39;s it&#39;)</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">document.body.appendChild(el);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">下面是一个get方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</span><br><span class="line">const proxy &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function(target, key, receiver) &#123;</span><br><span class="line">    return receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.getReceiver &#x3D;&#x3D;&#x3D; proxy &#x2F;&#x2F; true</span><br><span class="line">上面代码中，proxy对象的getReceiver属性是由proxy对象提供的，所以receiver指向proxy对象。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const proxy &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function(target, key, receiver) &#123;</span><br><span class="line">    return receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const d &#x3D; Object.create(proxy);</span><br><span class="line">d.a &#x3D;&#x3D;&#x3D; d &#x2F;&#x2F; true</span><br><span class="line">上面代码中，d对象本身没有a属性，所以读取d.a的时候，会去d的原型proxy对象找。这时，receiver就指向d，代表原始的读操作所在的那个对象。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</span><br><span class="line">const target &#x3D; Object.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    value: 123,</span><br><span class="line">    writable: false,</span><br><span class="line">    configurable: false</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const handler &#x3D; &#123;</span><br><span class="line">  get(target, propKey) &#123;</span><br><span class="line">    return &#39;abc&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">proxy.foo</span><br><span class="line">&#x2F;&#x2F; TypeError: Invariant check failed</span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let obj&#x3D;&#123;</span><br><span class="line">        name:&#39;hello world&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">    let proxy2 &#x3D; new Proxy(obj,&#123;</span><br><span class="line">        get(target,key,receiver)&#123;</span><br><span class="line">            return target[key]&#x2F;&#x2F;获取想要得到的属性</span><br><span class="line">        &#125;,</span><br><span class="line">        set(target,key,value,receiver)&#123;</span><br><span class="line">            console.log(&#39;要设置&#39;)</span><br><span class="line">            console.log(arguments)</span><br><span class="line">            &#x2F;&#x2F;key这里就是要设置的那个age属性</span><br><span class="line">            target[key]&#x3D;value</span><br><span class="line">            return true &#x2F;&#x2F;最后返回一个布尔值</span><br><span class="line">        &#125;,</span><br><span class="line">        has(target,key)&#123;&#x2F;&#x2F;拦截in这个操作。接收两个参数，目标对象和判断的那个属性名</span><br><span class="line">            if(key.startsWith(&#39;_&#39;))&#123;&#x2F;&#x2F;判断下是否是带__的属性比如&#39;__proto__&#39;</span><br><span class="line">                return false</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return key in target</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    proxy2.age&#x3D;10&#x2F;&#x2F;这里我们想要给obj设置一个age为10的属性</span><br><span class="line">    console.log(obj)</span><br><span class="line">    console.log(&#39;name&#39; in proxy2)</span><br></pre></td></tr></table></figure><h3 id="apply-拦截实例作为函数调用的时候：proxy3"><a href="#apply-拦截实例作为函数调用的时候：proxy3" class="headerlink" title="apply()//拦截实例作为函数调用的时候：proxy3()"></a>apply()//拦截实例作为函数调用的时候：proxy3()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function query()&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">        return &#123;name:&#39;hello world&#39;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let obj &#x3D; &#123;name:&#39;北京&#39;&#125;</span><br><span class="line">    let proxy3 &#x3D; new Proxy(query,&#123;</span><br><span class="line">        apply(target,object,args)&#123;</span><br><span class="line">            &#x2F;&#x2F;函数直接执行()、通过call执行、apply执行，都会触发此处。</span><br><span class="line">            &#x2F;&#x2F;object 给函数修改this</span><br><span class="line">            &#x2F;&#x2F; args 函数执行的参数</span><br><span class="line">            console.log(&#39;执行&#39;)</span><br><span class="line">            console.log(target,object,args)</span><br><span class="line">            if(object)&#123;</span><br><span class="line">                object.fn&#x3D;target</span><br><span class="line">                object.fn(...args)</span><br><span class="line">                delete object.fn</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                target(...args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    proxy3()</span><br><span class="line">    console.log(proxy3.call(obj,1,2,3))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;async函数默认返回一个Promise对象&quot;&gt;&lt;a href=&quot;#async函数默认返回一个Promise对象&quot; class=&quot;headerlink&quot; title=&quot;async函数默认返回一个Promise对象&quot;&gt;&lt;/a&gt;async函数默认返回一个Promise</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>属性描述符</title>
    <link href="http://example.com/2018/10/02/%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
    <id>http://example.com/2018/10/02/%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/</id>
    <published>2018-10-02T13:59:58.000Z</published>
    <updated>2021-01-03T05:51:03.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>Object.defineProperty(obj,prop,desctiptor)接受3个参数。<br>obj:接受一个对象、prop:定义或修改的属性或Smybol、descriptor:属性描述符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> let obj &#x3D;&#123;</span><br><span class="line">    name:&#39;hello&#39;</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(obj,&#39;sex&#39;,&#123;value:&#39;world&#39;&#125;)</span><br><span class="line">console.log(Object.keys(obj))</span><br><span class="line">&#x2F;&#x2F;只拿到了name 因为用上面定义的方法给对象添加的属性是不可枚举的所以它并不能被拿到</span><br></pre></td></tr></table></figure><p>对象里目前存在属性描述符有两种主要形式：数据描述符合存取描述符。<br>数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。<br>存取描述符是由getter函数和setter函数所描述的属性。一个描述符只能是这两种其中之一，不能同时是两者<br>这两种描述符都是对象。他们共享一下可选键值(默认值是指咋使用Object.definPropety()定义属性时的默认值)<br>configurable<br>当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。<br>默认为 false。<br>enumerable<br>当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。<br>默认为 false。<br>数据描述符还具有以下可选键值：</p><p>value<br>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。<br>默认为 undefined。<br>writable<br>当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变。<br>默认为 false。<br>存取描述符还具有以下可选键值：</p><p>get<br>属性的 getter 函数，如果没有 getter，则为 undefined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。<br>默认为 undefined。<br>set<br>属性的 setter 函数，如果没有 setter，则为 undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。<br>默认为 undefined。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; &#123;&#125;; &#x2F;&#x2F; 创建一个新对象</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在对象中添加一个属性与数据描述符的示例</span><br><span class="line">Object.defineProperty(o, &quot;a&quot;, &#123;</span><br><span class="line">  value : 37,</span><br><span class="line">  writable : true,</span><br><span class="line">  enumerable : true,</span><br><span class="line">  configurable : true</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象 o 拥有了属性 a，值为 37</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在对象中添加一个设置了存取描述符属性的示例</span><br><span class="line">var bValue &#x3D; 38;</span><br><span class="line">Object.defineProperty(o, &quot;b&quot;, &#123;</span><br><span class="line">  &#x2F;&#x2F; 使用了方法名称缩写（ES2015 特性）</span><br><span class="line">  &#x2F;&#x2F; 下面两个缩写等价于：</span><br><span class="line">  &#x2F;&#x2F; get : function() &#123; return bValue; &#125;,</span><br><span class="line">  &#x2F;&#x2F; set : function(newValue) &#123; bValue &#x3D; newValue; &#125;,</span><br><span class="line">  get() &#123; return bValue; &#125;,</span><br><span class="line">  set(newValue) &#123; bValue &#x3D; newValue; &#125;,</span><br><span class="line">  enumerable : true,</span><br><span class="line">  configurable : true</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.b; &#x2F;&#x2F; 38</span><br><span class="line">&#x2F;&#x2F; 对象 o 拥有了属性 b，值为 38</span><br><span class="line">&#x2F;&#x2F; 现在，除非重新定义 o.b，o.b 的值总是与 bValue 相同</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数据描述符和存取描述符不能混合使用</span><br><span class="line">Object.defineProperty(o, &quot;conflict&quot;, &#123;</span><br><span class="line">  value: 0x9f91102,</span><br><span class="line">  get() &#123; return 0xdeadbeef; &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 抛出错误 TypeError: value appears only in data descriptors, get appears only in accessor descriptors</span><br></pre></td></tr></table></figure><h2 id="自定义-Setters-和-Getters"><a href="#自定义-Setters-和-Getters" class="headerlink" title="自定义 Setters 和 Getters"></a>自定义 Setters 和 Getters</h2><p>下面的例子展示了如何实现一个自存档对象。当设置temperature 属性时，archive 数组会收到日志条目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Archiver() &#123;</span><br><span class="line">  var temperature &#x3D; null;</span><br><span class="line">  var archive &#x3D; [];</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(this, &#39;temperature&#39;, &#123;</span><br><span class="line">    get: function() &#123;</span><br><span class="line">      console.log(&#39;get!&#39;);</span><br><span class="line">      return temperature;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(value) &#123;</span><br><span class="line">      temperature &#x3D; value;</span><br><span class="line">      archive.push(&#123; val: temperature &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  this.getArchive &#x3D; function() &#123; return archive; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arc &#x3D; new Archiver();</span><br><span class="line">arc.temperature; &#x2F;&#x2F; &#39;get!&#39;</span><br><span class="line">arc.temperature &#x3D; 11;</span><br><span class="line">arc.temperature &#x3D; 13;</span><br><span class="line">arc.getArchive(); &#x2F;&#x2F; [&#123; val: 11 &#125;, &#123; val: 13 &#125;]</span><br></pre></td></tr></table></figure><h2 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h2><p>如果访问者的属性是被继承的，它的 get 和 set 方法会在子对象的属性被访问或者修改时被调用。如果这些方法用一个变量存值，该值会被所有对象共享。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function myclass() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var value;</span><br><span class="line">Object.defineProperty(myclass.prototype, &quot;x&quot;, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;,</span><br><span class="line">  set(x) &#123;</span><br><span class="line">    value &#x3D; x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var a &#x3D; new myclass();</span><br><span class="line">var b &#x3D; new myclass();</span><br><span class="line">a.x &#x3D; 1;</span><br><span class="line">console.log(b.x); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><h1 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h1><p>Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let obj1 &#x3D; &#123;</span><br><span class="line">    name:&#39;hong&#39;,</span><br><span class="line">    sex:&#39;女&#39;</span><br><span class="line">&#125;</span><br><span class="line">let obj2 &#x3D; &#123;</span><br><span class="line">    age:&#39;18&#39;,</span><br><span class="line">    get sayName()&#123;</span><br><span class="line">        return &#39;hong&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let obj3 &#x3D; Object.assign(&#123;&#125;,obj1,obj2)</span><br><span class="line">console.log(obj3)&#x2F;&#x2F;此时合并完，就会把obj2里的存取属性给变成了数据属性</span><br><span class="line">&#x2F;&#x2F;应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。</span><br></pre></td></tr></table></figure><h3 id="异常会打断后续拷贝任务"><a href="#异常会打断后续拷贝任务" class="headerlink" title="异常会打断后续拷贝任务"></a>异常会打断后续拷贝任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const target &#x3D; Object.defineProperty(&#123;&#125;, &quot;foo&quot;, &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    writable: false</span><br><span class="line">&#125;); &#x2F;&#x2F; target 的 foo 属性是个只读属性。</span><br><span class="line"></span><br><span class="line">Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);</span><br><span class="line">&#x2F;&#x2F; TypeError: &quot;foo&quot; is read-only</span><br><span class="line">&#x2F;&#x2F; 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</span><br><span class="line"></span><br><span class="line">console.log(target.bar);  &#x2F;&#x2F; 2，说明第一个源对象拷贝成功了。</span><br><span class="line">console.log(target.foo2); &#x2F;&#x2F; 3，说明第二个源对象的第一个属性也拷贝成功了。</span><br><span class="line">console.log(target.foo);  &#x2F;&#x2F; 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span><br><span class="line">console.log(target.foo3); &#x2F;&#x2F; undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span><br><span class="line">console.log(target.baz);  &#x2F;&#x2F; undefined，第三个源对象更是不会被拷贝到的。</span><br></pre></td></tr></table></figure><h2 id="拷贝访问器-手动实现你原来是个存取属性，现在通过Object-assign-拷贝过来还是存取属性"><a href="#拷贝访问器-手动实现你原来是个存取属性，现在通过Object-assign-拷贝过来还是存取属性" class="headerlink" title="拷贝访问器(手动实现你原来是个存取属性，现在通过Object.assign()拷贝过来还是存取属性)"></a>拷贝访问器(手动实现你原来是个存取属性，现在通过Object.assign()拷贝过来还是存取属性)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  get bar() &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let copy &#x3D; Object.assign(&#123;&#125;, obj);</span><br><span class="line">console.log(copy); &#x2F;&#x2F; &#123; foo: 1, bar: 2 &#125; copy.bar的值来自obj.bar的getter函数的返回值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面这个函数会拷贝所有自有属性的属性描述符</span><br><span class="line">function completeAssign(target, ...sources) &#123;</span><br><span class="line">  sources.forEach(source &#x3D;&gt; &#123;</span><br><span class="line">    let descriptors &#x3D; Object.keys(source).reduce((descriptors, key) &#x3D;&gt; &#123;</span><br><span class="line">      descriptors[key] &#x3D; Object.getOwnPropertyDescriptor(source, key);</span><br><span class="line">      return descriptors;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Object.assign 默认也会拷贝可枚举的Symbols</span><br><span class="line">    Object.getOwnPropertySymbols(source).forEach(sym &#x3D;&gt; &#123;</span><br><span class="line">      let descriptor &#x3D; Object.getOwnPropertyDescriptor(source, sym);</span><br><span class="line">      if (descriptor.enumerable) &#123;</span><br><span class="line">        descriptors[sym] &#x3D; descriptor;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Object.defineProperties(target, descriptors);</span><br><span class="line">  &#125;);</span><br><span class="line">  return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copy &#x3D; completeAssign(&#123;&#125;, obj);</span><br><span class="line">console.log(copy);</span><br><span class="line">&#x2F;&#x2F; &#123; foo:1, get bar() &#123; return 2 &#125; &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Object-defineProperty&quot;&gt;&lt;a href=&quot;#Object-defineProperty&quot; class=&quot;headerlink&quot; title=&quot;Object.defineProperty&quot;&gt;&lt;/a&gt;Object.defineProperty&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>express</title>
    <link href="http://example.com/2018/08/30/express/"/>
    <id>http://example.com/2018/08/30/express/</id>
    <published>2018-08-30T13:57:46.000Z</published>
    <updated>2020-12-30T11:58:53.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单使用express"><a href="#简单使用express" class="headerlink" title="简单使用express"></a>简单使用express</h1><p>首先安装 npm i express 、body-parser (post请求需要用到)</p><p>1.分别引用：import express from ‘express’;(如果没有引用bable,可以用require()引用)</p><p>import baodyParser from ‘body-parser’;</p><p>import fs from ‘fs’</p><p>import path from ‘path’</p><ol start="2"><li><p>const app=express() //创建一个express应用</p></li><li><p>const post=3000 端口号</p></li><li><p>用一下body-parser :app.use(bodyParser.json())</p></li></ol><p>app.use(bodyParser.urlencoded({extended:false}))</p><p>下面就可以使用 get post 进行请求了</p><p>app.post(‘/post’,(req,res)=&gt;{</p><p>　　</p><p>})</p><p>app.get(‘/gett’,(req,res)=&gt;{</p><p>　　</p><p>})</p><p>app.listen(post,()=&gt;{//监听端口号</p><p> 　　console.log(post)</p><p>})</p><p> 题外：1.关于express中间件的简单概述：在use(),get(),post()等方法里面是都可以使用中间件的。写法：app.user((req,res,next)=&gt;{</p><p>　　console.log(‘继续往下走’)</p><p>　　next()//如果不写next它是不会继续执行下面代码的</p><p>　　由此可简单说一个例子：就是有了这个中间件我们可以把一些公共逻辑放在use()方法中来执行，如果可行就next()继续往下走，否则停止本次请求。因为use()方法不管什么请求都会走进来！我们可以在这里进行账号密码的校验，因为不论登录还是注册都是要校验的，所以不可能登录和注册的接口都要写一遍校验。这个时候我们可以把校验这段逻辑放在use()方法中，如果校验通过就可以继续请求，否则直接停止。所以有了它就可以减少代码冗余问题。</p><p>})</p><p>　　2. express 重定向：使用 express.get(‘*’,(req,res)=&gt;{//就是当所有的请求都找不到时，给它重定向到一个专门的404页面。第一个参数是 *（通配符 所有），后面依然是回调函数</p><p>　　express.redirect(‘404.网页’)//用redirect方法做重定向</p><p>})</p><p>　　3. 请求对象req的方法：</p><p>　　　　req.body :获取post请求体的数据</p><p>　　　　req.query获取get请求的数据</p><p>　　　　req.originnalUrl 获取原始url地址、当需要处理路径的时候可以还可以用req.baseUrl，req.path  这三个方法是可以操作url的。</p><p>　　　　req.get(‘Content-type’)用来获取请求头</p><p>　　4. 响应对象res的方法：</p><p>　　　　res.set(‘key’,value)设置响应头  key:响应头的字段名称  。 value:值。</p><p>　　　　res.send()发送数据</p><p>　　　　res.senfFile()发送文件</p><p>　　　　res.redirect()重新定向 参数是文件的地址</p><p>　　　　res.download()下载</p><p>　　　　res.jsonp()以jsonp的方式返回数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简单使用express&quot;&gt;&lt;a href=&quot;#简单使用express&quot; class=&quot;headerlink&quot; title=&quot;简单使用express&quot;&gt;&lt;/a&gt;简单使用express&lt;/h1&gt;&lt;p&gt;首先安装 npm i express 、body-parser (p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>手写Promise</title>
    <link href="http://example.com/2018/05/25/%E6%89%8B%E5%86%99Promise/"/>
    <id>http://example.com/2018/05/25/%E6%89%8B%E5%86%99Promise/</id>
    <published>2018-05-25T14:10:50.000Z</published>
    <updated>2020-12-27T12:35:16.339Z</updated>
    
    <content type="html"><![CDATA[<p><font> 手写Promise  主要是解决回调地狱的问题，在ES6中出现了promise来解决这个问题，但是同样也带来了多个.then()的问题<br>    //随着es7 async和await到来可以说彻底解决回调地狱。<br>    new Promise() //是谁执行了？直接new一个Promise是内置构造Promise执行了，但是它会报错。因为这里缺一个回调函数，平常大家也都是这么用的<br>    new Promise(()=&gt;{<br>       console.log(‘你大爷’)//‘你大爷’会执行吗？：这里new了一个Promose,Promise执行一次，那里面的回调函数也会执行，所以‘你大爷’成功被打印<br>    })<br>    function fn(callBack){</p><pre><code>&#125;new fn(()=&gt;&#123;&#125;)//fn执行，但是里面的回调并没有，Promise的回调会执行。//new Promise 是内置构造函数Promise执行一次//Promise的回调函数也会执行一次，这个回调函数会给我们提供两个形参（函数）：成功、失败//Promise的回调函数，又有两个参数分别是：resolve、reject两个函数//Promise类的实例没有then方法，应该是原型对象的方法var obj = new Promise((resolve,rejecct)=&gt;&#123;     console.log(resolve,reject)//两个函数&#125;)//obj是Promise的一个实例// 手写function myPromise(callBack)&#123;//接受传进来的回调函数    //状态属性    this.status=&#39;pending&#39;    //回调函数    callBack(resolve.bind(this),reject.bing(this))    //定义一个成功的函数    function resolve(hello,           params)&#123;        //那么console.log(hello)肯定是执行的（很早演示时写）        //修改状态（后写）        if(this.status===&#39;pending&#39;)&#123;//如果出事状态为pengding,            this.status=&#39;success&#39;//那就把它改成success成功            //这里还有一个上下文的问题。成功时resolve是怎么调用的？是函数名+小括号，也就是window.            //但这里就不该用window，因为将来获取服务器的数据实在.then()里的来获取。所以我们在初始化时就要给            //resolve和reject绑死这个类的实例：resolve.bind(this)  reject.bing(this) 走起上面绑死↑            //否则你在调用resolve和reject时他们就会指向window            //为什么绑死上下文为这个类的实例？因为我们要借用这个类的实例的成功和失败的方法74行里面成功与失败的回调            //所以↓            this.successCallBack(params)//这个是谁？它就是then的第一个参数也就是成功的回调，所以把参数直接注进来就行了            //失败同样        &#125;    &#125;    //定义一个失败的函数    function reject(err)&#123;        if(this.status===&#39;pending&#39;)&#123;            this.status=&#39;faile&#39;            this.faileCallBack(err)        &#125;    &#125;&#125;//调用new myPromise(()=&gt;&#123;//并且传进去一个回调函数。但是我们在实际运用中肯定要传2个参数进去。resolve,reject,并且37行回调也要接受这个2个函数    //console.log(&#39;我是Promise&#39;)//这里肯定会执行。打印。    //假如这里调用并传参resolve(&#39;hello&#39;)    //处理异步,一般promise就是处理异步的    setTimeout(()=&gt;&#123;        resolve(&#39;我是promise&#39;)    &#125;)&#125;)//假如我们是在处理异步请求那么肯定要在这.then()。但是能直接.then()吗？要注意.then()是在原型上面的。虽然链式语法可以这么写，但是这里并没有这个方法。.then()应该是原型上面类的原型的方法.then((data)=&gt;&#123;    console.log(data)&#125;,()=&gt;&#123;&#125;)//一般我们在调用then()的时候肯定要传2个参数进去，下面接收，就是相当于将then方法里面成功与失败的回调函数当做当前类的实例即可，当前类是谁？promise//所以原型上定义一个then的方法，应该是myPromise.prototype.then=function(success,faile)&#123;//接收上面调用then时传进来的来个函数。就是将then方法里面成功与失败的回到函数作为当前类的实例即可    this.successCallBack=success//相当于then传进一个成功的函数给了success,就是给myPromise的实例动态添加了属性就是success这个成功的箭头函数。还有一个失败的同样     this.faileCallBack=faile    //then()的两个函数相当于作为这个实例的两个方法&#125;//53行异步成功后执行，就是相当于调用了41行那个方法。失败同样//因为promise有3中状态，pending、成功、失败。所以此时我去上面给类定义个状态的属性，走起↑//如果说异步解决成功就调用resolve方法 。resolve就是41行函数执行。但是我们都是在then()来获取成功或失败的数据，(其实就是调用this.successCallBack，this.faileCallBack)。所以走起去上面↑，就是修改promise的状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(()&#x3D;&gt;&#123;</span><br><span class="line">    window.myPromise&#x3D;function(callBack)&#123;</span><br><span class="line">        &#x2F;&#x2F;状态属性</span><br><span class="line">        this.status&#x3D;&#39;pending&#39;</span><br><span class="line">        &#x2F;&#x2F;回调函数</span><br><span class="line">        callBack(resolve.bind(this),reject.bind(this))</span><br><span class="line">        &#x2F;&#x2F; 成功</span><br><span class="line">        function resolve(params)&#123;</span><br><span class="line">            if(this.status&#x3D;&#x3D;&#x3D;&#39;pending&#39;)&#123;</span><br><span class="line">                this.status&#x3D;&#39;success&#39;</span><br><span class="line">                this.successCallBack(params)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 失败</span><br><span class="line">        function reject(err)&#123;</span><br><span class="line">            if(this.status&#x3D;&#x3D;&#x3D;&#39;pending&#39;)&#123;</span><br><span class="line">                this.status&#x3D;&#39;faile&#39;</span><br><span class="line">                this.successCallBack(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;原型上定义一个then的方法</span><br><span class="line">    myPromise.prototype.then&#x3D;function(success,faile)&#123;</span><br><span class="line">        this.successCallBack&#x3D;success</span><br><span class="line">        this.faileCallBack&#x3D;faile</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">var obj &#x3D; new myPromise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        resolve(&#39;你真好&#39;)</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;).then((data)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(data)&#x2F;&#x2F;成功执行</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;font&gt; 手写Promise  主要是解决回调地狱的问题，在ES6中出现了promise来解决这个问题，但是同样也带来了多个.then()的问题&lt;br&gt;    //随着es7 async和await到来可以说彻底解决回调地狱。&lt;br&gt;    new Promise() </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Class的继承</title>
    <link href="http://example.com/2018/05/16/Class2/"/>
    <id>http://example.com/2018/05/16/Class2/</id>
    <published>2018-05-16T06:53:04.000Z</published>
    <updated>2020-12-30T06:09:50.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>Class可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承,要清晰和方便很多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Pointwo extends Point&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Pointwo extends Point&#123;</span><br><span class="line">    constructor(x,y,color)&#123;</span><br><span class="line">        super(x,y)&#x2F;&#x2F;调用父类的constructor(x,y)</span><br><span class="line">        this.color &#x3D; color</span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line">        return this.color + &#39;&#39; +super.toString()&#x2F;&#x2F;调用父类的toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码中，constructor方法和toString方法之中，都出现了super关键字，他在这里表示父类的构造函数，用来新建父类的this对象</span><br><span class="line">子类必须在constructor方法中调用super方法，否则新建实例时会报错，这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后对其进行加工，加上子类自己的实例属性和方法，如果不调用super方法，子类就得不到this对象</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123; &#x2F;* ... *&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cp &#x3D; new ColorPoint(); &#x2F;&#x2F; ReferenceError</span><br><span class="line">上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。</span><br><span class="line"></span><br><span class="line">ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</span><br><span class="line"></span><br><span class="line">如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(...args) &#123;</span><br><span class="line">    super(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    this.color &#x3D; color; &#x2F;&#x2F; ReferenceError</span><br><span class="line">    super(x, y);</span><br><span class="line">    this.color &#x3D; color; &#x2F;&#x2F; 正确</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。</span><br><span class="line"></span><br><span class="line">下面是生成子类实例的代码。</span><br><span class="line">let cp &#x3D; new ColorPoint(25, 8, &#39;green&#39;);</span><br><span class="line"></span><br><span class="line">cp instanceof ColorPoint &#x2F;&#x2F; true</span><br><span class="line">cp instanceof Point &#x2F;&#x2F; true</span><br><span class="line">上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后，父类的静态方法，也会被子类继承。</span><br></pre></td></tr></table></figure><p>class A {<br>  static hello() {<br>    console.log(‘hello world’);<br>  }<br>}</p><p>class B extends A {<br>}</p><p>B.hello()  // hello world<br>上面代码中，hello()是A类的静态方法，B继承A，也继承了A的静态方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.Object.getPrototypeOf()</span><br><span class="line">Object.getPrototypeOf()方法可以用来从子类上获取父类</span><br></pre></td></tr></table></figure><p>Object.getPrototypeOf(ColorPoint) === Point//true<br>因此，可以使用这个方法判断，一个类是否继承了另一个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.super关键字</span><br><span class="line">super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同</span><br><span class="line">第一种情况，super作为函数用时，代表父类的构造函数。ES6要求，子类的构造函数必须执行一次super函数。</span><br></pre></td></tr></table></figure><p>class A {}</p><p>class B extends A {<br>  constructor() {<br>    super();<br>  }<br>}<br>上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p><p>注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    console.log(new.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">new A() &#x2F;&#x2F; A</span><br><span class="line">new B() &#x2F;&#x2F; B</span><br><span class="line">上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。</span><br><span class="line"></span><br><span class="line">作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  m() &#123;</span><br><span class="line">    super(); &#x2F;&#x2F; 报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，super()用在B类的m方法之中，就会造成语法错误。</span><br></pre></td></tr></table></figure><p>第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    p()&#123;</span><br><span class="line">        return 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super()</span><br><span class="line">        console.log(super.p())&#x2F;&#x2F;&#x2F;2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; new B()</span><br><span class="line">代码中，子类B当中的super.p(),就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype,所以super.p()就相当于A.prototype.p()</span><br><span class="line">注意：由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.p &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  get m() &#123;</span><br><span class="line">    return super.p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">b.m &#x2F;&#x2F; undefined</span><br><span class="line">上面代码中，p是父类A实例的属性，super.p就引用不到它。</span><br></pre></td></tr></table></figure><p>如果属性定义在父类的原型对象上，super就可以取到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line">A.prototype.x &#x3D; 2;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super.x) &#x2F;&#x2F; 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">代码中,属性x是定义在A.prototype上面的，所以super.x可以取到它的值</span><br></pre></td></tr></table></figure><p>ES6规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.x &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    super.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">b.m() &#x2F;&#x2F; 2</span><br><span class="line">代码中，super.print()虽然调用的是A.prototype.print(),但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1.也就是说，实际上执行的是super.print.call(this)</span><br></pre></td></tr></table></figure><p>由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.x &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x &#x3D; 2;</span><br><span class="line">    super.x &#x3D; 3;</span><br><span class="line">    console.log(super.x); &#x2F;&#x2F; undefined</span><br><span class="line">    console.log(this.x); &#x2F;&#x2F; 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">代码中，super.x赋值为3，这时等同于对this.x赋值为3.而当读取super.x的时候，读的是A.prototype.x,所以返回undefined</span><br></pre></td></tr></table></figure><p>如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">    static myMethod(msg)&#123;</span><br><span class="line">        console.log(&#39;static&#39;,msg)</span><br><span class="line">    &#125;</span><br><span class="line">    myMethod(msg)&#123;</span><br><span class="line">        console.log(&#39;instance&#39;,msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent&#123;</span><br><span class="line">    static myMethod(msg)&#123;</span><br><span class="line">        super.myMethod(msg)</span><br><span class="line">    &#125;</span><br><span class="line">    myMethod(msg)&#123;</span><br><span class="line">        super.myMethod(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Child.myMethod(1))</span><br><span class="line">var child &#x3D; new Child()</span><br><span class="line">console.log(child.myMethod(2))</span><br><span class="line">上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</span><br></pre></td></tr></table></figure><p>另外，在子类的静态方法中通过super调用父类方法时，方法内部的this指向当前的子类，而不是子类的实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.x &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  static print() &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line">  static m() &#123;</span><br><span class="line">    super.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.x &#x3D; 3;</span><br><span class="line">B.m() &#x2F;&#x2F; 3</span><br><span class="line">上面代码中，静态方法B.m里面，super.print指向父类的静态方法。这个方法里面的this指向的是B，而不是B的实例。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</span><br><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super); &#x2F;&#x2F; 报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super.valueOf() instanceof B); &#x2F;&#x2F; true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super使得this指向B的实例，所以super.valueOf()返回的是一个B的实例。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &quot;MyObject: &quot; + super.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.toString(); &#x2F;&#x2F; MyObject: [object Object]</span><br></pre></td></tr></table></figure><p>4.类的 prototype 属性和__proto__属性<br>大多数浏览器的ES5实现中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性,因此同时存在两条继承链<br>(1) 子类的__proto__属性，表示构造函数的继承，总是指向父类。<br>(2) 子类的prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">B.__proto__ &#x3D;&#x3D;&#x3D; A &#x2F;&#x2F;true</span><br><span class="line">B.prototype.__proto__ &#x3D;&#x3D;&#x3D; A.prototype &#x2F;&#x2F;true</span><br><span class="line">代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性</span><br></pre></td></tr></table></figure><p>这样的结果是因为，类的继承是按照下面的模式实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class B&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Object.setPrototypeOf(B.prototype,A.prototype)&#x2F;&#x2F;B的实例继承A的实例</span><br><span class="line">Object.setPrototypeOf(B,A)&#x2F;&#x2F;B继承A的静态属性</span><br><span class="line">const b &#x3D; new B()</span><br><span class="line">《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf &#x3D; function (obj, proto) &#123;</span><br><span class="line">  obj.__proto__ &#x3D; proto;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line">因此就得到了上面这个结果</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">B.prototype.__proto__ &#x3D; A.prototype;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(B, A);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">B.__proto__ &#x3D; A;</span><br><span class="line">这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B.prototype &#x3D; Object.create(A.prototype);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">B.prototype.__proto__ &#x3D; A.prototype;</span><br></pre></td></tr></table></figure><p>extends关键字后面可以跟多种类型的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class B extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。</span><br></pre></td></tr></table></figure><p>下面，讨论两种情况。第一种，子类继承Object类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A extends Object &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ &#x3D;&#x3D;&#x3D; Object &#x2F;&#x2F; true</span><br><span class="line">A.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; true</span><br><span class="line">这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。</span><br></pre></td></tr></table></figure><p>第二种情况，不存在任何继承。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ &#x3D;&#x3D;&#x3D; Function.prototype &#x2F;&#x2F; true</span><br><span class="line">A.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; true</span><br><span class="line">这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。</span><br></pre></td></tr></table></figure><p>实例的 <strong>proto</strong> 属性<br>子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Point(2, 3);</span><br><span class="line">var p2 &#x3D; new ColorPoint(2, 3, &#39;red&#39;);</span><br><span class="line"></span><br><span class="line">p2.__proto__ &#x3D;&#x3D;&#x3D; p1.__proto__ &#x2F;&#x2F; false</span><br><span class="line">p2.__proto__.__proto__ &#x3D;&#x3D;&#x3D; p1.__proto__ &#x2F;&#x2F; true</span><br><span class="line">上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。</span><br></pre></td></tr></table></figure><p>因此，通过子类实例的<strong>proto</strong>.__proto__属性，可以修改父类实例的行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p2.__proto__.__proto__.printName &#x3D; function () &#123;</span><br><span class="line">  console.log(&#39;Ha&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() &#x2F;&#x2F; &quot;Ha&quot;</span><br><span class="line">上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h1&gt;&lt;p&gt;Class可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承,要清晰和方便很多。&lt;/p&gt;
&lt;figur</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Class的基本语法</title>
    <link href="http://example.com/2018/05/15/Class1/"/>
    <id>http://example.com/2018/05/15/Class1/</id>
    <published>2018-05-15T14:02:45.000Z</published>
    <updated>2020-12-29T06:52:30.506Z</updated>
    
    <content type="html"><![CDATA[<p>class的基本语法:<br>一.类的由来<br>JS中生成实力对象的传统方法是通过构造函数，下面请看一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Point(x,y)&#123;</span><br><span class="line">    this.x&#x3D;x</span><br><span class="line">    this.y&#x3D;y</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.toString&#x3D;function ()&#123;</span><br><span class="line">    return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39;</span><br><span class="line">&#125;</span><br><span class="line">var p &#x3D; new Point(1,2)</span><br><span class="line">console.log(p)</span><br></pre></td></tr></table></figure><p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</p><p>基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">    constructor(x,y)&#123;</span><br><span class="line">        this.x&#x3D;x</span><br><span class="line">        this.y&#x3D;y</span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line">            return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p &#x3D;new Point(1,2)</span><br><span class="line">console.log(p)</span><br></pre></td></tr></table></figure><p>这个是定义了一个类，有一个constructor()方法，就是构造方法而this关键字就是实力的对象。这种新的Class写法，最开始ES5的构造函数Point是一样的。</p><p>Point类除了构造方法，还定义了一个toString方法。注意，这里定义toString()方法，是不用加上function关键字的。直接定义就可以，并且不用逗号隔开，加了会报错。</p><p>ES6的类，完全可以看做构造函数的另一种写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(typeof Point)&#x2F;&#x2F;function 说明类的数据类型是函数，类本身就指向构造函数</span><br><span class="line">console.log(Point&#x3D;&#x3D;&#x3D;Point.prototype.constructor)&#x2F;&#x2F;true</span><br><span class="line">使用的时候也是直接对类使用new 命令，跟构造函数的用法完全一致。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Bar&#123;</span><br><span class="line">    todo()&#123;</span><br><span class="line">        console.log(&#39;类&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const b &#x3D; new Bar()</span><br><span class="line">b.todo()&#x2F;&#x2F;&#39;类&#39;</span><br><span class="line">构造函数的prototype属性，在ES6的 类上面继续存在。事实上，类的所有方法都定义在类的 prototype属性上面</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">        constructor() &#123;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        toString() &#123;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        toValue() &#123;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 等同于</span><br><span class="line"></span><br><span class="line">        Point.prototype &#x3D; &#123;</span><br><span class="line">        constructor() &#123;&#125;,</span><br><span class="line">        toString() &#123;&#125;,</span><br><span class="line">        toValue() &#123;&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        上面代码中，所有的方法，其实都是定义在Point.prototype上面</span><br><span class="line">        因此，在类的实例上面调用方法，其实就是调用原型上的方法</span><br></pre></td></tr></table></figure><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class B&#123;&#125;</span><br><span class="line">const b &#x3D; new B()</span><br><span class="line">console.log(b.constructor &#x3D;&#x3D;&#x3D; B.prototype.constructor)&#x2F;&#x2F;true</span><br><span class="line">b是B类的实例，b的constructor()方法就是B类原型的constructor()方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。</span><br><span class="line">Object.assign()方法可以很方便地一次向类天机多个方法。比如：</span><br><span class="line">class Point&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Object.assign(Point.prototype,&#123;</span><br><span class="line">    toString()&#123;&#125;,</span><br><span class="line">    toValue()&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prototype对象的constructor()属性，直接指向&#39;类&#39;的本身，这与ES5的行为是一致的。</span><br><span class="line">Point.prototype.constructor&#x3D;&#x3D;&#x3D;Point &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>另外，类的内部所有定义的方法，都是不可枚举的(non-enumerabal)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">    constructor(x,y)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.keys(Point.prototype))&#x2F;&#x2F;[]</span><br><span class="line">console.log(Object.getOwnPropertyNames(Point.prototype))&#x2F;&#x2F;[&#39;constructor&#39;,&#39;toString&#39;]</span><br><span class="line">这里，toString()方法是Point类 内部定义的方法，它是不可枚举的。这一点与ES5是不一样的</span><br></pre></td></tr></table></figure></code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    var Point &#x3D; function (x,y)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.toString &#x3D; function ()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.keys(Point.prototype))&#x2F;&#x2F;[&#39;toString&#39;]</span><br><span class="line">console.log(Object.getOwnPropertyNames(Point.prototype))&#x2F;&#x2F;[&#39;constructor&#39;,&#39;toString&#39;]</span><br><span class="line">这是ES5 的写法，toString()方法就是可枚举的。</span><br></pre></td></tr></table></figure><p>Constructor()方法<br>    constructor()方法是类的默认方法，是通过new 命令生成对象实例时，自动调用该方法。一个类必须有constructor()<br>    方法，如果没有显示定义，一个空德constructor()方法也会被默认添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Ponit&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;等同于</span><br><span class="line">    class Point&#123;</span><br><span class="line">        constructor()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">这里，定义了一个空的类Point,JS引擎会自动给他添加一个空的constructor()方法。</span><br><span class="line">constructor()方法默认返回实例对象(即this),完全可以指定返回另一个对象</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        return Object.create(null)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Foo() instanceof Foo)&#x2F;&#x2F;false</span><br><span class="line">这里，constructor()函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。</span><br><span class="line">类必须使用new调用，否则会报错，这是它跟普通构造函数的一个主要区别，后者不用new也可以执行</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        return Object.create(null)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo()&#x2F;&#x2F;Class constructor Foo cannot be invoked without &#39;new&#39;</span><br></pre></td></tr></table></figure><p>类的实例！<br>    生成类的实例的写法，与ES5 完全一样，也是使用 new命令。如果没有用 new，像函数那样调用class,将会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> var point &#x3D; Point(2,3)&#x2F;&#x2F;报错</span><br><span class="line"> var point &#x3D; new Point(2,3)&#x2F;&#x2F;正确</span><br></pre></td></tr></table></figure><p>与ES5 一样，实例的属性除非显示定义在其本身(即定义在this上)，否则都是定义在原型上(即定义在class上)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">    constructor(x,y)&#123;</span><br><span class="line">        this.x&#x3D;x</span><br><span class="line">        this.y&#x3D;y</span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line">        return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var point &#x3D; new Point(2,3)</span><br><span class="line">console.log(point.toString(2,3))&#x2F;&#x2F;(2,3)</span><br><span class="line">console.log(point.hasOwnProperty(&#39;x&#39;))&#x2F;&#x2F;true</span><br><span class="line">console.log(point.hasOwnProperty(&#39;y&#39;))&#x2F;&#x2F;true</span><br><span class="line">console.log(point.hasOwnProperty(&#39;toString&#39;))&#x2F;&#x2F;false</span><br><span class="line">console.log(point.__proto__.hasOwnProperty(&#39;toString&#39;))&#x2F;&#x2F;true</span><br><span class="line">上面代码中，x和y都是实例对象point自身属性(因为定义在this变量上)，所以hasOwnProperty()方法返回true，而toString()</span><br><span class="line">是原型对象的属性(因为定义在Point类上)，所以hasOwnProperty()方法返回false,这些都与ES5的行为保持一致</span><br></pre></td></tr></table></figure><p>与ES5一样，类的所有实例共享一个原型对象！！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Point(2,3)</span><br><span class="line">var p2 &#x3D; new Point(1,3)</span><br><span class="line">p1.__proto&#x3D;&#x3D;&#x3D;p2.__proto__&#x2F;&#x2F;true</span><br><span class="line">上面代码中。p1和p2都是Point的实例，他们的原型都是Point.prototype,所以__proto__属性是相等的。</span><br><span class="line">这也意味着，可以通过实例的__proto__属性为&#39;类&#39;添加方法</span><br></pre></td></tr></table></figure><p><strong>proto</strong> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Point(2,3);</span><br><span class="line">var p2 &#x3D; new Point(3,2);</span><br><span class="line"></span><br><span class="line">p1.__proto__.printName &#x3D; function () &#123; return &#39;Oops&#39; &#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class="line">p2.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class="line"></span><br><span class="line">var p3 &#x3D; new Point(4,2);</span><br><span class="line">p3.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class="line">上面代码在p1的原型上添加了一个printName()方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</span><br></pre></td></tr></table></figure><p>取值函(getter)和存值函数(setter)<br>与ES5一样，在’类’的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MyClass&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    get prop()&#123;</span><br><span class="line">        return &#39;getter&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    set prop(value)&#123;</span><br><span class="line">        console.log(&#39;setter:&#39;+value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let inst &#x3D; new MyClass()</span><br><span class="line">console.log(inst.props&#x3D;123)&#x2F;&#x2F;&#39;setter:123&#39;</span><br><span class="line">console.log(inst.prop)&#x2F;&#x2F;&#39;getter&#39;</span><br><span class="line">上面，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了</span><br></pre></td></tr></table></figure><p>存值函数和取值函数式设置在属性的 Desscriptor对象上的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class CustomHTMLElement &#123;</span><br><span class="line">    constructor(element)&#123;</span><br><span class="line">        this.element &#x3D; element</span><br><span class="line">    &#125;</span><br><span class="line">    get html()&#123;</span><br><span class="line">        return thi.element.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">    set html(value)&#123;</span><br><span class="line">        this.element.innerHTML&#x3D;value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var descriptor &#x3D; Object.getOwnPropertyDescriptor(</span><br><span class="line">    CustomHTMLElement.proptotype,&#39;html&#39;</span><br><span class="line">)</span><br><span class="line">&#39;get&#39; in descriptor&#x2F;&#x2F;true</span><br><span class="line">&#39;set&#39; in descriptor&#x2F;&#x2F;true</span><br><span class="line">上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。</span><br></pre></td></tr></table></figure><p>属性表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let nethodName &#x3D; &#39;getArea&#39;</span><br><span class="line">class Square &#123;</span><br><span class="line">    constructor(length)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    [methodName]()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码中，Square类的方法名getArea,是从表达式得到的。</span><br></pre></td></tr></table></figure><p>Class 表达式<br>与函数一样，类也可以使用表达式的形式定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> const MyClass &#x3D; class Me&#123;</span><br><span class="line">    getClassName()&#123;</span><br><span class="line">        return Me.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这里使用表达式定义了一个类，类的名字是Me,但是Me只在Class的内部可用，指代当前类。在Class外部，这个类只能用myClass引用</span><br><span class="line">let inst &#x3D; new MyClass()</span><br><span class="line">console.log(inst.getClassName())&#x2F;&#x2F;Me</span><br><span class="line">Me.name&#x2F;&#x2F;Me is not defined</span><br><span class="line">这里就可以说明，Me只在Class内部有定义</span><br><span class="line"></span><br><span class="line">如果类的内部没有用到的话，可以省略Me,也就是可以下面的形式</span><br><span class="line">const MyClass &#x3D; class &#123;&#x2F;&#x2F;....&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">采用Class 表达式，可以写出立即执行的Class</span><br><span class="line">let person &#x3D; new class&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(&#39;李华&#39;)</span><br><span class="line">person.sayName()</span><br><span class="line">这里 person是一个立即执行的类的实例</span><br></pre></td></tr></table></figure><p>注意点<br>（1）严格模式</p><p>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。<br>（2）不存在提升<br>累不存在变量提升，这一点与ES5完全不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Foo()</span><br><span class="line">class Foo&#123;&#125;</span><br><span class="line">上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承者有关，必须保证子类在父类之后定义。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let Foo &#x3D; class&#123;&#125;</span><br><span class="line">    class Bar extends Foo&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。</span><br></pre></td></tr></table></figure><p>（3）name 属性<br>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;&#125;</span><br><span class="line">Point.name&#x2F;&#x2F;&#39;Point&#39;</span><br><span class="line">name属性总是返回紧跟在class关键字后面的类。</span><br></pre></td></tr></table></figure><p>（4）Generator 方法<br>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    constructor(...args)&#123;</span><br><span class="line">        this.args &#x3D; args</span><br><span class="line">    &#125;</span><br><span class="line">    *[Symbol.iterator]()&#123;</span><br><span class="line">        for(let arg of this.args)&#123;</span><br><span class="line">            yield arg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(let x of new Foo(&#39;hello&#39;,&#39;world&#39;))&#123;</span><br><span class="line">    console.log(x)</span><br><span class="line">&#125;</span><br><span class="line">上面的代码中，Foo类的Symbol.interator方法前有一个星号，表示该方法是一个Generator 函数。Symbol.interator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。</span><br></pre></td></tr></table></figure><p>5）this 的指向<br>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Logger&#123;</span><br><span class="line">    printName(name&#x3D;&#39;there&#39;)&#123;</span><br><span class="line">        this.print(&#96;Hello $&#123;name&#125;&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">    print(text)&#123;</span><br><span class="line">        console.log(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const logger &#x3D; new Logger()</span><br><span class="line">const &#123; printName&#125; &#x3D; logger</span><br><span class="line">console.log(printName())&#x2F;&#x2F;Cannot read property &#39;print&#39; of undefined</span><br><span class="line">上面代码中，printName方法中的this，默认指向Logger类的实例，但是。如果将这个方法提取出来单独使用，this会指向该方法运行是所在的环境(由于class内部是严格模式，所以this实际指向的是undefined),从而导致找不到print方法而报错。</span><br><span class="line">一个比较简单的解决方法是，在构造函数中绑定this。这样就不会找不到print方法了。</span><br><span class="line">class Logger &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.printName &#x3D; this.printName.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">另一种解决方法是使用箭头函数。</span><br><span class="line">class Obj&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.getThis &#x3D; () &#x3D;&gt; this</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const myObj &#x3D; new Obj()</span><br><span class="line">myObj.getThis() &#x3D;&#x3D;&#x3D; myObj&#x2F;&#x2F;true</span><br><span class="line">箭头函数内部的this总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，实在构造函数执行的时候，这时，箭头函数所在的运行环境，肯定是实例对象，所以this会总是指向实例对象</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。</span><br><span class="line">function selfish (target) &#123;</span><br><span class="line">  const cache &#x3D; new WeakMap();</span><br><span class="line">  const handler &#x3D; &#123;</span><br><span class="line">    get (target, key) &#123;</span><br><span class="line">      const value &#x3D; Reflect.get(target, key);</span><br><span class="line">      if (typeof value !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        return value;</span><br><span class="line">      &#125;</span><br><span class="line">      if (!cache.has(value)) &#123;</span><br><span class="line">        cache.set(value, value.bind(target));</span><br><span class="line">      &#125;</span><br><span class="line">      return cache.get(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  const proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">  return proxy;</span><br><span class="line">&#125;</span><br><span class="line">const logger &#x3D; selfish(new Logger());</span><br></pre></td></tr></table></figure><p>2.静态方法<br>类相当于实例的原型。所有在类中定义的方法，都会被实例继承，如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为‘静态方法’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    static classMethod()&#123;</span><br><span class="line">        return &#39;hello&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Foo.classMethod())&#x2F;&#x2F;&#39;hello&#39;</span><br><span class="line">var foo &#x3D; new Foo()</span><br><span class="line">console.log(foo.classMethod())&#x2F;&#x2F;foo.classMethod is not a function</span><br><span class="line">上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用</span><br><span class="line">(Foo.classMethod()),而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法</span><br></pre></td></tr></table></figure><p>注意：如果静态方法包含this关键字，这个this指的是类，而不是实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    static bar()&#123;</span><br><span class="line">        this.baz()</span><br><span class="line">    &#125;</span><br><span class="line">    static baz()&#123;</span><br><span class="line">        console.log(&#39;hello&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    baz()&#123;</span><br><span class="line">        console.log(&#39;world&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    console.log(Foo.bar())&#x2F;&#x2F;hello</span><br><span class="line"></span><br><span class="line">上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo的类，而不是Foo的实例，等同于调用Foo.baz.另外，从这个例子还可以看出，静态方法可以与非静态方法重名</span><br></pre></td></tr></table></figure><p>父类的静态方法，可以被子类继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    static classMethod()&#123;</span><br><span class="line">        return &#39;hello&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Bar extends Foo&#123;&#125;</span><br><span class="line">console.log(Bar.classMethod())&#x2F;&#x2F;hello</span><br><span class="line">这里，父类Foo有一个静态方法，子类Bar可以调用这个方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">静态方法也是可以从super对象上调用的</span><br><span class="line">class Foo&#123;</span><br><span class="line">    static classMethod()&#123;</span><br><span class="line">        return &#39;hello&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Bar extends Foo&#123;</span><br><span class="line">    static classMethod()&#123;</span><br><span class="line">        return super.classMethod()+&#39;,too&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Bar.classMethod())&#x2F;&#x2F;hello,too</span><br></pre></td></tr></table></figure><p>3.实例属性的新写法<br>实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class IncreasingCounter&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this._count &#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">    get value()&#123;</span><br><span class="line">        console.log(&#39;Getting the current value&#39;)</span><br><span class="line">        return this._count</span><br><span class="line">    &#125;</span><br><span class="line">    increment()&#123;</span><br><span class="line">        this._count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码中，实例属性this._count定义在constructor()方法里面，另一种写法是，这个属性也可以定义在类的最顶层，其他都不变</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class IncreasingCounter&#123;</span><br><span class="line">    _count &#x3D; 0</span><br><span class="line">    get value()&#123;</span><br><span class="line">        console.log(&#39;Getter the current value&#39;)</span><br><span class="line">        return this._count</span><br><span class="line">    &#125;</span><br><span class="line">    increment()&#123;</span><br><span class="line">        this._count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码中，实例属性_count与取值函数value()和increment()方法，处于同一层级。这时，不需要在实例属性前面加上this。</span><br><span class="line">这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class foo&#123;</span><br><span class="line">    bar &#x3D; &#39;hello&#39;</span><br><span class="line">    baz &#x3D; &#39;world&#39;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码中，一眼就能看出，foo类有两个实例属性，一目了然。另外，写起来也比较简洁</span><br></pre></td></tr></table></figure><p>4.静态属性<br>静态属性指的是Class 本身的属性，即Class.porpName,而不是定义在实例对象(this)上的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop &#x3D; 1</span><br><span class="line">Foo.prop &#x2F;&#x2F;1</span><br><span class="line">上面的写法为Foo类定义了一个静态属性prop</span><br></pre></td></tr></table></figure><p>目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性。写法是在实例属性的前面，加上static关键字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyClass&#123;</span><br><span class="line">    static myStaticProp &#x3D; 42</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        console.log(MyClass.myStaticProp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">new MyClass()</span><br><span class="line">这个新写法大大方便了静态属性的表达</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;&#x2F;&#x2F;老写法</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop &#x3D;1</span><br><span class="line">class Foo&#123;&#x2F;&#x2F;新写法</span><br><span class="line">    static prop &#x3D;1</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，老写法的静态属性定义在类的外部，整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative）,而不是赋值处理，语义更好。</span><br></pre></td></tr></table></figure><p>5.私有方法和私有属性<br>现在的解决方案<br>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问，这是常见需求，有利于代码的封装，但ES6不提供，只能通过变通方法模拟实现。<br>一种做法是在命名上加以区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Widget&#123;</span><br><span class="line">    &#x2F;&#x2F;公有方法</span><br><span class="line">    foo(baz)&#123;</span><br><span class="line">        this._bar(baz)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;私有属性</span><br><span class="line">    _bar(baz)&#123;</span><br><span class="line">        return this.snaf &#x3D; baz</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，_bar()方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是这种命名是不保险的。在类的外部，还是可以调用到这个方法</span><br></pre></td></tr></table></figure><p>另一种方法就是索性将私有方法移出类，因为类内部的所有方法都是对外可见的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    bar.call(this, baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar(baz) &#123;</span><br><span class="line">  return this.snaf &#x3D; baz;</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，foo是公开方法，内部调用了bar.call(this, baz)。这使得bar()实际上成为了当前类的私有方法。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;class的基本语法:&lt;br&gt;一.类的由来&lt;br&gt;JS中生成实力对象的传统方法是通过构造函数，下面请看一个例子&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>变量提升</title>
    <link href="http://example.com/2018/05/08/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    <id>http://example.com/2018/05/08/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</id>
    <published>2018-05-08T06:01:41.000Z</published>
    <updated>2020-12-30T06:09:49.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="var的变量提升"><a href="#var的变量提升" class="headerlink" title="var的变量提升"></a>var的变量提升</h1><p>es3/es5<br>1.变量提升：当栈内存（作用域）形成，JS代码自上而下执行之前，浏览器首先会把所有带var和function关键字的进行提前的<br>声明或定义.这种预先处理机制称之为变量提升。<br>3.声明（declare）：var a或function sum<br>4.定义（defined）:a=12 也就是赋值<br>5.变量提升阶段：<br>6.带var的只声明未定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(a)&#x2F;&#x2F;undefined</span><br><span class="line">    var a &#x3D; 12;</span><br><span class="line">    function b(arr)&#123;&#x2F;&#x2F;变量提升阶段function就完成了声明和赋值，浏览器会在全局作用域声明一个b，然后再形成一个堆内存里面</span><br><span class="line">        &#x2F;&#x2F;是函数体里面的代码字符串。这个堆内存会有一个16进制的地址，而全局里面声明的那个b就会指向这个地址</span><br><span class="line">        &#x2F;&#x2F;因为函数在变量提升阶段就完成了声明和赋值，所以在代码执行阶段在遇到b这个函数就不会在重复声明赋值，就会直接跳过</span><br><span class="line">        for(let i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">            console.log(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;跳过后就会执行下面这个函数调用，传了一个数组进去。</span><br><span class="line">    &#x2F;&#x2F;而执行一个函数也就是形成了一个私有栈内存。当私有的作用域形成后也不是立即代码执行，而是先进行变量提升（变量提升前，先形参赋值）</span><br><span class="line">    b([1,2,3,4])</span><br><span class="line">    &#x2F;&#x2F;在ES3和ES5语法规范中,只有全局作用域和函数执行的私有作用域（栈内存），其他大括号不会形成栈内存</span><br></pre></td></tr></table></figure><h1 id="带var与不带var"><a href="#带var与不带var" class="headerlink" title="带var与不带var"></a>带var与不带var</h1><p>在全局作用域下声明一个变量，也相当于给window全局对象设置了一个属性，变量的值就是属性值（私有作用域下声明的私有变量和window没有关系）<br>带function的声明和赋值都完成了<br>变量提升至发生在当前作用域（例如：开始加载页面的时候只对全局作用域下的进行提升，因为此时函数中存储的都是字符串）<br>在全局作用域先声明的函数或者变量是‘全局变量’，同理，在私有作用域下声明的变量是‘私有变量’[带var和function才是声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">console.log(i)&#x2F;&#x2F;undefined</span><br><span class="line">    console.log(window.i)&#x2F;&#x2F;undefined</span><br><span class="line">    console.log(&#39;i&#39; in window)&#x2F;&#x2F;true   在变量提升阶段，在全局作用域中声明了一个变量i，此时就已经把i当做属性值赋值</span><br><span class="line">    &#x2F;&#x2F;给了window了，只不过此时还没有给i赋值，默认是undefined  </span><br><span class="line">    &#x2F;&#x2F; in? ：检测某个属性是否隶属于这个对象</span><br><span class="line">    var i &#x3D; 9&#x2F;&#x2F;变量值修改window的值也跟着修改</span><br><span class="line">    console.log(i)&#x2F;&#x2F;9</span><br><span class="line">    console.log(window.i)&#x2F;&#x2F;9  window的一个属性名为i</span><br><span class="line">    i&#x3D;13</span><br><span class="line">    console.log(window.i)&#x2F;&#x2F;13</span><br><span class="line">    window.i&#x3D;14</span><br><span class="line">    console.log(i)&#x2F;&#x2F;14    重点：全局变量和window的属性存在‘映射机制’，就是有一个改变另一个也跟着改变</span><br></pre></td></tr></table></figure><h1 id="不带var-不带var的本质是window的属性"><a href="#不带var-不带var的本质是window的属性" class="headerlink" title="不带var 不带var的本质是window的属性"></a>不带var 不带var的本质是window的属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;console.log(j)&#x2F;&#x2F;j is not defined   这里的J是按照变量的来识别的</span><br><span class="line">   &#x2F;&#x2F;console.log(window.j)&#x2F;&#x2F;undefined    这里是按照window的属性来识别的，因为对象没有某一个属性返回的就是undefined</span><br><span class="line">   &#x2F;&#x2F;console.log(window.j)&#x2F;&#x2F;false 不存在这个属性</span><br><span class="line">   j&#x3D;10&#x2F;&#x2F; 这里不带var 就相当于给window加了一个属性叫j,值是10</span><br><span class="line">   console.log(j)&#x2F;&#x2F;10</span><br><span class="line">   console.log(window.a)&#x2F;&#x2F;12</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; var q &#x3D;10,</span><br><span class="line">   &#x2F;&#x2F;     s &#x3D;11 &#x2F;&#x2F;这样写s是带var</span><br><span class="line">   &#x2F;&#x2F; var q &#x3D; s &#x3D;11 &#x2F;&#x2F; 这样写不带var  </span><br><span class="line">   &#x2F;&#x2F;在私有作用域中带var和不带var也有区别：带var在私有作用域变量提升阶段都声明为私有变量和外界没有任何关系</span><br><span class="line">   &#x2F;&#x2F;不带var 不是私有变量，它会想它的上级作用域查找，看它是否是上级的变量，不是继续向上查找，一直找到window为止</span><br><span class="line">   &#x2F;&#x2F;这种查找机制叫‘作用域链’</span><br><span class="line">   &#x2F;&#x2F;console.log(n,m)&#x2F;&#x2F;undefined undefined</span><br><span class="line">   var n &#x3D;13;</span><br><span class="line">       m &#x3D;13;</span><br><span class="line">   function fn()&#123;</span><br><span class="line">       console.log(n,m)&#x2F;&#x2F;变量提升阶段先var了一个n所以是 undefined 但是m不带var，向上级查找所以m是13  ；</span><br><span class="line">       var n &#x3D; m &#x3D; 14&#x2F;&#x2F;此时都是14</span><br><span class="line">       console.log(n,m)&#x2F;&#x2F;14 14</span><br><span class="line">   &#125;</span><br><span class="line">   fn()</span><br><span class="line">   console.log(a,m)&#x2F;&#x2F; 这里的a是全局的所以是13，b在函数里被重新赋值所以是14</span><br></pre></td></tr></table></figure><h1 id="在私有作用域中如果向上级查找变量到window的时候发现window也没有这个属性时又是怎么做的呢？"><a href="#在私有作用域中如果向上级查找变量到window的时候发现window也没有这个属性时又是怎么做的呢？" class="headerlink" title="在私有作用域中如果向上级查找变量到window的时候发现window也没有这个属性时又是怎么做的呢？"></a>在私有作用域中如果向上级查找变量到window的时候发现window也没有这个属性时又是怎么做的呢？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unction f()&#123;</span><br><span class="line">        b &#x3D; 13</span><br><span class="line">        console.log(&#39;b&#39; in window)&#x2F;&#x2F;true  在作用域查找的过程中，如果找到window也没有这个变量，相当于给window设置了</span><br><span class="line">        &#x2F;&#x2F;了一个属性b</span><br><span class="line">        console.log(b)&#x2F;&#x2F;13</span><br><span class="line">    &#125;</span><br><span class="line">    f()</span><br><span class="line">    console.log(b)&#x2F;&#x2F;13</span><br></pre></td></tr></table></figure><h1 id="只对等于号左边进行变量提升"><a href="#只对等于号左边进行变量提升" class="headerlink" title="只对等于号左边进行变量提升"></a>只对等于号左边进行变量提升</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fnn()&#x2F;&#x2F; fnn is not a function </span><br><span class="line">    sun()&#x2F;&#x2F;2 </span><br><span class="line">    var fnn &#x3D; function ()&#123;&#x2F;&#x2F;函数表达式声明 因为是用var关键字声明在变量提升阶段只提升了等号左边的fnn,</span><br><span class="line">        &#x2F;&#x2F;但是并没有定义或赋值，所以在上面调用时报错</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;</span><br><span class="line">    fnn()</span><br><span class="line">    function sun ()&#123;&#x2F;&#x2F;普通方式声明的函数在 变量提升阶段就已经声明和定义完毕 所以上面可以直接执行</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;</span><br><span class="line">    sun()</span><br></pre></td></tr></table></figure><h1 id="条件判断下变量提升"><a href="#条件判断下变量提升" class="headerlink" title="条件判断下变量提升"></a>条件判断下变量提升</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">console.log(z)</span><br><span class="line">    if(1&#x3D;&#x3D;&#x3D;2)&#123;&#x2F;&#x2F;在当前作用域下，不管条件是否成功都要进行变量提升，</span><br><span class="line">        &#x2F;&#x2F;带var的还是只是声明</span><br><span class="line">        &#x2F;&#x2F;带function的在老版本浏览器渲染机制下，声明+定义都处理，但是为了迎合es6中的块级作用域，新版浏览器对于函数</span><br><span class="line">        &#x2F;&#x2F;（在条件判断中的函数），不管条件是否成立，都是先声明，没有赋值。</span><br><span class="line">        var z &#x3D; 10</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(z)</span><br><span class="line"></span><br><span class="line">    if(1&#x3D;&#x3D;&#x3D;1)&#123;</span><br><span class="line">        console.log(fs)&#x2F;&#x2F;函数本身：当条件成立，进入到判断体中（ES6中它是以个块级作用域）第一件事并不是变量提升，</span><br><span class="line">        &#x2F;&#x2F;先把fs声明并定义，也就是判断体中代买执行前，fs就已经赋值了</span><br><span class="line">        function fs()&#123;</span><br><span class="line">            console.log(&#39;ok&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(fs)&#x2F;&#x2F;函数本身</span><br></pre></td></tr></table></figure><h1 id="ES6中let创建的变量不存在变量提升。不允许重复定义-暂时性死区-切断了全局变量和window属性的映射机制"><a href="#ES6中let创建的变量不存在变量提升。不允许重复定义-暂时性死区-切断了全局变量和window属性的映射机制" class="headerlink" title="ES6中let创建的变量不存在变量提升。不允许重复定义  暂时性死区 ,切断了全局变量和window属性的映射机制"></a>ES6中let创建的变量不存在变量提升。不允许重复定义  暂时性死区 ,切断了全局变量和window属性的映射机制</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(a)&#x2F;&#x2F;a is not defined</span><br><span class="line">    let a &#x3D;12</span><br><span class="line">    console.log(window.a)&#x2F;&#x2F;undefined</span><br><span class="line">    console&#x2F;log(a)&#x2F;&#x2F;12</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;var的变量提升&quot;&gt;&lt;a href=&quot;#var的变量提升&quot; class=&quot;headerlink&quot; title=&quot;var的变量提升&quot;&gt;&lt;/a&gt;var的变量提升&lt;/h1&gt;&lt;p&gt;es3/es5&lt;br&gt;1.变量提升：当栈内存（作用域）形成，JS代码自上而下执行之前，浏览器</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JS面试题</title>
    <link href="http://example.com/2018/03/13/mianshiti/"/>
    <id>http://example.com/2018/03/13/mianshiti/</id>
    <published>2018-03-13T01:39:40.000Z</published>
    <updated>2021-02-23T01:40:58.195Z</updated>
    
    <content type="html"><![CDATA[<h5 id="js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别"><a href="#js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别" class="headerlink" title="js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别"></a>js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别</h5><pre><code>String、Number、Boolean、Null、undefinedObject为复杂数据类型基本数据类型把数据名和值直接存储在栈当中复杂数据类型在栈中存储数据名和一个堆的地址，在堆中存储属性和值，访问时先从栈中获取地址再到堆中取相应的值</code></pre><h5 id="和-有什么区别"><a href="#和-有什么区别" class="headerlink" title="== 和 === 有什么区别"></a>== 和 === 有什么区别</h5><pre><code>==用于一般比较 比较时可以转换数据类型 ===用于严格比较 比较时只要类型不匹配就返回false</code></pre><h5 id="例举3种强制类型转换和2种隐式类型转换"><a href="#例举3种强制类型转换和2种隐式类型转换" class="headerlink" title="例举3种强制类型转换和2种隐式类型转换?"></a>例举3种强制类型转换和2种隐式类型转换?</h5><pre><code>强制：通过String（），Number（），Boolean（）函数强制转换隐式：（乘，除，大于，小于，减，==）</code></pre><h5 id="split-和-join-的区别"><a href="#split-和-join-的区别" class="headerlink" title="split() 和 join() 的区别"></a>split() 和 join() 的区别</h5><pre><code>split() 字符串转数组 如：var str = &quot;hello?word?welcome&quot;  console.log(str.split(“？”)) 返回值为 [&quot;hello&quot;, &quot;word&quot;, &quot;welcome&quot;]join() 数组转字符串 如：var arr = new Array() arr[0] = &quot;hello&quot; arr[1] = &quot;world&quot; arr[3] = &quot;welcome&quot; arr.join(&quot;、&quot;)  返回值为 &quot;hello、world、welcome&quot;</code></pre><h5 id="ajax请求的时候get-和post方式的区别"><a href="#ajax请求的时候get-和post方式的区别" class="headerlink" title="ajax请求的时候get 和post方式的区别"></a>ajax请求的时候get 和post方式的区别</h5><pre><code>一个在url后面 ，一个放在虚拟载体里面get有大小限制(只能提交少量参数)安全问题应用不同 ，请求数据和提交数据</code></pre><h5 id="解释jsonp的原理，以及为什么不是真正的ajax"><a href="#解释jsonp的原理，以及为什么不是真正的ajax" class="headerlink" title="解释jsonp的原理，以及为什么不是真正的ajax"></a>解释jsonp的原理，以及为什么不是真正的ajax</h5><pre><code>jsonp的核心原理就是目标页面回调本地页面的方法,并带入参数动态创建script标签，使用回调函数Ajax是页面无刷新请求数据操作</code></pre><h5 id="call-、bind-、apply-区别"><a href="#call-、bind-、apply-区别" class="headerlink" title="call()、bind()、apply()区别"></a>call()、bind()、apply()区别</h5><pre><code>三者都是可以改变this的指向bind() 返回对应函数便于稍后调用；call()、apply()则是立即调用call() call(thisArg, case1, case2, case3,...) 第一个参数是对象 后面是字符串apply() apply(thisArg, [case1, case2, case3,...]) 第一个参数是对象  后面是数组</code></pre><h5 id="数组有哪些操作方法"><a href="#数组有哪些操作方法" class="headerlink" title="数组有哪些操作方法"></a>数组有哪些操作方法</h5><pre><code>unshift()  把参数添加到数组开头shift() 把数组的第一个元素删除push() 向数组末尾添加一个或多个元素pop() 把数组的最后一个元素删除 concat() 连接两个或多个数组join() 数组转成字符串reverse() 数组倒叙slice() 截取后返回新数组 [&#39;H&#39;,&#39;el&#39;,&#39;lo&#39;,&#39;wo&#39;,&#39;rld!&#39;].slice(1,3) 返回 [&quot;el&quot;, &quot;lo&quot;]splice() 添加或删除数组中的元素，这种方法会改变原始数组sort() 数组元素排序forEach() 遍历数组filter() 返回符合条件的新数组，arr.filter((item,index,arr)=&gt;&#123;return 测试语句&#125;)Map()  </code></pre><h5 id="对象有哪些操作方法"><a href="#对象有哪些操作方法" class="headerlink" title="对象有哪些操作方法"></a>对象有哪些操作方法</h5><pre><code>assign() 合并对像is() 对象比较是否严格相等keys() 遍历键名，返回所有键名数组values() 遍历键值，返回键值数组</code></pre><h5 id="什么是闭包-有什么特性，对页面有什么影响"><a href="#什么是闭包-有什么特性，对页面有什么影响" class="headerlink" title="什么是闭包,有什么特性，对页面有什么影响"></a>什么是闭包,有什么特性，对页面有什么影响</h5><pre><code>可以调用其它函数内部变量的函数闭包就是能够读取其他函数内部变量的函数,避免变量污染、加强了封装性，逻辑性比较强代码的可读性高；加载到内存中执行效率高,使得函数不被GC回收，如果过多使用闭包，容易导致内存泄露,在内存中，造成了内存浪费，如果滥用闭包是灾难性的；</code></pre><h4 id="闭包的好处"><a href="#闭包的好处" class="headerlink" title="闭包的好处"></a>闭包的好处</h4><pre><code>(1)希望一个变量长期驻扎在内存当中(不被垃圾回收机制回收)(2)避免全局变量的污染(3)私有成员的存在(4)安全性提高</code></pre><h5 id="怎么创建闭包"><a href="#怎么创建闭包" class="headerlink" title="怎么创建闭包"></a>怎么创建闭包</h5><pre><code>在函数内部嵌套使用函数</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">        for (var i &#x3D; 0; i &lt; 2; i++) &#123;</span><br><span class="line">            (function () &#123;</span><br><span class="line">                var variate &#x3D; i;</span><br><span class="line">                setTimeout(function () &#123;</span><br><span class="line">                    console.log(&quot;setTimeout执行后:&quot;+variate);</span><br><span class="line">                &#125;, 1000);</span><br><span class="line">            &#125;)();&#x2F;&#x2F;闭包,立即执行函数,匿名函数</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        console.log(i);&#x2F;&#x2F;2</span><br><span class="line">        console.log(variate);&#x2F;&#x2F;variate is not defined</span><br><span class="line">    &#125;</span><br><span class="line">    fn();</span><br></pre></td></tr></table></figure><h5 id="如何阻止事件冒泡"><a href="#如何阻止事件冒泡" class="headerlink" title="如何阻止事件冒泡"></a>如何阻止事件冒泡</h5><pre><code>e.stopPropagation()（IE:window.event.cancelBubble=true）</code></pre><h5 id="如何阻止默认事件、阻止标签自带功能"><a href="#如何阻止默认事件、阻止标签自带功能" class="headerlink" title="如何阻止默认事件、阻止标签自带功能"></a>如何阻止默认事件、阻止标签自带功能</h5><pre><code>e.preventDefault()（IE:window.event.returnValue=false）</code></pre><h5 id="0级事件和2级事件"><a href="#0级事件和2级事件" class="headerlink" title="0级事件和2级事件"></a>0级事件和2级事件</h5><pre><code>0级：dom.on事件名称=function()&#123;&#125;2级：dom.addEvenListener(&#39;事件类型&#39;,function()&#123;&#125;,布尔值(为true表在捕du获阶段调用处理函数.false在冒泡阶段调用.为了兼zhi,一般都用false))</code></pre><h5 id="添加-删除-替换-插入到某个接点的方法"><a href="#添加-删除-替换-插入到某个接点的方法" class="headerlink" title="添加 删除 替换 插入到某个接点的方法"></a>添加 删除 替换 插入到某个接点的方法</h5><pre><code>1）创建新节点createElement() //创建一个具体的元素createTextNode() //创建一个文本节点2）添加、移除、替换、插入appendChild() //添加removeChild() //移除replaceChild() //替换insertBefore() //插入3）查找getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值getElementById() //通过元素Id，唯一性</code></pre><h5 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h5><pre><code>null表示没有对象，该处不该有值，转为数值时为0undefined表示缺少值，该处应该有值，但是未定义，转为数值时为NaN</code></pre><h5 id="什么是变量提升"><a href="#什么是变量提升" class="headerlink" title="什么是变量提升"></a>什么是变量提升</h5><pre><code>变量提升是js的默认行为，变量提升会将所有变量声明移动到当前作用域的顶部，并可以在声明之前使用该变量，初始化不会被提升，提升的仅作用于变量的声明</code></pre><h5 id="什么是事件委托"><a href="#什么是事件委托" class="headerlink" title="什么是事件委托"></a>什么是事件委托</h5><pre><code>利用事件冒泡的原理，把原本需要绑定的事件委托给父元素，让父元素负责事件监听</code></pre><h5 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h5><pre><code>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象</code></pre><h5 id="async与defer区别"><a href="#async与defer区别" class="headerlink" title="async与defer区别"></a>async与defer区别</h5><pre><code>异步(async) 脚本将在其加载完成后立即执行，而 延迟(defer) 脚本将等待 HTML 解析完成后，并按加载顺序执行。</code></pre><h5 id="cookies，sessionStorage和localStorage-有什么区别？"><a href="#cookies，sessionStorage和localStorage-有什么区别？" class="headerlink" title="cookies，sessionStorage和localStorage 有什么区别？"></a>cookies，sessionStorage和localStorage 有什么区别？</h5><pre><code>cookies可以和服务端交互，数据大小不会超过4k，设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭，使用方法需要自己封装不够友好;sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存，虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大，有封装好的方法，可以直接存取值localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除。</code></pre><h5 id="数组去重有哪些方法"><a href="#数组去重有哪些方法" class="headerlink" title="数组去重有哪些方法"></a>数组去重有哪些方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Set()  如：var arr &#x3D; [1,2,3,9,6,3,1,2,6] new set(arr)</span><br></pre></td></tr></table></figure><p>利用冒泡for循环嵌套，然后splice()去重 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr)&#123;            </span><br><span class="line">        for(var i&#x3D;0; i&lt;arr.length; i++)&#123;</span><br><span class="line">            for(var j&#x3D;i+1; j&lt;arr.length; j++)&#123;</span><br><span class="line">                if(arr[i]&#x3D;&#x3D;arr[j])&#123;         &#x2F;&#x2F;第一个等同于第二个，splice方法删除第二个</span><br><span class="line">                    arr.splice(j,1);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line">console.log(unique(arr))</span><br></pre></td></tr></table></figure><h5 id="indexOf-去重-如："><a href="#indexOf-去重-如：" class="headerlink" title="indexOf()去重 如："></a>indexOf()去重 如：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#39;type error!&#39;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array &#x3D; [];</span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (array .indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">            array .push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line">    console.log(unique(arr))</span><br></pre></td></tr></table></figure><h5 id="sort-去重-如："><a href="#sort-去重-如：" class="headerlink" title="sort()去重 如："></a>sort()去重 如：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123; </span><br><span class="line">    if (!Array.isArray(arr)) &#123; </span><br><span class="line">        console.log(&#39;type error!&#39;) return;</span><br><span class="line">    &#125; </span><br><span class="line">    arr &#x3D; arr.sort() </span><br><span class="line">    var arrry&#x3D; [arr[0]]; </span><br><span class="line">    for (var i &#x3D; 1; i &lt; arr.length; i++) &#123; </span><br><span class="line">        if (arr[i] !&#x3D;&#x3D; arr[i-1]) &#123; </span><br><span class="line">            arrry.push(arr[i]);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return arrry; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line"></span><br><span class="line">console.log(unique(arr))</span><br></pre></td></tr></table></figure><h5 id="filter-去重-如"><a href="#filter-去重-如" class="headerlink" title="filter()去重 如:"></a>filter()去重 如:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123; </span><br><span class="line">    return arr.filter(function(item, index, arr) &#123; </span><br><span class="line">        return arr.indexOf(item, 0) &#x3D;&#x3D;&#x3D; index;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line"></span><br><span class="line">console.log(unique(arr))</span><br></pre></td></tr></table></figure><h5 id="行代码实现数组去重？"><a href="#行代码实现数组去重？" class="headerlink" title="行代码实现数组去重？"></a>行代码实现数组去重？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new Set([1,2,3,1,&#39;a&#39;,1,&#39;a&#39;])]</span><br></pre></td></tr></table></figure><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var array &#x3D; [5, 4, 3, 2, 1];</span><br><span class="line">var temp &#x3D; 0;</span><br><span class="line">for (var i &#x3D; 0; i &lt;array.length; i++)&#123;</span><br><span class="line">    for (var j &#x3D; 0; j &lt;array.length - i; j++)&#123;</span><br><span class="line">        if (array[j] &gt; array[j + 1])&#123;</span><br><span class="line">            temp &#x3D; array[j + 1];</span><br><span class="line">            array[j + 1] &#x3D; array[j];</span><br><span class="line">            array[j] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="降维数组"><a href="#降维数组" class="headerlink" title="降维数组"></a>降维数组</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr&#x3D;[[1,2],[3,4]];</span><br><span class="line">function Jw(obj)&#123;</span><br><span class="line">    return Array.prototype.concat.apply([],obj);</span><br><span class="line">&#125;</span><br><span class="line">Jw(arr);</span><br></pre></td></tr></table></figure><h5 id="GET-和-POST-有什么区别"><a href="#GET-和-POST-有什么区别" class="headerlink" title="GET 和 POST 有什么区别"></a>GET 和 POST 有什么区别</h5><pre><code>GET请求在浏览器回退和刷新时是无害的，而POST请求会告知用户数据会被重新提交；GET请求可以收藏为书签，POST请求不可以收藏为书签；GET请求可以被缓存，POST请求不可以被缓存，除非在响应头中包含合适的Cache-Control/Expires字段，但是不建议缓存POST请求，其不满足幂等性，每次调用都会对服务器资源造成影响；GET请求一般不具有请求体，因此只能进行url编码，而POST请求支持多种编码方式。GET请求的参数可以被保留在浏览器的历史中，POST请求不会被保留；GET请求因为是向URL添加数据，不同的浏览器厂商，代理服务器，web服务器都可能会有自己的长度限制，而POST请求无长度限制；GET请求只允许ASCII字符，POST请求无限制，支持二进制数据；GET请求的安全性较差，数据被暴露在浏览器的URL中，所以不能用来传递敏感信息，POST请求的安全性较好，数据不会暴露在URL中；GET请求具有幂等性(多次请求不会对资源造成影响)，POST请求不幂等；GET请求一般不具有请求体，请求中一般不包含100-continue 协议，所以只会发一次请求，而POST请求在发送数据到服务端之前允许双方&quot;握手&quot;，客户端先发送Expect:100-continue消息，询问服务端是否愿意接收数据，接收到服务端正确的100-continue应答后才会将请求体发送给服务端，服务端再响应200返回数据。</code></pre><h5 id="跨域有几种解决方案"><a href="#跨域有几种解决方案" class="headerlink" title="跨域有几种解决方案"></a>跨域有几种解决方案</h5><pre><code>jsonp 适用于get请求document.domain + iframe 适用于主域相同 子域不同  两个页面都通过js强制设置document.domain为基础主域，就实现了同域location.hash + iframe window.name + iframe postMessage (data,origin)方法接受两个参数data：需要传递的数据，html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin：协议+主机+端口号，也可以设置为&quot;*&quot;，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为&quot;/&quot;。跨域资源共享（CORS）</code></pre><h5 id="typeof和instanceof有什么区别"><a href="#typeof和instanceof有什么区别" class="headerlink" title="typeof和instanceof有什么区别"></a>typeof和instanceof有什么区别</h5><pre><code>typeof 判断一个数据是什么数据类型；一般只能返回如下几个结果：&quot;number&quot;、&quot;string&quot;、&quot;boolean&quot;、&quot;object&quot;、&quot;function&quot; 和 &quot;undefined&quot;。instanceof 判断一个对象是否在另一个对象的原型链上</code></pre><h5 id="函数声明与函数表达式的区别？"><a href="#函数声明与函数表达式的区别？" class="headerlink" title="函数声明与函数表达式的区别？"></a>函数声明与函数表达式的区别？</h5><pre><code>在Javscript中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。</code></pre><h5 id="Javascript的事件流模型都有什么"><a href="#Javascript的事件流模型都有什么" class="headerlink" title="Javascript的事件流模型都有什么?"></a>Javascript的事件流模型都有什么?</h5><pre><code>“事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播“事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的“DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡</code></pre><h5 id="希望获取到页面中所有的checkbox怎么做？-不使用第三方框架"><a href="#希望获取到页面中所有的checkbox怎么做？-不使用第三方框架" class="headerlink" title="希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)"></a>希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var inputs &#x3D; document.getElementsByTagName(&quot;input&quot;);&#x2F;&#x2F;获取所有的input标签对象</span><br><span class="line">var checkboxArray &#x3D; [];&#x2F;&#x2F;初始化空数组，用来存放checkbox对象。</span><br><span class="line">for(var i&#x3D;0;i&lt;inputs.length;i++)&#123;</span><br><span class="line">    var obj &#x3D; inputs[i];</span><br><span class="line">    if(obj.type&#x3D;&#x3D;&#39;checkbox&#39;)&#123;</span><br><span class="line">        checkboxArray.push(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="如何获取javascript三个数中的最大值和最小值？"><a href="#如何获取javascript三个数中的最大值和最小值？" class="headerlink" title="如何获取javascript三个数中的最大值和最小值？"></a>如何获取javascript三个数中的最大值和最小值？</h5><pre><code>Math.max(a,b,c);//最大值Math.min(a,b,c)//最小值</code></pre><h5 id="javascript是面向对象的，怎么体现javascript的继承关系？"><a href="#javascript是面向对象的，怎么体现javascript的继承关系？" class="headerlink" title="javascript是面向对象的，怎么体现javascript的继承关系？"></a>javascript是面向对象的，怎么体现javascript的继承关系？</h5><pre><code>使用prototype原型来实现。</code></pre><h5 id="列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型。"><a href="#列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型。" class="headerlink" title="列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型。"></a>列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型。</h5><pre><code>主要数据类型：string, boolean, number复合数据类型：function, object特殊类型：undefined，null</code></pre><h5 id="解释什么是Json"><a href="#解释什么是Json" class="headerlink" title="解释什么是Json:"></a>解释什么是Json:</h5><pre><code>(1)JSON 是一种轻量级的数据交换格式。(2)JSON 独立于语言和平台，JSON 解析器和 JSON 库支持许多不同的编程语言。(3)JSON的语法表示三种类型值，简单值(字符串，数值，布尔值，null),数组，对象</code></pre><h5 id="js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？"><a href="#js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？" class="headerlink" title="js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？"></a>js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？</h5><pre><code>alertconfirmprompt</code></pre><h4 id="浏览器的滚动距离："><a href="#浏览器的滚动距离：" class="headerlink" title="浏览器的滚动距离："></a>浏览器的滚动距离：</h4><pre><code>可视区域距离页面顶部的距离scrollTop=document.documentElement.scrollTop||document.body.scrollTop</code></pre><h5 id="innerHTML、innerText和outerHTML的区别"><a href="#innerHTML、innerText和outerHTML的区别" class="headerlink" title="innerHTML、innerText和outerHTML的区别"></a>innerHTML、innerText和outerHTML的区别</h5><pre><code>innerHTML(元素内包含的内容）innerText(元素的文本内容）outerHTML(自己以及元素内的内容）</code></pre><h5 id="offsetWidth-offsetHeight和clientWidth-clientHeight的区别"><a href="#offsetWidth-offsetHeight和clientWidth-clientHeight的区别" class="headerlink" title="offsetWidth offsetHeight和clientWidth clientHeight的区别"></a>offsetWidth offsetHeight和clientWidth clientHeight的区别</h5><pre><code>(1)offsetWidth （content宽度+padding宽度+border宽度）(2)offsetHeight（content高度+padding高度+border高度）(3)clientWidth（content宽度+padding宽度）(4)clientHeight（content高度+padding高度）</code></pre><h5 id="请解释一下什么是语义化的HTML。"><a href="#请解释一下什么是语义化的HTML。" class="headerlink" title="请解释一下什么是语义化的HTML。"></a>请解释一下什么是语义化的HTML。</h5><pre><code>内容使用特定标签，通过标签就能大概了解整体页面的布局分布</code></pre><h5 id="请说出三种减低页面加载时间的方法"><a href="#请说出三种减低页面加载时间的方法" class="headerlink" title="请说出三种减低页面加载时间的方法"></a>请说出三种减低页面加载时间的方法</h5><pre><code>1、压缩css、js文件2、合并js、css文件，减少http请求3、外部js、css文件放在最底下4、减少dom操作，尽可能用变量替代不必要的dom操作</code></pre><h5 id="请解释什么是Javascript的模块模式，并举出实用实例。"><a href="#请解释什么是Javascript的模块模式，并举出实用实例。" class="headerlink" title="请解释什么是Javascript的模块模式，并举出实用实例。"></a>请解释什么是Javascript的模块模式，并举出实用实例。</h5><pre><code>js模块化mvc（数据层、表现层、控制层）seajs命名空间</code></pre><h5 id="你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？"><a href="#你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？" class="headerlink" title="你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？"></a>你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？</h5><pre><code>对内：模块模式对外：继承</code></pre><h5 id="你如何优化自己的代码？"><a href="#你如何优化自己的代码？" class="headerlink" title="你如何优化自己的代码？"></a>你如何优化自己的代码？</h5><pre><code>代码重用避免全局变量（命名空间，封闭空间，模块化mvc..）拆分函数避免函数过于臃肿注释</code></pre><h4 id="你能解释一下JavaScript中的继承是如何工作的吗？"><a href="#你能解释一下JavaScript中的继承是如何工作的吗？" class="headerlink" title="你能解释一下JavaScript中的继承是如何工作的吗？"></a>你能解释一下JavaScript中的继承是如何工作的吗？</h4><pre><code>子构造函数中执行父构造函数，并用call\apply改变this克隆父构造函数原型上的方法</code></pre><h5 id="最简单的一道题"><a href="#最简单的一道题" class="headerlink" title="最简单的一道题"></a>最简单的一道题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 2, b &#x3D; 3;</span><br><span class="line">var c &#x3D; a++ + b; </span><br><span class="line">&#x2F;&#x2F; c &#x3D; 5</span><br></pre></td></tr></table></figure><h5 id="dom事件委托什么原理，有什么优缺点"><a href="#dom事件委托什么原理，有什么优缺点" class="headerlink" title="dom事件委托什么原理，有什么优缺点"></a>dom事件委托什么原理，有什么优缺点</h5><pre><code>事件委托原理:事件冒泡机制优点1.可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错。2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适缺点事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。</code></pre><h5 id="js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型"><a href="#js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型" class="headerlink" title="js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型"></a>js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型</h5><pre><code>1.基本数据类型（自身不可拆分的）：Undefined、Null、Boolean、Number、String2.引用数据类型（对象）：Object （Array，Date，RegExp，Function）ES6基本数据类型多了个symbol 据说这道题刷了百分之二十的人 感谢Abbyshen提出</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function gettype(nm)&#123;</span><br><span class="line">    return Object.prototype.toString.call(nm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处"><a href="#js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处" class="headerlink" title="js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处"></a>js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处</h5><pre><code>1 标记清除（mark and sweep）2 引用计数（reference counting）好处：大幅简化程序的内存管理代码，减轻程序猿负担，并且减少因为长时间运转而带来的内存泄露问题。坏处：自动回收意味着程序猿无法掌控内存。ECMAScript中没有暴露垃圾回收的借口，我们无法强迫其进行垃圾回收，更加无法干预内存管理。</code></pre><h5 id="setTimeout-和-setInterval-细谈"><a href="#setTimeout-和-setInterval-细谈" class="headerlink" title="setTimeout 和 setInterval 细谈"></a>setTimeout 和 setInterval 细谈</h5><pre><code>常问的点，前者是在一定时间过后将函数添加至执行队列，执行时间=延迟时间+之前函数代码执行时间+执行函数时间。后者是不管前一次是否执行完毕，每隔一定时间重复执行，用于精准执行互相没有影响的重复操作。如果需要控制前后执行顺序，最好使用setTimeout模拟setInterval</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var time &#x3D; 400, times &#x3D; 0, max &#x3D; 10;</span><br><span class="line">function func()&#123;</span><br><span class="line">times++;</span><br><span class="line">if(times &lt; max)&#123;</span><br><span class="line">    &#x2F;&#x2F;code here</span><br><span class="line">    setTimeout(func, time);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&quot;finished&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(func, time);</span><br></pre></td></tr></table></figure><h5 id="判断数组"><a href="#判断数组" class="headerlink" title="判断数组"></a>判断数组</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isArray(arr)&#123;</span><br><span class="line">    return Object.prototype.toString.call(arr) &#x3D;&#x3D;&#x3D; &#39;[Object Array]&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h5><pre><code>即使在页面打开多层iframe后，每个iframe中window.name 属性值都是相同的，以此用作数据传输的工具。但由于跨域的限制，是无法获取另一个frame中的window.name数据，所以要使用一个同域的代理(proxy.html)：</code></pre><h5 id="forEach和map的区别"><a href="#forEach和map的区别" class="headerlink" title="forEach和map的区别"></a>forEach和map的区别</h5><h6 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h6><pre><code>都是循环遍历数组中的每一项forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组）匿名函数中的this都是指向window只能遍历数组都有兼容问题</code></pre><h6 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h6><pre><code>map速度比foreach快map会返回一个新数组，不对原数组产生影响,foreach不会产生新数组，map因为返回数组所以可以链式操作，foreach不能</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别&quot;&gt;&lt;a href=&quot;#js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别&quot; class=&quot;headerlink&quot; title=&quot;js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>去重排序</title>
    <link href="http://example.com/2018/03/10/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2018/03/10/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%8E%92%E5%BA%8F/</id>
    <published>2018-03-10T10:38:33.000Z</published>
    <updated>2021-01-12T11:30:03.626Z</updated>
    
    <content type="html"><![CDATA[<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序</span><br><span class="line">let arr &#x3D; [23,46,2,5,767,7,4,3]</span><br><span class="line">    for (let i&#x3D;0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">        for(let j&#x3D;0;j&lt;arr.length-1-i;j++)&#123;</span><br><span class="line">            if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">                let temp&#x3D;arr[j+1]</span><br><span class="line">                arr[j+1]&#x3D;arr[j]</span><br><span class="line">                arr[j]&#x3D;temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(arr)&#x2F;&#x2F;[2, 3, 4, 5, 7, 23, 46, 767]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">插入排序</span><br><span class="line">let arr &#x3D; [23,46,2,5,767,7,4,3]</span><br><span class="line">    for(let i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        for(let j&#x3D;i;j&gt;0&amp;&amp;arr[j]&lt;arr[j-1];j--)&#123;</span><br><span class="line">            let temp &#x3D; arr[j]</span><br><span class="line">            arr[j]&#x3D;arr[j-1]</span><br><span class="line">            arr[j-1]&#x3D;temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(arr)&#x2F;&#x2F;[2, 3, 4, 5, 7, 23, 46, 767]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>函数的length</title>
    <link href="http://example.com/2018/03/05/%E5%87%BD%E6%95%B0%E7%9A%84length/"/>
    <id>http://example.com/2018/03/05/%E5%87%BD%E6%95%B0%E7%9A%84length/</id>
    <published>2018-03-05T12:36:48.000Z</published>
    <updated>2021-01-05T11:29:09.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6中的函数length属性"><a href="#ES6中的函数length属性" class="headerlink" title="ES6中的函数length属性"></a>ES6中的函数length属性</h2><p>ES6中函数的length属性，将返回没有指定默认值的参数个数。也就是说指定了默认值后，length属性将失真。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在es6之前函数的length就是指函数声明形参的个数</span><br><span class="line">function fn1()&#123;&#125; &#x2F;&#x2F;length为0</span><br><span class="line">function fn2(a,b)&#123;&#125; &#x2F;&#x2F;length为1</span><br><span class="line">function fn3(a,b,c) &#x2F;&#x2F;length为3</span><br></pre></td></tr></table></figure><p>但是在ES6之后，就发生了变化，因为ES6更新了一个新特性，让函数可以给形参设置默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function fn1(a,b&#x3D;10)&#123;&#125;</span><br><span class="line">&#x2F;&#x2F;这种写法在ES6之前是不允许的</span><br></pre></td></tr></table></figure><p>有了这一新特性之后，length的解释就要修改成这样：length的值是指函数的第一个具有默认值得形参之前的形参的个数！！！<br>写点代码更好理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fn1(a,b)&#123;&#125; &#x2F;&#x2F;因为a,b 没有默认值，length的值为2！</span><br><span class="line">function fn2(a&#x3D;1,b)&#123;&#125; &#x2F;&#x2F;因为a 为‘第一个具有默认值得形参’，而a的前面没有其他形参了，所以length为1</span><br><span class="line">function fn3(a,b&#x3D;1,c)&#123;&#125; &#x2F;&#x2F;b为‘第一个具有默认值的形参’，前面还有一个a，length为1 。</span><br><span class="line">function fn4(a,b,c&#x3D;1)&#123;&#125; &#x2F;&#x2F;所以length为2 因为‘c为第一个具有默认值的形参’</span><br><span class="line">function fn5(a,b&#x3D;1,c,d&#x3D;2)&#123;&#125; &#x2F;&#x2F;length为1。因为‘b为第一个具有默认值的形参’，它前面只有一个a,并且只算</span><br><span class="line">&#x2F;&#x2F;具有默认值形参前面的形参的个数，后面的不算所以是1个。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意，当函数拥有剩余参数时，比如</span><br><span class="line">function fn1(a,...args)&#123;&#125; &#x2F;&#x2F;length为1，剩余参数也有默认值，默认为空数组。前面有只有一个a，所以length为1</span><br><span class="line">function fn1(...args)&#123;&#125; &#x2F;&#x2F;如果函数形参只有一个默认参数，那么length为0！</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ES6中的函数length属性&quot;&gt;&lt;a href=&quot;#ES6中的函数length属性&quot; class=&quot;headerlink&quot; title=&quot;ES6中的函数length属性&quot;&gt;&lt;/a&gt;ES6中的函数length属性&lt;/h2&gt;&lt;p&gt;ES6中函数的length属性，将返</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>es5ANDes6</title>
    <link href="http://example.com/2018/03/03/es5ANDes6/"/>
    <id>http://example.com/2018/03/03/es5ANDes6/</id>
    <published>2018-03-03T02:45:49.000Z</published>
    <updated>2021-02-23T01:46:43.257Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是ES5"><a href="#什么是ES5" class="headerlink" title="什么是ES5"></a>什么是ES5</h4><pre><code>ECMAScript第五个版本</code></pre><h5 id="1-strict模式"><a href="#1-strict模式" class="headerlink" title="1. strict模式"></a>1. strict模式</h5><pre><code>严格模式，限制一些用法，&#39;use strict&#39;;</code></pre><h5 id="2-Array增加方法"><a href="#2-Array增加方法" class="headerlink" title="2. Array增加方法"></a>2. Array增加方法</h5><pre><code>增加了every、some 、forEach、filter 、indexOf、lastIndexOf、isArray、map、reduce、reduceRight方法还有其他方法 Function.prototype.bind、String.prototype.trim、Date.now</code></pre><h5 id="3-Object方法"><a href="#3-Object方法" class="headerlink" title="3. Object方法"></a>3. Object方法</h5><pre><code>Object.getPrototypeOfObject.createObject.getOwnPropertyNamesObject.definePropertyObject.getOwnPropertyDescriptorObject.definePropertiesObject.keysObject.preventExtensions / Object.isExtensibleObject.seal / Object.isSealedObject.freeze / Object.isFrozen</code></pre><h4 id="什么是ES6"><a href="#什么是ES6" class="headerlink" title="什么是ES6"></a>什么是ES6</h4><pre><code>ECMAScript6版本 ES6特性如下：1.块级作用域 关键字let, 常量const2.对象字面量的属性赋值简写</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let width &#x3D; &quot;100px&quot;;</span><br><span class="line">let height &#x3D; &quot;200px&quot;;</span><br><span class="line">let background &#x3D; &quot;red&quot;;</span><br><span class="line">let style &#x3D; &#123;</span><br><span class="line">    width,</span><br><span class="line">    height,</span><br><span class="line">    background,</span><br><span class="line">    method()&#123;</span><br><span class="line">        console.log(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">style.method();   &#x2F;&#x2F;&quot;hello&quot;</span><br></pre></td></tr></table></figure><pre><code>3.赋值解构</code></pre><figure class="highlight plain"><figcaption><span>singer </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let &#123; first: f, last: l &#125; &#x3D; singer; &#x2F;&#x2F; 相当于 f &#x3D; &quot;Bob&quot;, l &#x3D; &quot;Dylan&quot;</span><br><span class="line">let [all, year, month, day] &#x3D;  &#x2F;^(\d\d\d\d)-(\d\d)-(\d\d)$&#x2F;.exec(&quot;2015-10-25&quot;);</span><br><span class="line">let [x, y] &#x3D; [1, 2, 3]; &#x2F;&#x2F; x &#x3D; 1, y &#x3D; 2&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">    4.函数参数 - 默认值、参数打包、 数组展开（Default 、Rest 、Spread）</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>//Defaultfunction findArtist(name=&#39;lu&#39;, age=&#39;26&#39;) &#123;    ...&#125;//Restfunction f(x, ...y) &#123;// y is an Arrayreturn x * y.length;&#125;f(3, &quot;hello&quot;, true) == 6//Spreadfunction f(x, y, z) &#123;return x + y + z;&#125;// Pass each elem of array as argumentf(...[1,2,3]) == 6</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5.箭头函数 Arrow functions</span><br><span class="line"></span><br><span class="line">(1).简化了代码形式，默认return表达式结果。</span><br><span class="line"></span><br><span class="line">(2).自动绑定语义this，即定义函数时的this。如上面例子中，forEach的匿名函数参数中用到的this。</span><br><span class="line"></span><br><span class="line">6.字符串模板 Template strings</span><br></pre></td></tr></table></figure><pre><code>var name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`// return &quot;Hello Bob, how are you today?&quot;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">7. Iterators（迭代器）+ for..of</span><br><span class="line"></span><br><span class="line">迭代器有个next方法，调用会返回：</span><br><span class="line"></span><br><span class="line">(1).返回迭代对象的一个元素：&#123; done: false, value: elem &#125;</span><br><span class="line"></span><br><span class="line">(2).如果已到迭代对象的末端：&#123; done: true, value: retVal &#125;</span><br></pre></td></tr></table></figure><pre><code>for (var n of [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]) &#123;console.log(n);&#125;// 打印a、b、c```8.Class</code></pre><p>Class，有constructor、extends、super，但本质上是语法糖（对语言的功能并没有影响，但是更方便程序员使用）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Artist &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    perform() &#123;</span><br><span class="line">        return this.name + &quot; performs &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Singer extends Artist &#123;</span><br><span class="line"></span><br><span class="line">    constructor(name, song) &#123;</span><br><span class="line">        super.constructor(name);</span><br><span class="line">        this.song &#x3D; song;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    perform() &#123;</span><br><span class="line">        return super.perform() + &quot;[&quot; + this.song + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">    9.Symbols</span><br><span class="line"></span><br><span class="line">    Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的。</span><br></pre></td></tr></table></figure><pre><code>var key = Symbol(&quot;key&quot;);var key2 = Symbol(&quot;key&quot;);key == key2  //false</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.Promises</span><br><span class="line"></span><br><span class="line">Promises是处理异步操作的对象，使用了 Promise 对象之后可以用一种链式调用的方式来组织代码，让代码更加直观（类似jQuery的deferred 对象）。</span><br></pre></td></tr></table></figure><pre><code>function fakeAjax(url) &#123;return new Promise(function (resolve, reject) &#123;    // setTimeouts are for effect, typically we would handle XHR    if (!url) &#123;    return setTimeout(reject, 1000);    &#125;    return setTimeout(resolve, 1000);&#125;);&#125;// no url, promise rejectedfakeAjax().then(function () &#123;    console.log(&#39;success&#39;);    &#125;,function () &#123;    console.log(&#39;fail&#39;);&#125;);</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;什么是ES5&quot;&gt;&lt;a href=&quot;#什么是ES5&quot; class=&quot;headerlink&quot; title=&quot;什么是ES5&quot;&gt;&lt;/a&gt;什么是ES5&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;ECMAScript第五个版本&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&quot;1-strict模</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>嘛是跨域？</title>
    <link href="http://example.com/2018/03/02/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://example.com/2018/03/02/%E8%B7%A8%E5%9F%9F/</id>
    <published>2018-03-02T12:00:36.000Z</published>
    <updated>2020-12-30T12:47:21.577Z</updated>
    
    <content type="html"><![CDATA[<p>资源所在的服务器地址和资源内发起请求的目标服务器地址不同！（两个服务器是不同的）</p><p>　　这里就要说一下浏览器的同源策略问题（服务器之间是没有同源策略的），如果两个URL的协议/主机(域名，IP地址)/端口（默认是80），都相同的话就是同源。如有一个不一样就会发生跨域问题，就是非同源。注意：同源策略是指针对AJXS请求而言，如果不是Ajxs即便非同源也是能请求的。如果用ajxs发起的请求地址和后端地址不同就会跨域</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;资源所在的服务器地址和资源内发起请求的目标服务器地址不同！（两个服务器是不同的）&lt;/p&gt;
&lt;p&gt;　　这里就要说一下浏览器的同源策略问题（服务器之间是没有同源策略的），如果两个URL的协议/主机(域名，IP地址)/端口（默认是80），都相同的话就是同源。如有一个不一样就会发生</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue、react面试题</title>
    <link href="http://example.com/2018/02/22/vue%E3%80%81react/"/>
    <id>http://example.com/2018/02/22/vue%E3%80%81react/</id>
    <published>2018-02-22T07:17:05.000Z</published>
    <updated>2021-02-23T01:19:21.930Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><h4 id="一-vue的特点是什么？"><a href="#一-vue的特点是什么？" class="headerlink" title="一.vue的特点是什么？"></a>一.vue的特点是什么？</h4><p>1.遵循MVVM模式数据驱动视图<br>2.双向绑定<br>3.摒弃了原始的dom操作<br>3.可以轻松引入Vue插件或其他第三方库开发项目</p><h4 id="二-vue的原理是什么？"><a href="#二-vue的原理是什么？" class="headerlink" title="二.vue的原理是什么？"></a>二.vue的原理是什么？</h4><p>vue2.0采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter,getter,在数据变动时发布消息给订阅者,触发响应的监听回调</p><h4 id="三-computed-和-watch-有什么区别及运用场景"><a href="#三-computed-和-watch-有什么区别及运用场景" class="headerlink" title="三.computed 和 watch 有什么区别及运用场景?"></a>三.computed 和 watch 有什么区别及运用场景?</h4><p>computed 计算属性 : 依赖其它属性值,并且 computed 的值有缓存,只有它依赖的属性值发生改变,下一次获取 computed 的值时才会重新计算 computed 的值。</p><p>watch 侦听器 : 更多的是「观察」的作用,<strong>无缓存性</strong>,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作。</p><p>运用场景：</p><p>当我们需要进行数值计算,并且依赖于其它数据时,应该使用 computed,因为可以利用 computed 的缓存特性,避免每次获取值时,都要重新计算。</p><p>当我们需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),限制我们执行该操作的频率,并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。</p><h4 id="四-Vue-中的-key-到底有什么用？"><a href="#四-Vue-中的-key-到底有什么用？" class="headerlink" title="四.Vue 中的 key 到底有什么用？"></a>四.Vue 中的 key 到底有什么用？</h4><p>key 的特殊属性主要用在 Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。</p><h4 id="五-什么是MVVM？"><a href="#五-什么是MVVM？" class="headerlink" title="五.什么是MVVM？"></a>五.什么是MVVM？</h4><p>MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</p><h4 id="六-mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？"><a href="#六-mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？" class="headerlink" title="六.mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？"></a>六.mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？</h4><p>mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</p><p>区别：vue数据驱动，通过数据来显示视图层而不是节点操作。<br>场景：数据操作比较多的场景，更加便捷</p><h4 id="七-vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#七-vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="七.vuex是什么？怎么使用？哪种功能场景使用它？"></a>七.vuex是什么？怎么使用？哪种功能场景使用它？</h4><p>vuex是管理vue状态的一个库<br>任何组件都可以和store通信<br>它是单一数据源</p><h4 id="八-vuex有哪几种属性？"><a href="#八-vuex有哪几种属性？" class="headerlink" title="八.vuex有哪几种属性？"></a>八.vuex有哪几种属性？</h4><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p><p>·  vuex的State特性<br>A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data<br>B、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新<br>C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</p><p>· vuex的Getter特性<br>A、getters 可以对State进行计算操作，它就是Store的计算属性<br>B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用<br>C、 如果一个状态只在一个组件内使用，是可以不用getters</p><p>·  vuex的Mutation特性<br>Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。</p><h4 id="九-v-show和v-if指令的共同点和不同点"><a href="#九-v-show和v-if指令的共同点和不同点" class="headerlink" title="九. v-show和v-if指令的共同点和不同点"></a>九. v-show和v-if指令的共同点和不同点</h4><p>v-show指令是通过修改元素的display的CSS属性让其显示或者隐藏<br>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果</p><h4 id="十-vue-router有哪几种导航钩子？"><a href="#十-vue-router有哪几种导航钩子？" class="headerlink" title="十.vue-router有哪几种导航钩子？"></a>十.vue-router有哪几种导航钩子？</h4><p>三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。<br>第二种：组件内的钩子；<br>第三种：单独路由独享组件</p><h4 id="十一-什么是vue生命周期"><a href="#十一-什么是vue生命周期" class="headerlink" title="十一.什么是vue生命周期"></a>十一.什么是vue生命周期</h4><p>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p><h4 id="十二-vue生命周期的作用是什么"><a href="#十二-vue生命周期的作用是什么" class="headerlink" title="十二.vue生命周期的作用是什么"></a>十二.vue生命周期的作用是什么</h4><p>它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p><h4 id="十三-第一次页面加载会触发哪几个钩子"><a href="#十三-第一次页面加载会触发哪几个钩子" class="headerlink" title="十三.第一次页面加载会触发哪几个钩子"></a>十三.第一次页面加载会触发哪几个钩子</h4><p>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</p><h4 id="十四-简单描述每个周期具体适合哪些场景"><a href="#十四-简单描述每个周期具体适合哪些场景" class="headerlink" title="十四.简单描述每个周期具体适合哪些场景"></a>十四.简单描述每个周期具体适合哪些场景</h4><p>生命周期钩子的一些使用方法：<br>beforecreate : 可以在这加个loading事件，在加载实例时触发<br>created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用<br>mounted : 挂载元素，获取到DOM节点<br>updated : 如果对数据统一处理，在这里写上相应函数<br>beforeDestroy : 可以做一个确认停止事件的确认框<br>nextTick : 更新数据后立即操作dom</p><h4 id="十五-为什么使用key？"><a href="#十五-为什么使用key？" class="headerlink" title="十五.为什么使用key？"></a>十五.为什么使用key？</h4><p>当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。</p><h4 id="十六-为什么避免-v-if-和-v-for-用在一起"><a href="#十六-为什么避免-v-if-和-v-for-用在一起" class="headerlink" title="十六.为什么避免 v-if 和 v-for 用在一起"></a>十六.为什么避免 v-if 和 v-for 用在一起</h4><p>当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。</p><h4 id="十七-VNode是什么？虚拟-DOM是什么？"><a href="#十七-VNode是什么？虚拟-DOM是什么？" class="headerlink" title="十七.VNode是什么？虚拟 DOM是什么？"></a>十七.VNode是什么？虚拟 DOM是什么？</h4><p>Vue在 页面上渲染的节点，及其子节点称为“虚拟节点 (Virtual Node)”，简写为“VNode”。“虚拟 DOM”是由 Vue 组件树建立起来的整个 VNode 树的称呼。</p><h4 id="十八-active-class是哪个组件的属性？嵌套路由怎么定义？"><a href="#十八-active-class是哪个组件的属性？嵌套路由怎么定义？" class="headerlink" title="十八.active-class是哪个组件的属性？嵌套路由怎么定义？"></a>十八.active-class是哪个组件的属性？嵌套路由怎么定义？</h4><p>vue-router模块的router-link组件。<br>嵌套路由顾名思义就是路由的多层嵌套。 一级路由里面使用children数组配置子路由，就是嵌套路由。</p><h4 id="十九-怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"><a href="#十九-怎么定义vue-router的动态路由？怎么获取传过来的动态参数？" class="headerlink" title="十九.怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"></a>十九.怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</h4><p>在router目录下的index.js文件中，对path属性加上/:id。  使用router对象的params.id</p><h4 id="二十-请说出vue-cli项目中src目录每个文件夹和文件的用法？"><a href="#二十-请说出vue-cli项目中src目录每个文件夹和文件的用法？" class="headerlink" title="二十.请说出vue.cli项目中src目录每个文件夹和文件的用法？"></a>二十.请说出vue.cli项目中src目录每个文件夹和文件的用法？</h4><p>assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件</p><h4 id="二十一-指令v-el的作用是什么"><a href="#二十一-指令v-el的作用是什么" class="headerlink" title="二十一.指令v-el的作用是什么?"></a>二十一.指令v-el的作用是什么?</h4><p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例</p><h4 id="二十二-请列举出3个Vue中常用的生命周期钩子函数"><a href="#二十二-请列举出3个Vue中常用的生命周期钩子函数" class="headerlink" title="二十二.请列举出3个Vue中常用的生命周期钩子函数?"></a>二十二.请列举出3个Vue中常用的生命周期钩子函数?</h4><p>created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见</p><p>mounted: el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</p><p>activated::keep-alive组件激活时调用</p><h4 id="二十三-怎样理解单向数据流"><a href="#二十三-怎样理解单向数据流" class="headerlink" title="二十三.怎样理解单向数据流"></a>二十三.怎样理解单向数据流</h4><p>这个概念出现在组件通信。父组件是通过 prop 把数据传递到子组件的，但是这个 prop 只能由父组件修改，子组件不能修改，否则会报错。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p><h4 id="二十四-各个生命周期的作用"><a href="#二十四-各个生命周期的作用" class="headerlink" title="二十四.各个生命周期的作用"></a>二十四.各个生命周期的作用</h4><p>beforeCreate 组件实例被创建之初，组件的属性生效之前<br>created 组件实例已经完全出创建，属性也绑定，但是真实 DOM 没有生成，$el 还不可以用<br>beforeMount 在挂载开始之前被调用，相关的render函数首次被调用<br>mounted el 被新创建的 vm.$el 替换，并挂载实例上去调动该钩子<br>beforeUpdate 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前<br>update 组件数据更新之后<br>activated keep-alive 专属，组件被激活时调用<br>deactivated keep-alive 专属，组件被销毁时调用<br>beforeDestory 组件销毁前调用<br>destroyed 组件销毁后调用<br>#Vue 的父组件和子</p><h4 id="二十五-在哪个生命周期内调用异步请求？"><a href="#二十五-在哪个生命周期内调用异步请求？" class="headerlink" title="二十五.在哪个生命周期内调用异步请求？"></a>二十五.在哪个生命周期内调用异步请求？</h4><p>在 钩子函数 created 、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务器点的数据返回进行赋值</p><h4 id="二十六-在什么阶段才能访问操作-DOM"><a href="#二十六-在什么阶段才能访问操作-DOM" class="headerlink" title="二十六.在什么阶段才能访问操作 DOM"></a>二十六.在什么阶段才能访问操作 DOM</h4><p>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以可以在 mounted 中访问到 DOM</p><h4 id="二十七-Proxy-与-Object-defineProperty-优劣对比"><a href="#二十七-Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="二十七.Proxy 与 Object.defineProperty 优劣对比"></a>二十七.Proxy 与 Object.defineProperty 优劣对比</h4><p>Proxy 可以直接监听对象而非属性；<br>Proxy 可以直接监听数组的变化；<br>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；<br>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；<br>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</p><h4 id="二十八-使你用过-Vuex-吗？"><a href="#二十八-使你用过-Vuex-吗？" class="headerlink" title="二十八.使你用过 Vuex 吗？"></a>二十八.使你用过 Vuex 吗？</h4><p>主要包含一下几种模块：<br>#State<br>定义了应用状态的数据结构，可以在这里设置默认的初始化状态。<br>#Getter<br>允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性中。<br>#Mutation<br>是唯一更改 store 中状态的方法，且必须是同步函数。<br>#Action<br>用于提交 mutation，而不是直接变更状态，可以任何异步操作。<br>#Module<br>允许将单一的 Store 拆分为多个 store 且同时保持在单一的状态数中</p><h4 id="二十九-使用过-Vue-SSR-吗？-说说-SSR"><a href="#二十九-使用过-Vue-SSR-吗？-说说-SSR" class="headerlink" title="二十九.使用过 Vue SSR 吗？ 说说 SSR"></a>二十九.使用过 Vue SSR 吗？ 说说 SSR</h4><p>SSR 将 Vue 在客户端将标签渲染成HTML 片段的工作放到了服务端完成，服务端形成的 HTML 片段直接返回给客户端这个过程，叫做服务端渲染</p><h4 id="三十-计算属性和methods的区别？为什么要用计算属性而不用methods？"><a href="#三十-计算属性和methods的区别？为什么要用计算属性而不用methods？" class="headerlink" title="三十.计算属性和methods的区别？为什么要用计算属性而不用methods？"></a>三十.计算属性和methods的区别？为什么要用计算属性而不用methods？</h4><p>它两的执行结果是一样的。计算属性 是只有它的依赖发生变化的时候它会自动的进行计算求值，如果依赖没有发生变化，那么每次访问的时候计算属性都会立刻返回之前的执行结果，而事件函数需要手动调用，并且调用一次触发一次比较粗暴一点，每当重新触发渲染时，调用方法总是再次执行函数。</p><h4 id="三十一-vue-router-的原理是什么？"><a href="#三十一-vue-router-的原理是什么？" class="headerlink" title="三十一.vue-router 的原理是什么？"></a>三十一.vue-router 的原理是什么？</h4><p>vue-router是什么：他可以让单页面应用拥有了多页面应用的效果，一个url对应一个页面。<br>它主要是通过h5新增的history和hash两种模式来实现的<br>hash —— 即地址栏 URL 中的 # 符号。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。每次hash值得变化，会触发hashchange这个时间，通过这个时间我就可以知道hash值发生了哪些变化。然后我们就可以监听hashchange来实现更新页面部分内容的操作。<br>history —— 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。<br>因此可以说，hash 模式和 history 模式都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由.</p><h4 id="三十二-插槽的作用："><a href="#三十二-插槽的作用：" class="headerlink" title="三十二.插槽的作用："></a>三十二.插槽的作用：</h4><p>为了让组件更加具有扩展性。抽取共性，保留不同为插槽，让其他组件可以传递自己想展示的标签到预留插槽。它包含具名插槽，匿名插槽、还有作用域插槽。</p><h4 id="三十三-keep-alive的作用？"><a href="#三十三-keep-alive的作用？" class="headerlink" title="三十三.keep-alive的作用？"></a>三十三.keep-alive的作用？</h4><p>缓存组件的状态，在组件还原的时候能够把状态还原到组件上。然后它有3个属性，分别是：include(包括)、exclude(不包括)、max(可缓存的最大组件实例数量)<br>利用keep-alive组件把想要缓存的组件包一下，并且给被缓存的组件添加name属性，在include属性里面写上我们要缓存的组件name</p><h4 id="三十四-vuex与全局对象的区别？"><a href="#三十四-vuex与全局对象的区别？" class="headerlink" title="三十四.vuex与全局对象的区别？"></a>三十四.vuex与全局对象的区别？</h4><p>Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会得到高效更新。<br>不能直接改变store中的状态，改变store中的状态的唯一途径就是显示地提交(commit)mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p><h4 id="三十五-为什么组件里的data是个函数？"><a href="#三十五-为什么组件里的data是个函数？" class="headerlink" title="三十五.为什么组件里的data是个函数？"></a>三十五.为什么组件里的data是个函数？</h4><p>一个组件被复用多次的话，也就会创建多个实例。本质上， 这些实例都是同一个构造函数<br>如果data是对象的话，对象属于引用类型，会影响到所有的实例<br>所以为了保证组件不同的实例之间data不冲突，data必须是个函数</p><h4 id="三十六-vue2-x和vue3-x渲染器的diff算法有什么区别？"><a href="#三十六-vue2-x和vue3-x渲染器的diff算法有什么区别？" class="headerlink" title="三十六.vue2.x和vue3.x渲染器的diff算法有什么区别？"></a>三十六.vue2.x和vue3.x渲染器的diff算法有什么区别？</h4><p>Vue3.x借鉴了 ivi算法和 inferno算法<br>Vue2的核?Diff算法采?了双端?较的算法，同时从新旧children的两端开始进??较，借助key值找到可复?的节点，再进?相关操作<br>在创建VNode时就确定其类型，以及在mount/patch的过程中采?位运算来判断?个VNode的类型，在这个基础之上再配合核?的Diff算法，使得性能上较Vue2.x有了提升</p><h4 id="三十七-那你知道Vue3-x响应式数据原理吗？"><a href="#三十七-那你知道Vue3-x响应式数据原理吗？" class="headerlink" title="三十七.那你知道Vue3.x响应式数据原理吗？"></a>三十七.那你知道Vue3.x响应式数据原理吗？</h4><p>Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。<br>Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？<br>答：判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。<br>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？？<br>答：我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p><h4 id="三十八-nextTick知道吗，实现原理是什么？"><a href="#三十八-nextTick知道吗，实现原理是什么？" class="headerlink" title="三十八.nextTick知道吗，实现原理是什么？"></a>三十八.nextTick知道吗，实现原理是什么？</h4><p>在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用<br>PromiseMutationObserversetImmediate如果以上都不行则采用setTimeout<br>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p><h4 id="三十九-说一下Vue的生命周期"><a href="#三十九-说一下Vue的生命周期" class="headerlink" title="三十九.说一下Vue的生命周期"></a>三十九.说一下Vue的生命周期</h4><p>beforeCreate是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。<br>created在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。<br>beforeMount发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。<br>mounted在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。<br>beforeUpdate发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。<br>updated发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。<br>beforeDestroy发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。<br>destroyed发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p><h4 id="四十-说一下v-model的原理"><a href="#四十-说一下v-model的原理" class="headerlink" title="四十.说一下v-model的原理?"></a>四十.说一下v-model的原理?</h4><p>v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。</p><h4 id="四十一-Vue事件绑定原理说一下"><a href="#四十一-Vue事件绑定原理说一下" class="headerlink" title="四十一.Vue事件绑定原理说一下?"></a>四十一.Vue事件绑定原理说一下?</h4><p>原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。</p><h4 id="四十一-Vue中组件生命周期调用顺序说一下"><a href="#四十一-Vue中组件生命周期调用顺序说一下" class="headerlink" title="四十一.Vue中组件生命周期调用顺序说一下?"></a>四十一.Vue中组件生命周期调用顺序说一下?</h4><p>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。<br>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。<br>加载渲染过程<br>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount- &gt;子mounted-&gt;父mounted<br>子组件更新过程<br>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated<br>父组件更新过程<br>父 beforeUpdate -&gt; 父 updated<br>销毁过程<br>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p><h4 id="四十二-Vue2-x组件通信有哪些方式？"><a href="#四十二-Vue2-x组件通信有哪些方式？" class="headerlink" title="四十二.Vue2.x组件通信有哪些方式？"></a>四十二.Vue2.x组件通信有哪些方式？</h4><p>父子组件通信<br>父-&gt;子props，子-&gt;父 $on、$emit<br>获取父子组件实例 $parent、$children<br>Ref 获取实例的方式调用组件的属性或者方法<br>Provide、inject 官方不推荐使用，但是写组件库时很常用<br>兄弟组件通信<br>Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue<br>Vuex<br>跨级组件通信<br>Vuex<br>$attrs、$listeners<br>Provide、inject</p><h4 id="四十三-你都做过哪些Vue的性能优化？"><a href="#四十三-你都做过哪些Vue的性能优化？" class="headerlink" title="四十三.你都做过哪些Vue的性能优化？"></a>四十三.你都做过哪些Vue的性能优化？</h4><p>编码阶段</p><p>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcherv-if和v-for不能连用如果需要使用v-for给每项元素绑定事件时使用事件代理SPA 页面采用keep-alive缓存组件在更多的情况下，使用v-if替代v-showkey保证唯一使用路由懒加载、异步组件防抖、节流第三方模块按需导入长列表滚动到可视区域动态加载图片懒加载<br>SEO优化</p><p>预渲染服务端渲染SSR<br>打包优化</p><p>压缩代码Tree Shaking/Scope Hoisting使用cdn加载第三方模块多线程打包happypacksplitChunks抽离公共文件sourceMap优化<br>用户体验</p><p>骨架屏 PWA</p><h4 id="四十四-vue中的修饰符"><a href="#四十四-vue中的修饰符" class="headerlink" title="四十四.vue中的修饰符?"></a>四十四.vue中的修饰符?</h4><p>.stop 阻止事件冒泡<br>.prevent 清除默认行为<br>.once 只触发一次回调<br>.lazy 取代input 监听change 事件<br>.number 输入字符串转为有效的数字<br>.trim 输入首尾空格过滤</p><h4 id="四十五-vue中的指令有哪些？"><a href="#四十五-vue中的指令有哪些？" class="headerlink" title="四十五.vue中的指令有哪些？"></a>四十五.vue中的指令有哪些？</h4><p>v-if、v-else、v-for、v-bind、v-model、v-onv-text</p><h4 id="四十六-插槽之间是怎么传值的？"><a href="#四十六-插槽之间是怎么传值的？" class="headerlink" title="四十六.插槽之间是怎么传值的？"></a>四十六.插槽之间是怎么传值的？</h4><p>可以用作用域插槽进行传值。子组件的slot标签中动态绑定属性，父组件中给template标签绑定(v-slot)值，子组件抛出来的接口，可以通过这个值访问到子组件的数据</p><h4 id="四十七-vue中的内置组件有哪些？"><a href="#四十七-vue中的内置组件有哪些？" class="headerlink" title="四十七.vue中的内置组件有哪些？"></a>四十七.vue中的内置组件有哪些？</h4><p>component、<br>transition、<br>transition-group、<br>keep-alive、<br>slot</p><h4 id="四十八-vue中的transfrom组件是什么？"><a href="#四十八-vue中的transfrom组件是什么？" class="headerlink" title="四十八.vue中的transfrom组件是什么？"></a>四十八.vue中的transfrom组件是什么？</h4><p>使用transfrom可以完成任何元素进入/离开的过渡效果。<br>它的用法是：首先在这个组件内设置一个那么属性，然后再css中用v-enter、v-enter-active、v-leave、v-leave-active<br>来实现整体的效果。</p><h4 id="四十九-computed-是什么？实现原理？"><a href="#四十九-computed-是什么？实现原理？" class="headerlink" title="四十九.computed 是什么？实现原理？"></a>四十九.computed 是什么？实现原理？</h4><p>是：计算属性。基于当前的数据进行简单的加工返回新的数据，当计算属性所依赖的数据发生变化时，它会自动进行计算。<br>写起来像函数，本质是属性。</p><p>对大量计算有优化效果。仅仅在依赖的数据发生变化时，才执行。<br>computed 内部实现了一个惰性的 watcher，在实例化的时候不会去求值，其内部通过 dirty 属性标记计算属性是否需要重新求值。当 computed 依赖的任意状态发生改变，都会通知这个惰性的 watcher，让它把 dirty 属性设置为 true，所以，当再次读取这个计算属性的时候，就会重新去求值。<br>惰性的watcher 计算属性在创建时不会去求值的，是在使用时去求值。</p><p>computed 本质是一个惰性求值的观察者。</p><p>computed 内部实现了一个惰性的 watcher,也就是 computed watcher,computed watcher 不会立刻求值,同时持有一个 dep 实例。</p><p>其内部通过 this.dirty 属性标记计算属性是否需要重新求值。</p><p>当 computed 的依赖状态发生改变时,就会通知这个惰性的 watcher,</p><p>computed watcher 通过 this.dep.subs.length 判断有没有订阅者,</p><p>有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 (<strong>Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染，本质上是一种优化。</strong>)<br>没有的话,仅仅把 this.dirty = true。 (<strong>当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性。</strong>)</p><h5 id="五十-为什么在-Vue3-0-采用了-Proxy-抛弃了-Object-defineProperty？"><a href="#五十-为什么在-Vue3-0-采用了-Proxy-抛弃了-Object-defineProperty？" class="headerlink" title="五十.为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？"></a>五十.为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？</h5><p>Object.defineProperty 本身有一定的监控到数组下标变化的能力,但是在 Vue 中,从性能/体验的性价比考虑,尤大大就弃用了这个特性(<a href="https://link.zhihu.com/?target=https://segmentfault.com/a/1190000015783546">Vue 为什么不能检测数组变动</a> )。为了解决这个问题,经过 vue 内部处理后可以使用以下几种方法来监听数组</p><h3 id="react面试题"><a href="#react面试题" class="headerlink" title="react面试题"></a>react面试题</h3><h4 id="什么是react？"><a href="#什么是react？" class="headerlink" title="什么是react？"></a>什么是react？</h4><p>它是facebook在2011年发布的一个框架<br>react和vue大体是差不多一个开发框架，支出组件并且可以引入第三方UI库<br>相对vue来说它比较更原生一点，vue相对来说更容易上手。</p><h4 id="react有什么特点？"><a href="#react有什么特点？" class="headerlink" title="react有什么特点？"></a>react有什么特点？</h4><p>它使用虚拟dom而不是真正的dom<br>它可以用服务器端渲染<br>它遵循单向数据流或者数据绑定</p><h4 id="vue和react的区别？"><a href="#vue和react的区别？" class="headerlink" title="vue和react的区别？"></a>vue和react的区别？</h4><p>react严格上针对的是mvc模式的view层，vue则是mvvm模式。<br>操作dom的方式不同，vue使用的是指令操作dom，react是通过js进行操作。<br>数据绑定不同，vue实现的是双向绑定，react的数据流动是单向的。<br>react中state是不能直接改变的，需要使用setState改变。vue中的state不是必须的，数据主要是由data属性在vue对象中管理的。</p><h4 id="列出React的一些主要优点？"><a href="#列出React的一些主要优点？" class="headerlink" title="列出React的一些主要优点？"></a>列出React的一些主要优点？</h4><p>它提高了应用的性能<br>可以方便地在客户端和服务器端使用<br>由于 JSX，代码的可读性很好<br>React 很容易与 Meteor，Angular 等其他框架集成<br>使用React，编写UI测试用例变得非常容易</p><h4 id="React有哪些限制？"><a href="#React有哪些限制？" class="headerlink" title="React有哪些限制？"></a>React有哪些限制？</h4><p>React 只是一个库，而不是一个完整的框架<br>它的库非常庞大，需要时间来理解<br>新手程序员可能很难理解<br>编码变得复杂，因为它使用内联模板和 JSX</p><h4 id="什么是虚拟DOM？"><a href="#什么是虚拟DOM？" class="headerlink" title="什么是虚拟DOM？"></a>什么是虚拟DOM？</h4><p>虚拟 DOM (VDOM)是真实 DOM 在内存中的表示。UI 的表示形式保存在内存中，并与实际的 DOM 同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。</p><h4 id="什么是JSX？"><a href="#什么是JSX？" class="headerlink" title="什么是JSX？"></a>什么是JSX？</h4><p>JSX 是J avaScript XML 的简写。是 React 使用的一种文件，它利用 JavaScript 的表现力和类似 HTML 的模板语法。这使得 HTML 文件非常容易理解。此文件能使应用非常可靠，并能够提高其性能。下面是JSX的一个例子：</p><h4 id="为什么不直接更新-state-呢"><a href="#为什么不直接更新-state-呢" class="headerlink" title="为什么不直接更新 state 呢 ?"></a>为什么不直接更新 state 呢 ?</h4><p>如果试图直接更新 state ，则不会重新渲染组件<br>要使用setState()方法来更新 state。它调度对组件state对象的更新。当state改变时，组件通过重新渲染来响应：</p><h4 id="使用-React-Hooks-好处是啥？"><a href="#使用-React-Hooks-好处是啥？" class="headerlink" title="使用 React Hooks 好处是啥？"></a>使用 React Hooks 好处是啥？</h4><p>首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 props 的负担。Hooks 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。</p><p>Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。</p><h4 id="什么是-React-Hooks？"><a href="#什么是-React-Hooks？" class="headerlink" title="什么是 React Hooks？"></a>什么是 React Hooks？</h4><p>Hooks是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用state和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。</p><h4 id="什么是-React-Context"><a href="#什么是-React-Context" class="headerlink" title="什么是 React Context?"></a>什么是 React Context?</h4><p>Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。</p><h4 id="什么是纯函数？"><a href="#什么是纯函数？" class="headerlink" title="什么是纯函数？"></a>什么是纯函数？</h4><p>纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。</p><h4 id="你了解-Virtual-DOM-吗？解释一下它的工作原理？"><a href="#你了解-Virtual-DOM-吗？解释一下它的工作原理？" class="headerlink" title="你了解 Virtual DOM 吗？解释一下它的工作原理？"></a>你了解 Virtual DOM 吗？解释一下它的工作原理？</h4><p>Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。<br>Virtual DOM 工作过程有三个简单的步骤：<br>每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。<br>然后计算之前 DOM 表示与新表示的之间的差异。<br>完成计算后，将只用实际更改的内容更新 real DOM</p><h4 id="为什么浏览器无法读取JSX？"><a href="#为什么浏览器无法读取JSX？" class="headerlink" title="为什么浏览器无法读取JSX？"></a>为什么浏览器无法读取JSX？</h4><p>浏览器只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX。所以为了使浏览器能够读取 JSX，首先，需要用像 Babel 这样的 JSX 转换器将 JSX 文件转换为 JavaScript 对象，然后再将其传给浏览器。</p><h4 id="与-ES5-相比，React-的-ES6-语法有何不同？"><a href="#与-ES5-相比，React-的-ES6-语法有何不同？" class="headerlink" title="与 ES5 相比，React 的 ES6 语法有何不同？"></a>与 ES5 相比，React 的 ES6 语法有何不同？</h4><h4 id="你理解“在React中，一切都是组件”这句话？"><a href="#你理解“在React中，一切都是组件”这句话？" class="headerlink" title="你理解“在React中，一切都是组件”这句话？"></a>你理解“在React中，一切都是组件”这句话？</h4><p>组件是 React 应用 UI 的构建块。这些组件将整个 UI 分成小的独立并可重用的部分。每个组件彼此独立，而不会影响 UI 的其余部分。</p><h4 id="解释-React-中-render-的目的？"><a href="#解释-React-中-render-的目的？" class="headerlink" title="解释 React 中 render() 的目的？"></a>解释 React 中 render() 的目的？</h4><p>每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，例如 <form>、<group>、<div> 等。此函数必须保持纯净，即必须每次调用时都返回相同的结果。</p><h4 id="什么是-Props"><a href="#什么是-Props" class="headerlink" title="什么是 Props?"></a>什么是 Props?</h4><p>Props 是 React 中属性的简写。它们是只读组件，必须保持纯，即不可变。它们总是在整个应用中从父组件传递到子组件。子组件永远不能将 prop 送回父组件。这有助于维护单向数据流，通常用于呈现动态生成的数据。</p><h4 id="React中的状态是什么？它是如何使用的？"><a href="#React中的状态是什么？它是如何使用的？" class="headerlink" title="React中的状态是什么？它是如何使用的？"></a>React中的状态是什么？它是如何使用的？</h4><p>状态是 React 组件的核心，是数据的来源，必须尽可能简单。基本上状态是确定组件呈现和行为的对象。与props 不同，它们是可变的，并创建动态和交互式组件。可以通过 this.state() 访问它们</p><h4 id="如何更新组件的状态？"><a href="#如何更新组件的状态？" class="headerlink" title="如何更新组件的状态？"></a>如何更新组件的状态？</h4><p>可以用 this.setState()更新组件的状态。</p><h4 id="详细解释-React-组件的生命周期方法。"><a href="#详细解释-React-组件的生命周期方法。" class="headerlink" title="详细解释 React 组件的生命周期方法。"></a>详细解释 React 组件的生命周期方法。</h4><p>componentWillMount**()** – 在渲染之前执行，在客户端和服务器端都会执行。<br>componentDidMount**()** – 仅在第一次渲染后在客户端执行。<br>componentWillReceiveProps**()** – 当从父类接收到 props 并且在调用另一个渲染器之前调用。<br>shouldComponentUpdate**()** – 根据特定条件返回 true 或 false。如果你希望更新组件，请返回true 否则返回 false。默认情况下，它返回 false。<br>componentWillUpdate**()** – 在 DOM 中进行渲染之前调用。<br>componentDidUpdate**()** – 在渲染发生后立即调用。<br>componentWillUnmount**()** – 从 DOM 卸载组件后调用。用于清理内存空间。</p><h4 id="React中的合成事件是什么？"><a href="#React中的合成事件是什么？" class="headerlink" title="React中的合成事件是什么？"></a>React中的合成事件是什么？</h4><p>合成事件是围绕浏览器原生事件充当跨浏览器包装器的对象。它们将不同浏览器的行为合并为一个 API。这样做是为了确保事件在不同浏览器中显示一致的属性。</p><h4 id="你对-React-的-refs-有什么了解？"><a href="#你对-React-的-refs-有什么了解？" class="headerlink" title="你对 React 的 refs 有什么了解？"></a>你对 React 的 refs 有什么了解？</h4><p>Refs 是 React 中引用的简写。它是一个有助于存储对特定的 React 元素或组件的引用的属性，它将由组件渲染配置函数返回。用于对 render() 返回的特定元素或组件的引用。当需要进行 DOM 测量或向组件添加方法时，它们会派上用场。</p><h4 id="什么是高阶组件（HOC）？"><a href="#什么是高阶组件（HOC）？" class="headerlink" title="什么是高阶组件（HOC）？"></a>什么是高阶组件（HOC）？</h4><p>高阶组件是重用组件逻辑的高级方法，是一种源于 React 的组件模式。 HOC 是自定义组件，在它之内包含另一个组件。它们可以接受子组件提供的任何动态，但不会修改或复制其输入组件中的任何行为。你可以认为 HOC 是“纯（Pure）”组件。</p><h4 id="你能用HOC做什么？"><a href="#你能用HOC做什么？" class="headerlink" title="你能用HOC做什么？"></a>你能用HOC做什么？</h4><p>代码重用，逻辑和引导抽象<br>渲染劫持<br>状态抽象和控制<br>Props 控制</p><h4 id="什么是纯组件？"><a href="#什么是纯组件？" class="headerlink" title="什么是纯组件？"></a>什么是纯组件？</h4><p>纯（Pure） 组件是可以编写的最简单、最快的组件。它们可以替换任何只有 render() 的组件。这些组件增强了代码的简单性和应用的性能。</p><h4 id="React-中-key-的重要性是什么？"><a href="#React-中-key-的重要性是什么？" class="headerlink" title="React 中 key 的重要性是什么？"></a>React 中 key 的重要性是什么？</h4><p>key 用于识别唯一的 Virtual DOM 元素及其驱动 UI 的相应数据。它们通过回收 DOM 中当前所有的元素来帮助 React 优化渲染。这些 key 必须是唯一的数字或字符串，React 只是重新排序元素而不是重新渲染它们。这可以提高应用程序的性能。</p><h4 id="MVC框架的主要问题是什么？"><a href="#MVC框架的主要问题是什么？" class="headerlink" title="MVC框架的主要问题是什么？"></a>MVC框架的主要问题是什么？</h4><p>对 DOM 操作的代价非常高<br>程序运行缓慢且效率低下<br>内存浪费严重<br>由于循环依赖性，组件模型需要围绕 models 和 views 进行创建</p><h4 id="解释一下-Flux？"><a href="#解释一下-Flux？" class="headerlink" title="解释一下 Flux？"></a>解释一下 Flux？</h4><p>Flux 是一种强制单向数据流的架构模式。它控制派生数据，并使用具有所有数据权限的中心 store 实现多个组件之间的通信。整个应用中的数据更新必须只能在此处进行。 Flux 为应用提供稳定性并减少运行时的错误。</p><h4 id="什么是Redux？"><a href="#什么是Redux？" class="headerlink" title="什么是Redux？"></a>什么是Redux？</h4><p>Redux 是当今最热门的前端开发库之一。它是 JavaScript 程序的可预测状态容器，用于整个应用的状态管理。使用 Redux 开发的应用易于测试，可以在不同环境中运行，并显示一致的行为。</p><h4 id="Redux遵循的三个原则是什么？"><a href="#Redux遵循的三个原则是什么？" class="headerlink" title="Redux遵循的三个原则是什么？"></a>Redux遵循的三个原则是什么？</h4><p>单一数据源<br>使用纯函数进行修改<br>状态是只读的</p><h4 id="你对“单一事实来源”有什么理解？"><a href="#你对“单一事实来源”有什么理解？" class="headerlink" title="你对“单一事实来源”有什么理解？"></a>你对“单一事实来源”有什么理解？</h4><p>Redux 使用 “Store” 将程序的整个状态存储在同一个地方。因此所有组件的状态都存储在 Store 中，并且它们从 Store 本身接收更新。单一状态树可以更容易地跟踪随时间的变化，并调试或检查程序。</p><h4 id="列出-Redux-的组件。"><a href="#列出-Redux-的组件。" class="headerlink" title="列出 Redux 的组件。"></a>列出 Redux 的组件。</h4><p>Action – 这是一个用来描述发生了什么事情的对象。<br>Reducer – 这是一个确定状态将如何变化的地方。<br>Store – 整个程序的状态/对象树保存在Store中。<br>View – 只显示 Store 提供的数据。</p><h4 id="redux中间件？"><a href="#redux中间件？" class="headerlink" title="redux中间件？"></a>redux中间件？</h4><p>edux-logger：提供日志输出<br>redux-thunk：处理异步操作<br>redux-promise：处理异步操作，actionCreator的返回值是promise</p><h4 id="如何在-Redux-中定义-Action？"><a href="#如何在-Redux-中定义-Action？" class="headerlink" title="如何在 Redux 中定义 Action？"></a>如何在 Redux 中定义 Action？</h4><p>React 中的 Action 必须具有 type 属性，该属性指示正在执行的 ACTION 的类型。必须将它们定义为字符串常量，并且还可以向其添加更多的属性。在 Redux 中，action 被名为 Action Creators 的函数所创建。以下是 Action 和Action Creator 的示例：</p><h4 id="解释-Reducer-的作用？"><a href="#解释-Reducer-的作用？" class="headerlink" title="解释 Reducer 的作用？"></a>解释 Reducer 的作用？</h4><p>Reducers 是纯函数，它规定应用程序的状态怎样因响应 ACTION 而改变。Reducers 通过接受先前的状态和 action 来工作，然后它返回一个新的状态。它根据操作的类型确定需要执行哪种更新，然后返回新的值。如果不需要完成任务，它会返回原来的状态。</p><h4 id="Store-在-Redux-中的意义是什么？"><a href="#Store-在-Redux-中的意义是什么？" class="headerlink" title="Store 在 Redux 中的意义是什么？"></a>Store 在 Redux 中的意义是什么？</h4><p>Store 是一个 JavaScript 对象，它可以保存程序的状态，并提供一些方法来访问状态、调度操作和注册侦听器。应用程序的整个状态/对象树保存在单一存储中。因此，Redux 非常简单且是可预测的。我们可以将中间件传递到 store 来处理数据，并记录改变存储状态的各种操作。所有操作都通过 reducer 返回一个新状态。</p><h4 id="什么是React-路由？"><a href="#什么是React-路由？" class="headerlink" title="什么是React 路由？"></a>什么是React 路由？</h4><p>React 路由是一个构建在 React 之上的强大的路由库，它有助于向应用程序添加新的屏幕和流。这使 URL 与网页上显示的数据保持同步。它负责维护标准化的结构和行为，并用于开发单页 Web 应用。 React 路由有一个简单的API。</p><h4 id="为什么React-Router-v4中使用-switch-关键字-？"><a href="#为什么React-Router-v4中使用-switch-关键字-？" class="headerlink" title="为什么React Router v4中使用 switch 关键字 ？"></a>为什么React Router v4中使用 switch 关键字 ？</h4><p>虽然 <div> ** 用于封装 Router 中的多个路由，当你想要仅显示要在多个定义的路线中呈现的单个路线时，可以使用 “switch” 关键字。使用时，<switch>** 标记会按顺序将已定义的 URL 与已定义的路由进行匹配。找到第一个匹配项后，它将渲染指定的路径。从而绕过其它路线。</p><h4 id="为什么需要-React-中的路由？"><a href="#为什么需要-React-中的路由？" class="headerlink" title="为什么需要 React 中的路由？"></a>为什么需要 React 中的路由？</h4><p>Router 用于定义多个路由，当用户定义特定的 URL 时，如果此 URL 与 Router 内定义的任何 “路由” 的路径匹配，则用户将重定向到该特定路由。所以基本上我们需要在自己的应用中添加一个 Router 库，允许创建多个路由，每个路由都会向我们提供一个独特的视图</p><h4 id="react性能优化的方案？"><a href="#react性能优化的方案？" class="headerlink" title="react性能优化的方案？"></a>react性能优化的方案？</h4><p>重写shouldComponentUpdate来避免不必要的dom操作。<br>使用 production 版本的react.js。<br>使用key来帮助React识别列表中所有子组件的最小变化。</p><h4 id="介绍一下webpack？"><a href="#介绍一下webpack？" class="headerlink" title="介绍一下webpack？"></a>介绍一下webpack？</h4><p>webpack是一个前端模块化打包工具，主要由入口，出口，loader，plugins四个部分。前端的打包工具还有一个gulp，不过gulp侧重于前端开发的过程，而webpack侧重于模块，例如他会将css文件看作一个模块，通过css-loader将css打包成符合css的静态资源。</p><h4 id="react生命周期中，最适合与服务端进行数据交互的是哪个函数？"><a href="#react生命周期中，最适合与服务端进行数据交互的是哪个函数？" class="headerlink" title="react生命周期中，最适合与服务端进行数据交互的是哪个函数？"></a>react生命周期中，最适合与服务端进行数据交互的是哪个函数？</h4><p>componentDidMount：在这个阶段，实例和dom已经挂载完成，可以进行相关的dom操作。</p><h4 id="shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）"><a href="#shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）" class="headerlink" title="shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）"></a>shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）</h4><p>询问组件是否需要更新的一个钩子函数，判断数据是否需要重新渲染，返回一个布尔值。默认的返回值是true，需要重新render()。若如果返回值是false则不触发渲染,利用这个生命周期函数可以强制关闭不需要更新的子组件来提升渲染性能。</p><p>这个方法用来判断是否需要调用 render 方法重新描绘 dom。<br>因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</p><h4 id="指出-组件-生命周期方法的不同？"><a href="#指出-组件-生命周期方法的不同？" class="headerlink" title="指出(组件)生命周期方法的不同？"></a>指出(组件)生命周期方法的不同？</h4><p>componentWillMount – 多用于根组件中的应用程序配置<br>componentDidMount – 在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据；如果需要设置事件监听，也可以在这完成<br>componentWillReceiveProps – 这个周期函数作用于特定的 prop 改变导致的 state 转换<br>shouldComponentUpdate – 如果你担心组件过度渲染，shouldComponentUpdate 是一个改善性能的地方，因为如果组件接收了新的 prop， 它可以阻止(组件)重新渲染。shouldComponentUpdate 应该返回一个布尔值来决定组件是否要重新渲染<br>componentWillUpdate – 很少使用。它可以用于代替组件的 componentWillReceiveProps 和 shouldComponentUpdate(但不能访问之前的 props)<br>componentDidUpdate – 常用于更新 DOM，响应 prop 或 state 的改变<br>componentWillUnmount – 在这你可以取消网络请求，或者移除所有与组件相关的事件监听器</p><h4 id="调用-setState-之后发生了什么？"><a href="#调用-setState-之后发生了什么？" class="headerlink" title="调用 setState 之后发生了什么？"></a>调用 setState 之后发生了什么？</h4><p>代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。</p><p>经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面；<br>在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染；<br>在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p><h4 id="react-diff-原理（常考，大厂必考）"><a href="#react-diff-原理（常考，大厂必考）" class="headerlink" title="react diff 原理（常考，大厂必考）"></a>react diff 原理（常考，大厂必考）</h4><p>把树形结构按照层级分解，只比较同级元素。<br>列表结构的每个单元添加唯一的 key 属性，方便比较。<br>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）<br>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.<br>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</p><h4 id="为什么建议传递给-setState-的参数是一个-callback-而不是一个对象？"><a href="#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象？" class="headerlink" title="为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？"></a>为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？</h4><p>因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state</p><h4 id="除了在构造函数中绑定-this，还有其它方式吗？"><a href="#除了在构造函数中绑定-this，还有其它方式吗？" class="headerlink" title="除了在构造函数中绑定 this，还有其它方式吗？"></a>除了在构造函数中绑定 this，还有其它方式吗？</h4><p>你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。<br>在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。</p><h4 id="setState第二个参数的作用"><a href="#setState第二个参数的作用" class="headerlink" title="setState第二个参数的作用?"></a>setState第二个参数的作用?</h4><p>因为setState是一个异步的过程，所以说执行完setState之后不能立刻更改state里面的值。如果需要对state数据更改监听，setState提供第二个参数，就是用来监听state里面数据的更改，当数据更改完成，调用回调函数。</p><h4 id="在构造函数中-调用-super-props-的目的是什么"><a href="#在构造函数中-调用-super-props-的目的是什么" class="headerlink" title="(在构造函数中)调用 super(props) 的目的是什么?"></a>(在构造函数中)调用 super(props) 的目的是什么?</h4><p>在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。<br>传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。</p><h4 id="在-React-当中-Element-和-Component-有何区别？"><a href="#在-React-当中-Element-和-Component-有何区别？" class="headerlink" title="在 React 当中 Element 和 Component 有何区别？"></a>在 React 当中 Element 和 Component 有何区别？</h4><p>React Element 是描述屏幕上所见内容的数据结构，是对于 UI 的对象表述。<br>典型的 React Element 就是利用 JSX 构建的声明式代码片然后被转化为 createElement 的调用组合。</p><p>React Component 是一个函数或一个类，可以接收参数输入，并且返回某个 React Element</p><h4 id="组件的-状态-state-和属性-props-之间有何不同"><a href="#组件的-状态-state-和属性-props-之间有何不同" class="headerlink" title="(组件的)状态(state)和属性(props)之间有何不同?"></a>(组件的)状态(state)和属性(props)之间有何不同?</h4><p>State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。<br>Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。</p><h4 id="受控组件和非受控组件区别"><a href="#受控组件和非受控组件区别" class="headerlink" title="受控组件和非受控组件区别?"></a>受控组件和非受控组件区别?</h4><p>受控组件：<br>1.没有维持自己的状态<br>2.数据由父组件控制<br>3.通过 props 获取当前值，然后通过回调通知更改</p><p>非受控组件：<br>1、保持着自己的状态<br>2、数据由 DOM 控制<br>3、Refs 用于获取其当前值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vue&quot;&gt;&lt;a href=&quot;#vue&quot; class=&quot;headerlink&quot; title=&quot;vue&quot;&gt;&lt;/a&gt;vue&lt;/h3&gt;&lt;h4 id=&quot;一-vue的特点是什么？&quot;&gt;&lt;a href=&quot;#一-vue的特点是什么？&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>居中总结</title>
    <link href="http://example.com/2017/06/10/%E5%B1%85%E4%B8%AD%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2017/06/10/%E5%B1%85%E4%B8%AD%E6%80%BB%E7%BB%93/</id>
    <published>2017-06-10T11:55:00.000Z</published>
    <updated>2020-12-30T11:55:35.913Z</updated>
    
    <content type="html"><![CDATA[<p>剧中总结！<br>水平居中</p><p>绝对定位+left+margin-left</p><p>.first{<br>    position: absolute;<br>    left: 50%;<br>    margin-left: -50px;//也就是1/2width<br>}</p><a id="more"></a><p>☠️必须得知道物体的宽高</p><p>2.绝对定位+left+transform</p><p>.second{<br>    position: absolute;<br>    left:50%;<br>    -webkit-transform: translate(-50%);<br>    -moz-transform: translate(-50%);<br>    -ms-transform: translate(-50%);<br>    -o-transform: translate(-50%);<br>    transform: translate(-50%);<br>}<br>😍transform的妙用，translate位移是针对自身的，所以可以不知道自身的宽度，是上面的升级版。</p><p>3.绝对定位+margin+左右</p><p>.third{<br>     margin:auto;<br>     position: absolute;<br>     left:0;<br>     right:0;<br> }<br>😍margin的妙用，如果设置左右为0，那么水平居中，如果设置上下左右都为0，那么就在整个页面居中（也就是水平也居中垂直也居中），换言之，如果值设置上下为0，那么垂直方向居中。</p><p>4.flex布局</p><p>.box{<br>  display:flex;<br>  justify-content:center;<br>}<br>😍很简洁的样子，给父元素设置两行就能做到水平居中了</p><p>相对定位+margin</p><p>.fouth{<br>    position:relative;<br>    margin:x auto x;//x代表随意的数值<br>}<br>😍好简洁</p><p>5.text-align</p><p>.box{<br>    text-align:center;<br>}<br>😍text-align属性只对行内元素有效，比如图片、文字、span等，当然也能让它对div奏效，把块级元素设为行内元素就行了。这个属性是设置在父盒子上面的。一般用来设置图片和文字居中比较多。</p><p>垂直居中</p><p>1.line-height</p><p>.box{<br>  line-height:50px;<br>}<br>😍设置行高，子元素会垂直居中，不论是行内还是块级子元素都有效。 ☠️只对单行文字有效。</p><p>2.多行文字垂直居中</p><p>//第一种<br>.box{<br>  display:table;<br>  height:200px;<br>}<br>.child{<br>  display:table-sell;<br>  vertical-aligh:middle;<br>}<br>//第二种<br>.box{<br>  display:table-sell;<br>  height:200px;<br>  vertical-align:middle;<br>}<br>.child{<br>  display:inline-block;<br>}<br>👉vertical-align是用来指定行内元素和表格单元格（table-sell）元素的垂直对齐方式</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;剧中总结！&lt;br&gt;水平居中&lt;/p&gt;
&lt;p&gt;绝对定位+left+margin-left&lt;/p&gt;
&lt;p&gt;.first{&lt;br&gt;    position: absolute;&lt;br&gt;    left: 50%;&lt;br&gt;    margin-left: -50px;//也就是1/2width&lt;br&gt;}&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
