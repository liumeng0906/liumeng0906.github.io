<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-30T11:00:42.499Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js严格模式</title>
    <link href="http://example.com/2021/06/09/js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/06/09/js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-06-09T10:47:35.000Z</published>
    <updated>2020-12-30T11:00:42.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-严格模式-use-strict"><a href="#JavaScript-严格模式-use-strict" class="headerlink" title="JavaScript 严格模式(use strict)"></a>JavaScript 严格模式(use strict)</h1><h3 id="使用-“use-strict”-指令"><a href="#使用-“use-strict”-指令" class="headerlink" title="使用 “use strict” 指令"></a>使用 “use strict” 指令</h3><p>“use strict” 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。</p><p>它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。</p><p>“use strict” 的目的是指定代码在严格条件下执行。</p><p>严格模式下你不能使用未声明的变量。<br>支持严格模式的浏览器:<br>Internet Explorer 10 +、 Firefox 4+ Chrome 13+、 Safari 5.1+、 Opera 12+。</p><h3 id="严格模式声明"><a href="#严格模式声明" class="headerlink" title="严格模式声明"></a>严格模式声明</h3><p>严格模式通过在脚本或者函数的头部添加 ‘use static;表达式来声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">x &#x3D; 3.14;       &#x2F;&#x2F; 报错 (x 未定义)</span><br><span class="line">严格模式下，需要用var let 或者 const 来声明</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">myFunction();</span><br><span class="line"></span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    y &#x3D; 3.14;   &#x2F;&#x2F; 报错 (y 未定义)</span><br><span class="line">&#125;</span><br><span class="line">在函数内部声明是局部作用域 (只在函数内使用严格模式):</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; 3.14;       &#x2F;&#x2F; 不报错</span><br><span class="line">myFunction();</span><br><span class="line"></span><br><span class="line">function myFunction() &#123;</span><br><span class="line">   &quot;use strict&quot;;</span><br><span class="line">    y &#x3D; 3.14;   &#x2F;&#x2F; 报错 (y 未定义)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么使用严格模式:</p><p>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;<br>消除代码运行的一些不安全之处，保证代码运行的安全；<br>提高编译器效率，增加运行速度；<br>为未来新版本的Javascript做好铺垫。<br>“严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。</p><p>另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var x &#x3D; 3.14;</span><br><span class="line">delete x;      </span><br><span class="line">不允许删除变量或对象</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function x(p1, p1) &#123;&#125;;   </span><br><span class="line">不允许变量重名</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var x &#x3D; 010;             &#x2F;&#x2F; 报错</span><br><span class="line">不允许使用八进制</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var x &#x3D; \010;            &#x2F;&#x2F; 报错</span><br><span class="line">不允许使用转义字符:</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &quot;x&quot;, &#123;value:0, writable:false&#125;);</span><br><span class="line"></span><br><span class="line">obj.x &#x3D; 3.14;            &#x2F;&#x2F; 报错</span><br><span class="line">不允许对只读属性赋值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var obj &#x3D; &#123;get x() &#123;return 0&#125; &#125;;</span><br><span class="line"></span><br><span class="line">obj.x &#x3D; 3.14;            &#x2F;&#x2F; 报错</span><br><span class="line">不允许对一个使用getter方法读取的属性进行赋值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">delete Object.prototype; &#x2F;&#x2F; 报错</span><br><span class="line">不允许删除一个不允许删除的属性</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var eval &#x3D; 3.14;         &#x2F;&#x2F; 报错</span><br><span class="line">变量名不能使用 &quot;eval&quot; 字符串:</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var arguments &#x3D; 3.14;    &#x2F;&#x2F; 报错</span><br><span class="line">变量名不能使用 &quot;arguments&quot; 字符串</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">with (Math)&#123;x &#x3D; cos(2)&#125;; &#x2F;&#x2F; 报错\</span><br><span class="line">不允许使用一下语句</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">eval (&quot;var x &#x3D; 2&quot;);</span><br><span class="line">alert (x);               &#x2F;&#x2F; 报错</span><br><span class="line">由于一些安全原因，在作用域 eval() 创建的变量不能被调用：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">禁止this关键字指向全局对象。</span><br><span class="line">function f()&#123;</span><br><span class="line">    return !this;</span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F; 返回false，因为&quot;this&quot;指向全局对象，&quot;!this&quot;就是false</span><br><span class="line"></span><br><span class="line">function f()&#123; </span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    return !this;</span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F; 返回true，因为严格模式下，this的值为undefined，所以&quot;!this&quot;为true。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。</span><br><span class="line">function f()&#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    this.a &#x3D; 1;</span><br><span class="line">&#125;;</span><br><span class="line">f();&#x2F;&#x2F; 报错，this未定义</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript-严格模式-use-strict&quot;&gt;&lt;a href=&quot;#JavaScript-严格模式-use-strict&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 严格模式(use strict)&quot;&gt;&lt;/a&gt;JavaScr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue、react面试题</title>
    <link href="http://example.com/2021/02/22/vue%E3%80%81react/"/>
    <id>http://example.com/2021/02/22/vue%E3%80%81react/</id>
    <published>2021-02-22T07:17:05.000Z</published>
    <updated>2021-02-23T01:16:34.163Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><h4 id="一-vue的特点是什么？"><a href="#一-vue的特点是什么？" class="headerlink" title="一.vue的特点是什么？"></a>一.vue的特点是什么？</h4><p>1.遵循MVVM模式数据驱动视图<br>2.双向绑定<br>3.摒弃了原始的dom操作<br>3.可以轻松引入Vue插件或其他第三方库开发项目</p><h4 id="二-vue的原理是什么？"><a href="#二-vue的原理是什么？" class="headerlink" title="二.vue的原理是什么？"></a>二.vue的原理是什么？</h4><p>vue2.0采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter,getter,在数据变动时发布消息给订阅者,触发响应的监听回调</p><h4 id="三-computed-和-watch-有什么区别及运用场景"><a href="#三-computed-和-watch-有什么区别及运用场景" class="headerlink" title="三.computed 和 watch 有什么区别及运用场景?"></a>三.computed 和 watch 有什么区别及运用场景?</h4><p>computed 计算属性 : 依赖其它属性值,并且 computed 的值有缓存,只有它依赖的属性值发生改变,下一次获取 computed 的值时才会重新计算 computed 的值。</p><p>watch 侦听器 : 更多的是「观察」的作用,<strong>无缓存性</strong>,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作。</p><p>运用场景：</p><p>当我们需要进行数值计算,并且依赖于其它数据时,应该使用 computed,因为可以利用 computed 的缓存特性,避免每次获取值时,都要重新计算。</p><p>当我们需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),限制我们执行该操作的频率,并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。</p><h4 id="四-Vue-中的-key-到底有什么用？"><a href="#四-Vue-中的-key-到底有什么用？" class="headerlink" title="四.Vue 中的 key 到底有什么用？"></a>四.Vue 中的 key 到底有什么用？</h4><p>key 的特殊属性主要用在 Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。</p><h4 id="五-什么是MVVM？"><a href="#五-什么是MVVM？" class="headerlink" title="五.什么是MVVM？"></a>五.什么是MVVM？</h4><p>MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</p><h4 id="六-mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？"><a href="#六-mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？" class="headerlink" title="六.mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？"></a>六.mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？</h4><p>mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</p><p>区别：vue数据驱动，通过数据来显示视图层而不是节点操作。<br>场景：数据操作比较多的场景，更加便捷</p><h4 id="七-vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#七-vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="七.vuex是什么？怎么使用？哪种功能场景使用它？"></a>七.vuex是什么？怎么使用？哪种功能场景使用它？</h4><p>vuex是管理vue状态的一个库<br>任何组件都可以和store通信<br>它是单一数据源</p><h4 id="八-vuex有哪几种属性？"><a href="#八-vuex有哪几种属性？" class="headerlink" title="八.vuex有哪几种属性？"></a>八.vuex有哪几种属性？</h4><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p><p>·  vuex的State特性<br>A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data<br>B、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新<br>C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</p><p>· vuex的Getter特性<br>A、getters 可以对State进行计算操作，它就是Store的计算属性<br>B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用<br>C、 如果一个状态只在一个组件内使用，是可以不用getters</p><p>·  vuex的Mutation特性<br>Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。</p><h4 id="九-v-show和v-if指令的共同点和不同点"><a href="#九-v-show和v-if指令的共同点和不同点" class="headerlink" title="九. v-show和v-if指令的共同点和不同点"></a>九. v-show和v-if指令的共同点和不同点</h4><p>v-show指令是通过修改元素的display的CSS属性让其显示或者隐藏<br>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果</p><h4 id="十-vue-router有哪几种导航钩子？"><a href="#十-vue-router有哪几种导航钩子？" class="headerlink" title="十.vue-router有哪几种导航钩子？"></a>十.vue-router有哪几种导航钩子？</h4><p>三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。<br>第二种：组件内的钩子；<br>第三种：单独路由独享组件</p><h4 id="十一-什么是vue生命周期"><a href="#十一-什么是vue生命周期" class="headerlink" title="十一.什么是vue生命周期"></a>十一.什么是vue生命周期</h4><p>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p><h4 id="十二-vue生命周期的作用是什么"><a href="#十二-vue生命周期的作用是什么" class="headerlink" title="十二.vue生命周期的作用是什么"></a>十二.vue生命周期的作用是什么</h4><p>它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p><h4 id="十三-第一次页面加载会触发哪几个钩子"><a href="#十三-第一次页面加载会触发哪几个钩子" class="headerlink" title="十三.第一次页面加载会触发哪几个钩子"></a>十三.第一次页面加载会触发哪几个钩子</h4><p>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</p><h4 id="十四-简单描述每个周期具体适合哪些场景"><a href="#十四-简单描述每个周期具体适合哪些场景" class="headerlink" title="十四.简单描述每个周期具体适合哪些场景"></a>十四.简单描述每个周期具体适合哪些场景</h4><p>生命周期钩子的一些使用方法：<br>beforecreate : 可以在这加个loading事件，在加载实例时触发<br>created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用<br>mounted : 挂载元素，获取到DOM节点<br>updated : 如果对数据统一处理，在这里写上相应函数<br>beforeDestroy : 可以做一个确认停止事件的确认框<br>nextTick : 更新数据后立即操作dom</p><h4 id="十五-为什么使用key？"><a href="#十五-为什么使用key？" class="headerlink" title="十五.为什么使用key？"></a>十五.为什么使用key？</h4><p>当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。</p><h4 id="十六-为什么避免-v-if-和-v-for-用在一起"><a href="#十六-为什么避免-v-if-和-v-for-用在一起" class="headerlink" title="十六.为什么避免 v-if 和 v-for 用在一起"></a>十六.为什么避免 v-if 和 v-for 用在一起</h4><p>当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。</p><h4 id="十七-VNode是什么？虚拟-DOM是什么？"><a href="#十七-VNode是什么？虚拟-DOM是什么？" class="headerlink" title="十七.VNode是什么？虚拟 DOM是什么？"></a>十七.VNode是什么？虚拟 DOM是什么？</h4><p>Vue在 页面上渲染的节点，及其子节点称为“虚拟节点 (Virtual Node)”，简写为“VNode”。“虚拟 DOM”是由 Vue 组件树建立起来的整个 VNode 树的称呼。</p><h4 id="十八-active-class是哪个组件的属性？嵌套路由怎么定义？"><a href="#十八-active-class是哪个组件的属性？嵌套路由怎么定义？" class="headerlink" title="十八.active-class是哪个组件的属性？嵌套路由怎么定义？"></a>十八.active-class是哪个组件的属性？嵌套路由怎么定义？</h4><p>vue-router模块的router-link组件。<br>嵌套路由顾名思义就是路由的多层嵌套。 一级路由里面使用children数组配置子路由，就是嵌套路由。</p><h4 id="十九-怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"><a href="#十九-怎么定义vue-router的动态路由？怎么获取传过来的动态参数？" class="headerlink" title="十九.怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"></a>十九.怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</h4><p>在router目录下的index.js文件中，对path属性加上/:id。  使用router对象的params.id</p><h4 id="二十-请说出vue-cli项目中src目录每个文件夹和文件的用法？"><a href="#二十-请说出vue-cli项目中src目录每个文件夹和文件的用法？" class="headerlink" title="二十.请说出vue.cli项目中src目录每个文件夹和文件的用法？"></a>二十.请说出vue.cli项目中src目录每个文件夹和文件的用法？</h4><p>assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件</p><h4 id="二十一-指令v-el的作用是什么"><a href="#二十一-指令v-el的作用是什么" class="headerlink" title="二十一.指令v-el的作用是什么?"></a>二十一.指令v-el的作用是什么?</h4><p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例</p><h4 id="二十二-请列举出3个Vue中常用的生命周期钩子函数"><a href="#二十二-请列举出3个Vue中常用的生命周期钩子函数" class="headerlink" title="二十二.请列举出3个Vue中常用的生命周期钩子函数?"></a>二十二.请列举出3个Vue中常用的生命周期钩子函数?</h4><p>created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见</p><p>mounted: el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</p><p>activated::keep-alive组件激活时调用</p><h4 id="二十三-怎样理解单向数据流"><a href="#二十三-怎样理解单向数据流" class="headerlink" title="二十三.怎样理解单向数据流"></a>二十三.怎样理解单向数据流</h4><p>这个概念出现在组件通信。父组件是通过 prop 把数据传递到子组件的，但是这个 prop 只能由父组件修改，子组件不能修改，否则会报错。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p><h4 id="二十四-各个生命周期的作用"><a href="#二十四-各个生命周期的作用" class="headerlink" title="二十四.各个生命周期的作用"></a>二十四.各个生命周期的作用</h4><p>beforeCreate 组件实例被创建之初，组件的属性生效之前<br>created 组件实例已经完全出创建，属性也绑定，但是真实 DOM 没有生成，$el 还不可以用<br>beforeMount 在挂载开始之前被调用，相关的render函数首次被调用<br>mounted el 被新创建的 vm.$el 替换，并挂载实例上去调动该钩子<br>beforeUpdate 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前<br>update 组件数据更新之后<br>activated keep-alive 专属，组件被激活时调用<br>deactivated keep-alive 专属，组件被销毁时调用<br>beforeDestory 组件销毁前调用<br>destroyed 组件销毁后调用<br>#Vue 的父组件和子</p><h4 id="二十五-在哪个生命周期内调用异步请求？"><a href="#二十五-在哪个生命周期内调用异步请求？" class="headerlink" title="二十五.在哪个生命周期内调用异步请求？"></a>二十五.在哪个生命周期内调用异步请求？</h4><p>在 钩子函数 created 、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务器点的数据返回进行赋值</p><h4 id="二十六-在什么阶段才能访问操作-DOM"><a href="#二十六-在什么阶段才能访问操作-DOM" class="headerlink" title="二十六.在什么阶段才能访问操作 DOM"></a>二十六.在什么阶段才能访问操作 DOM</h4><p>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以可以在 mounted 中访问到 DOM</p><h4 id="二十七-Proxy-与-Object-defineProperty-优劣对比"><a href="#二十七-Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="二十七.Proxy 与 Object.defineProperty 优劣对比"></a>二十七.Proxy 与 Object.defineProperty 优劣对比</h4><p>Proxy 可以直接监听对象而非属性；<br>Proxy 可以直接监听数组的变化；<br>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；<br>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；<br>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</p><h4 id="二十八-使你用过-Vuex-吗？"><a href="#二十八-使你用过-Vuex-吗？" class="headerlink" title="二十八.使你用过 Vuex 吗？"></a>二十八.使你用过 Vuex 吗？</h4><p>主要包含一下几种模块：<br>#State<br>定义了应用状态的数据结构，可以在这里设置默认的初始化状态。<br>#Getter<br>允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性中。<br>#Mutation<br>是唯一更改 store 中状态的方法，且必须是同步函数。<br>#Action<br>用于提交 mutation，而不是直接变更状态，可以任何异步操作。<br>#Module<br>允许将单一的 Store 拆分为多个 store 且同时保持在单一的状态数中</p><h4 id="二十九-使用过-Vue-SSR-吗？-说说-SSR"><a href="#二十九-使用过-Vue-SSR-吗？-说说-SSR" class="headerlink" title="二十九.使用过 Vue SSR 吗？ 说说 SSR"></a>二十九.使用过 Vue SSR 吗？ 说说 SSR</h4><p>SSR 将 Vue 在客户端将标签渲染成HTML 片段的工作放到了服务端完成，服务端形成的 HTML 片段直接返回给客户端这个过程，叫做服务端渲染</p><h4 id="三十-计算属性和methods的区别？为什么要用计算属性而不用methods？"><a href="#三十-计算属性和methods的区别？为什么要用计算属性而不用methods？" class="headerlink" title="三十.计算属性和methods的区别？为什么要用计算属性而不用methods？"></a>三十.计算属性和methods的区别？为什么要用计算属性而不用methods？</h4><p>它两的执行结果是一样的。计算属性 是只有它的依赖发生变化的时候它会自动的进行计算求值，如果依赖没有发生变化，那么每次访问的时候计算属性都会立刻返回之前的执行结果，而事件函数需要手动调用，并且调用一次触发一次比较粗暴一点，每当重新触发渲染时，调用方法总是再次执行函数。</p><h4 id="三十一-vue-router-的原理是什么？"><a href="#三十一-vue-router-的原理是什么？" class="headerlink" title="三十一.vue-router 的原理是什么？"></a>三十一.vue-router 的原理是什么？</h4><p>vue-router是什么：他可以让单页面应用拥有了多页面应用的效果，一个url对应一个页面。<br>它主要是通过h5新增的history和hash两种模式来实现的<br>hash —— 即地址栏 URL 中的 # 符号。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。每次hash值得变化，会触发hashchange这个时间，通过这个时间我就可以知道hash值发生了哪些变化。然后我们就可以监听hashchange来实现更新页面部分内容的操作。<br>history —— 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。<br>因此可以说，hash 模式和 history 模式都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由.</p><h4 id="三十二-插槽的作用："><a href="#三十二-插槽的作用：" class="headerlink" title="三十二.插槽的作用："></a>三十二.插槽的作用：</h4><p>为了让组件更加具有扩展性。抽取共性，保留不同为插槽，让其他组件可以传递自己想展示的标签到预留插槽。它包含具名插槽，匿名插槽、还有作用域插槽。</p><h4 id="三十三-keep-alive的作用？"><a href="#三十三-keep-alive的作用？" class="headerlink" title="三十三.keep-alive的作用？"></a>三十三.keep-alive的作用？</h4><p>缓存组件的状态，在组件还原的时候能够把状态还原到组件上。然后它有3个属性，分别是：include(包括)、exclude(不包括)、max(可缓存的最大组件实例数量)<br>利用keep-alive组件把想要缓存的组件包一下，并且给被缓存的组件添加name属性，在include属性里面写上我们要缓存的组件name</p><h4 id="三十四-vuex与全局对象的区别？"><a href="#三十四-vuex与全局对象的区别？" class="headerlink" title="三十四.vuex与全局对象的区别？"></a>三十四.vuex与全局对象的区别？</h4><p>Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会得到高效更新。<br>不能直接改变store中的状态，改变store中的状态的唯一途径就是显示地提交(commit)mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p><h4 id="三十五-为什么组件里的data是个函数？"><a href="#三十五-为什么组件里的data是个函数？" class="headerlink" title="三十五.为什么组件里的data是个函数？"></a>三十五.为什么组件里的data是个函数？</h4><p>一个组件被复用多次的话，也就会创建多个实例。本质上， 这些实例都是同一个构造函数<br>如果data是对象的话，对象属于引用类型，会影响到所有的实例<br>所以为了保证组件不同的实例之间data不冲突，data必须是个函数</p><h4 id="三十六-vue2-x和vue3-x渲染器的diff算法有什么区别？"><a href="#三十六-vue2-x和vue3-x渲染器的diff算法有什么区别？" class="headerlink" title="三十六.vue2.x和vue3.x渲染器的diff算法有什么区别？"></a>三十六.vue2.x和vue3.x渲染器的diff算法有什么区别？</h4><p>Vue3.x借鉴了 ivi算法和 inferno算法<br>Vue2的核?Diff算法采?了双端?较的算法，同时从新旧children的两端开始进??较，借助key值找到可复?的节点，再进?相关操作<br>在创建VNode时就确定其类型，以及在mount/patch的过程中采?位运算来判断?个VNode的类型，在这个基础之上再配合核?的Diff算法，使得性能上较Vue2.x有了提升</p><h4 id="三十七-那你知道Vue3-x响应式数据原理吗？"><a href="#三十七-那你知道Vue3-x响应式数据原理吗？" class="headerlink" title="三十七.那你知道Vue3.x响应式数据原理吗？"></a>三十七.那你知道Vue3.x响应式数据原理吗？</h4><p>Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。<br>Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？<br>答：判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。<br>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？？<br>答：我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p><h4 id="三十八-nextTick知道吗，实现原理是什么？"><a href="#三十八-nextTick知道吗，实现原理是什么？" class="headerlink" title="三十八.nextTick知道吗，实现原理是什么？"></a>三十八.nextTick知道吗，实现原理是什么？</h4><p>在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用<br>PromiseMutationObserversetImmediate如果以上都不行则采用setTimeout<br>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p><h4 id="三十九-说一下Vue的生命周期"><a href="#三十九-说一下Vue的生命周期" class="headerlink" title="三十九.说一下Vue的生命周期"></a>三十九.说一下Vue的生命周期</h4><p>beforeCreate是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。<br>created在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。<br>beforeMount发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。<br>mounted在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。<br>beforeUpdate发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。<br>updated发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。<br>beforeDestroy发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。<br>destroyed发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p><h4 id="四十-说一下v-model的原理"><a href="#四十-说一下v-model的原理" class="headerlink" title="四十.说一下v-model的原理?"></a>四十.说一下v-model的原理?</h4><p>v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。</p><h4 id="四十一-Vue事件绑定原理说一下"><a href="#四十一-Vue事件绑定原理说一下" class="headerlink" title="四十一.Vue事件绑定原理说一下?"></a>四十一.Vue事件绑定原理说一下?</h4><p>原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。</p><h4 id="四十一-Vue中组件生命周期调用顺序说一下"><a href="#四十一-Vue中组件生命周期调用顺序说一下" class="headerlink" title="四十一.Vue中组件生命周期调用顺序说一下?"></a>四十一.Vue中组件生命周期调用顺序说一下?</h4><p>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。<br>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。<br>加载渲染过程<br>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount- &gt;子mounted-&gt;父mounted<br>子组件更新过程<br>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated<br>父组件更新过程<br>父 beforeUpdate -&gt; 父 updated<br>销毁过程<br>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p><h4 id="四十二-Vue2-x组件通信有哪些方式？"><a href="#四十二-Vue2-x组件通信有哪些方式？" class="headerlink" title="四十二.Vue2.x组件通信有哪些方式？"></a>四十二.Vue2.x组件通信有哪些方式？</h4><p>父子组件通信<br>父-&gt;子props，子-&gt;父 $on、$emit<br>获取父子组件实例 $parent、$children<br>Ref 获取实例的方式调用组件的属性或者方法<br>Provide、inject 官方不推荐使用，但是写组件库时很常用<br>兄弟组件通信<br>Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue<br>Vuex<br>跨级组件通信<br>Vuex<br>$attrs、$listeners<br>Provide、inject</p><h4 id="四十三-你都做过哪些Vue的性能优化？"><a href="#四十三-你都做过哪些Vue的性能优化？" class="headerlink" title="四十三.你都做过哪些Vue的性能优化？"></a>四十三.你都做过哪些Vue的性能优化？</h4><p>编码阶段</p><p>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcherv-if和v-for不能连用如果需要使用v-for给每项元素绑定事件时使用事件代理SPA 页面采用keep-alive缓存组件在更多的情况下，使用v-if替代v-showkey保证唯一使用路由懒加载、异步组件防抖、节流第三方模块按需导入长列表滚动到可视区域动态加载图片懒加载<br>SEO优化</p><p>预渲染服务端渲染SSR<br>打包优化</p><p>压缩代码Tree Shaking/Scope Hoisting使用cdn加载第三方模块多线程打包happypacksplitChunks抽离公共文件sourceMap优化<br>用户体验</p><p>骨架屏 PWA</p><h4 id="四十四-vue中的修饰符"><a href="#四十四-vue中的修饰符" class="headerlink" title="四十四.vue中的修饰符?"></a>四十四.vue中的修饰符?</h4><p>.stop 阻止事件冒泡<br>.prevent 清除默认行为<br>.once 只触发一次回调<br>.lazy 取代input 监听change 事件<br>.number 输入字符串转为有效的数字<br>.trim 输入首尾空格过滤</p><h4 id="四十五-vue中的指令有哪些？"><a href="#四十五-vue中的指令有哪些？" class="headerlink" title="四十五.vue中的指令有哪些？"></a>四十五.vue中的指令有哪些？</h4><p>v-if、v-else、v-for、v-bind、v-model、v-onv-text</p><h4 id="四十六-插槽之间是怎么传值的？"><a href="#四十六-插槽之间是怎么传值的？" class="headerlink" title="四十六.插槽之间是怎么传值的？"></a>四十六.插槽之间是怎么传值的？</h4><p>可以用作用域插槽进行传值。子组件的slot标签中动态绑定属性，父组件中给template标签绑定(v-slot)值，子组件抛出来的接口，可以通过这个值访问到子组件的数据</p><h4 id="四十七-vue中的内置组件有哪些？"><a href="#四十七-vue中的内置组件有哪些？" class="headerlink" title="四十七.vue中的内置组件有哪些？"></a>四十七.vue中的内置组件有哪些？</h4><p>component、<br>transition、<br>transition-group、<br>keep-alive、<br>slot</p><h4 id="四十八-vue中的transfrom组件是什么？"><a href="#四十八-vue中的transfrom组件是什么？" class="headerlink" title="四十八.vue中的transfrom组件是什么？"></a>四十八.vue中的transfrom组件是什么？</h4><p>使用transfrom可以完成任何元素进入/离开的过渡效果。<br>它的用法是：首先在这个组件内设置一个那么属性，然后再css中用v-enter、v-enter-active、v-leave、v-leave-active<br>来实现整体的效果。</p><h4 id="四十九-computed-是什么？实现原理？"><a href="#四十九-computed-是什么？实现原理？" class="headerlink" title="四十九.computed 是什么？实现原理？"></a>四十九.computed 是什么？实现原理？</h4><p>是：计算属性。基于当前的数据进行简单的加工返回新的数据，当计算属性所依赖的数据发生变化时，它会自动进行计算。<br>写起来像函数，本质是属性。</p><p>对大量计算有优化效果。仅仅在依赖的数据发生变化时，才执行。<br>computed 内部实现了一个惰性的 watcher，在实例化的时候不会去求值，其内部通过 dirty 属性标记计算属性是否需要重新求值。当 computed 依赖的任意状态发生改变，都会通知这个惰性的 watcher，让它把 dirty 属性设置为 true，所以，当再次读取这个计算属性的时候，就会重新去求值。<br>惰性的watcher 计算属性在创建时不会去求值的，是在使用时去求值。</p><p>computed 本质是一个惰性求值的观察者。</p><p>computed 内部实现了一个惰性的 watcher,也就是 computed watcher,computed watcher 不会立刻求值,同时持有一个 dep 实例。</p><p>其内部通过 this.dirty 属性标记计算属性是否需要重新求值。</p><p>当 computed 的依赖状态发生改变时,就会通知这个惰性的 watcher,</p><p>computed watcher 通过 this.dep.subs.length 判断有没有订阅者,</p><p>有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 (<strong>Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染，本质上是一种优化。</strong>)<br>没有的话,仅仅把 this.dirty = true。 (<strong>当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性。</strong>)</p><h5 id="五十-为什么在-Vue3-0-采用了-Proxy-抛弃了-Object-defineProperty？"><a href="#五十-为什么在-Vue3-0-采用了-Proxy-抛弃了-Object-defineProperty？" class="headerlink" title="五十.为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？"></a>五十.为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？</h5><p>Object.defineProperty 本身有一定的监控到数组下标变化的能力,但是在 Vue 中,从性能/体验的性价比考虑,尤大大就弃用了这个特性(<a href="https://link.zhihu.com/?target=https://segmentfault.com/a/1190000015783546">Vue 为什么不能检测数组变动</a> )。为了解决这个问题,经过 vue 内部处理后可以使用以下几种方法来监听数组</p><h3 id="react面试题"><a href="#react面试题" class="headerlink" title="react面试题"></a>react面试题</h3><h4 id="什么是react？"><a href="#什么是react？" class="headerlink" title="什么是react？"></a>什么是react？</h4><p>它是facebook在2011年发布的一个框架<br>react和vue大体是差不多一个开发框架，支出组件并且可以引入第三方UI库<br>相对vue来说它比较更原生一点，vue相对来说更容易上手。</p><h4 id="react有什么特点？"><a href="#react有什么特点？" class="headerlink" title="react有什么特点？"></a>react有什么特点？</h4><p>它使用虚拟dom而不是真正的dom<br>它可以用服务器端渲染<br>它遵循单向数据流或者数据绑定</p><h4 id="vue和react的区别？"><a href="#vue和react的区别？" class="headerlink" title="vue和react的区别？"></a>vue和react的区别？</h4><p>react严格上针对的是mvc模式的view层，vue则是mvvm模式。<br>操作dom的方式不同，vue使用的是指令操作dom，react是通过js进行操作。<br>数据绑定不同，vue实现的是双向绑定，react的数据流动是单向的。<br>react中state是不能直接改变的，需要使用setState改变。vue中的state不是必须的，数据主要是由data属性在vue对象中管理的。</p><h4 id="列出React的一些主要优点？"><a href="#列出React的一些主要优点？" class="headerlink" title="列出React的一些主要优点？"></a>列出React的一些主要优点？</h4><p>它提高了应用的性能<br>可以方便地在客户端和服务器端使用<br>由于 JSX，代码的可读性很好<br>React 很容易与 Meteor，Angular 等其他框架集成<br>使用React，编写UI测试用例变得非常容易</p><h4 id="React有哪些限制？"><a href="#React有哪些限制？" class="headerlink" title="React有哪些限制？"></a>React有哪些限制？</h4><p>React 只是一个库，而不是一个完整的框架<br>它的库非常庞大，需要时间来理解<br>新手程序员可能很难理解<br>编码变得复杂，因为它使用内联模板和 JSX</p><h4 id="什么是虚拟DOM？"><a href="#什么是虚拟DOM？" class="headerlink" title="什么是虚拟DOM？"></a>什么是虚拟DOM？</h4><p>虚拟 DOM (VDOM)是真实 DOM 在内存中的表示。UI 的表示形式保存在内存中，并与实际的 DOM 同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。</p><h4 id="什么是JSX？"><a href="#什么是JSX？" class="headerlink" title="什么是JSX？"></a>什么是JSX？</h4><p>JSX 是J avaScript XML 的简写。是 React 使用的一种文件，它利用 JavaScript 的表现力和类似 HTML 的模板语法。这使得 HTML 文件非常容易理解。此文件能使应用非常可靠，并能够提高其性能。下面是JSX的一个例子：</p><h4 id="为什么不直接更新-state-呢"><a href="#为什么不直接更新-state-呢" class="headerlink" title="为什么不直接更新 state 呢 ?"></a>为什么不直接更新 state 呢 ?</h4><p>如果试图直接更新 state ，则不会重新渲染组件<br>要使用setState()方法来更新 state。它调度对组件state对象的更新。当state改变时，组件通过重新渲染来响应：</p><h4 id="使用-React-Hooks-好处是啥？"><a href="#使用-React-Hooks-好处是啥？" class="headerlink" title="使用 React Hooks 好处是啥？"></a>使用 React Hooks 好处是啥？</h4><p>首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 props 的负担。Hooks 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。</p><p>Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。</p><h4 id="什么是-React-Hooks？"><a href="#什么是-React-Hooks？" class="headerlink" title="什么是 React Hooks？"></a>什么是 React Hooks？</h4><p>Hooks是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用state和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。</p><h4 id="什么是-React-Context"><a href="#什么是-React-Context" class="headerlink" title="什么是 React Context?"></a>什么是 React Context?</h4><p>Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。</p><h4 id="什么是纯函数？"><a href="#什么是纯函数？" class="headerlink" title="什么是纯函数？"></a>什么是纯函数？</h4><p>纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。</p><h4 id="你了解-Virtual-DOM-吗？解释一下它的工作原理？"><a href="#你了解-Virtual-DOM-吗？解释一下它的工作原理？" class="headerlink" title="你了解 Virtual DOM 吗？解释一下它的工作原理？"></a>你了解 Virtual DOM 吗？解释一下它的工作原理？</h4><p>Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。<br>Virtual DOM 工作过程有三个简单的步骤：<br>每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。<br>然后计算之前 DOM 表示与新表示的之间的差异。<br>完成计算后，将只用实际更改的内容更新 real DOM</p><h4 id="为什么浏览器无法读取JSX？"><a href="#为什么浏览器无法读取JSX？" class="headerlink" title="为什么浏览器无法读取JSX？"></a>为什么浏览器无法读取JSX？</h4><p>浏览器只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX。所以为了使浏览器能够读取 JSX，首先，需要用像 Babel 这样的 JSX 转换器将 JSX 文件转换为 JavaScript 对象，然后再将其传给浏览器。</p><h4 id="与-ES5-相比，React-的-ES6-语法有何不同？"><a href="#与-ES5-相比，React-的-ES6-语法有何不同？" class="headerlink" title="与 ES5 相比，React 的 ES6 语法有何不同？"></a>与 ES5 相比，React 的 ES6 语法有何不同？</h4><h4 id="你理解“在React中，一切都是组件”这句话？"><a href="#你理解“在React中，一切都是组件”这句话？" class="headerlink" title="你理解“在React中，一切都是组件”这句话？"></a>你理解“在React中，一切都是组件”这句话？</h4><p>组件是 React 应用 UI 的构建块。这些组件将整个 UI 分成小的独立并可重用的部分。每个组件彼此独立，而不会影响 UI 的其余部分。</p><h4 id="解释-React-中-render-的目的？"><a href="#解释-React-中-render-的目的？" class="headerlink" title="解释 React 中 render() 的目的？"></a>解释 React 中 render() 的目的？</h4><p>每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，例如 <form>、<group>、<div> 等。此函数必须保持纯净，即必须每次调用时都返回相同的结果。</p><h4 id="什么是-Props"><a href="#什么是-Props" class="headerlink" title="什么是 Props?"></a>什么是 Props?</h4><p>Props 是 React 中属性的简写。它们是只读组件，必须保持纯，即不可变。它们总是在整个应用中从父组件传递到子组件。子组件永远不能将 prop 送回父组件。这有助于维护单向数据流，通常用于呈现动态生成的数据。</p><h4 id="React中的状态是什么？它是如何使用的？"><a href="#React中的状态是什么？它是如何使用的？" class="headerlink" title="React中的状态是什么？它是如何使用的？"></a>React中的状态是什么？它是如何使用的？</h4><p>状态是 React 组件的核心，是数据的来源，必须尽可能简单。基本上状态是确定组件呈现和行为的对象。与props 不同，它们是可变的，并创建动态和交互式组件。可以通过 this.state() 访问它们</p><h4 id="如何更新组件的状态？"><a href="#如何更新组件的状态？" class="headerlink" title="如何更新组件的状态？"></a>如何更新组件的状态？</h4><p>可以用 this.setState()更新组件的状态。</p><h4 id="详细解释-React-组件的生命周期方法。"><a href="#详细解释-React-组件的生命周期方法。" class="headerlink" title="详细解释 React 组件的生命周期方法。"></a>详细解释 React 组件的生命周期方法。</h4><p>componentWillMount**()** – 在渲染之前执行，在客户端和服务器端都会执行。<br>componentDidMount**()** – 仅在第一次渲染后在客户端执行。<br>componentWillReceiveProps**()** – 当从父类接收到 props 并且在调用另一个渲染器之前调用。<br>shouldComponentUpdate**()** – 根据特定条件返回 true 或 false。如果你希望更新组件，请返回true 否则返回 false。默认情况下，它返回 false。<br>componentWillUpdate**()** – 在 DOM 中进行渲染之前调用。<br>componentDidUpdate**()** – 在渲染发生后立即调用。<br>componentWillUnmount**()** – 从 DOM 卸载组件后调用。用于清理内存空间。</p><h4 id="React中的合成事件是什么？"><a href="#React中的合成事件是什么？" class="headerlink" title="React中的合成事件是什么？"></a>React中的合成事件是什么？</h4><p>合成事件是围绕浏览器原生事件充当跨浏览器包装器的对象。它们将不同浏览器的行为合并为一个 API。这样做是为了确保事件在不同浏览器中显示一致的属性。</p><h4 id="你对-React-的-refs-有什么了解？"><a href="#你对-React-的-refs-有什么了解？" class="headerlink" title="你对 React 的 refs 有什么了解？"></a>你对 React 的 refs 有什么了解？</h4><p>Refs 是 React 中引用的简写。它是一个有助于存储对特定的 React 元素或组件的引用的属性，它将由组件渲染配置函数返回。用于对 render() 返回的特定元素或组件的引用。当需要进行 DOM 测量或向组件添加方法时，它们会派上用场。</p><h4 id="什么是高阶组件（HOC）？"><a href="#什么是高阶组件（HOC）？" class="headerlink" title="什么是高阶组件（HOC）？"></a>什么是高阶组件（HOC）？</h4><p>高阶组件是重用组件逻辑的高级方法，是一种源于 React 的组件模式。 HOC 是自定义组件，在它之内包含另一个组件。它们可以接受子组件提供的任何动态，但不会修改或复制其输入组件中的任何行为。你可以认为 HOC 是“纯（Pure）”组件。</p><h4 id="你能用HOC做什么？"><a href="#你能用HOC做什么？" class="headerlink" title="你能用HOC做什么？"></a>你能用HOC做什么？</h4><p>代码重用，逻辑和引导抽象<br>渲染劫持<br>状态抽象和控制<br>Props 控制</p><h4 id="什么是纯组件？"><a href="#什么是纯组件？" class="headerlink" title="什么是纯组件？"></a>什么是纯组件？</h4><p>纯（Pure） 组件是可以编写的最简单、最快的组件。它们可以替换任何只有 render() 的组件。这些组件增强了代码的简单性和应用的性能。</p><h4 id="React-中-key-的重要性是什么？"><a href="#React-中-key-的重要性是什么？" class="headerlink" title="React 中 key 的重要性是什么？"></a>React 中 key 的重要性是什么？</h4><p>key 用于识别唯一的 Virtual DOM 元素及其驱动 UI 的相应数据。它们通过回收 DOM 中当前所有的元素来帮助 React 优化渲染。这些 key 必须是唯一的数字或字符串，React 只是重新排序元素而不是重新渲染它们。这可以提高应用程序的性能。</p><h4 id="MVC框架的主要问题是什么？"><a href="#MVC框架的主要问题是什么？" class="headerlink" title="MVC框架的主要问题是什么？"></a>MVC框架的主要问题是什么？</h4><p>对 DOM 操作的代价非常高<br>程序运行缓慢且效率低下<br>内存浪费严重<br>由于循环依赖性，组件模型需要围绕 models 和 views 进行创建</p><h4 id="解释一下-Flux？"><a href="#解释一下-Flux？" class="headerlink" title="解释一下 Flux？"></a>解释一下 Flux？</h4><p>Flux 是一种强制单向数据流的架构模式。它控制派生数据，并使用具有所有数据权限的中心 store 实现多个组件之间的通信。整个应用中的数据更新必须只能在此处进行。 Flux 为应用提供稳定性并减少运行时的错误。</p><h4 id="什么是Redux？"><a href="#什么是Redux？" class="headerlink" title="什么是Redux？"></a>什么是Redux？</h4><p>Redux 是当今最热门的前端开发库之一。它是 JavaScript 程序的可预测状态容器，用于整个应用的状态管理。使用 Redux 开发的应用易于测试，可以在不同环境中运行，并显示一致的行为。</p><h4 id="Redux遵循的三个原则是什么？"><a href="#Redux遵循的三个原则是什么？" class="headerlink" title="Redux遵循的三个原则是什么？"></a>Redux遵循的三个原则是什么？</h4><p>单一数据源<br>使用纯函数进行修改<br>状态是只读的</p><h4 id="你对“单一事实来源”有什么理解？"><a href="#你对“单一事实来源”有什么理解？" class="headerlink" title="你对“单一事实来源”有什么理解？"></a>你对“单一事实来源”有什么理解？</h4><p>Redux 使用 “Store” 将程序的整个状态存储在同一个地方。因此所有组件的状态都存储在 Store 中，并且它们从 Store 本身接收更新。单一状态树可以更容易地跟踪随时间的变化，并调试或检查程序。</p><h4 id="列出-Redux-的组件。"><a href="#列出-Redux-的组件。" class="headerlink" title="列出 Redux 的组件。"></a>列出 Redux 的组件。</h4><p>Action – 这是一个用来描述发生了什么事情的对象。<br>Reducer – 这是一个确定状态将如何变化的地方。<br>Store – 整个程序的状态/对象树保存在Store中。<br>View – 只显示 Store 提供的数据。</p><h4 id="redux中间件？"><a href="#redux中间件？" class="headerlink" title="redux中间件？"></a>redux中间件？</h4><p>edux-logger：提供日志输出<br>redux-thunk：处理异步操作<br>redux-promise：处理异步操作，actionCreator的返回值是promise</p><h4 id="如何在-Redux-中定义-Action？"><a href="#如何在-Redux-中定义-Action？" class="headerlink" title="如何在 Redux 中定义 Action？"></a>如何在 Redux 中定义 Action？</h4><p>React 中的 Action 必须具有 type 属性，该属性指示正在执行的 ACTION 的类型。必须将它们定义为字符串常量，并且还可以向其添加更多的属性。在 Redux 中，action 被名为 Action Creators 的函数所创建。以下是 Action 和Action Creator 的示例：</p><h4 id="解释-Reducer-的作用？"><a href="#解释-Reducer-的作用？" class="headerlink" title="解释 Reducer 的作用？"></a>解释 Reducer 的作用？</h4><p>Reducers 是纯函数，它规定应用程序的状态怎样因响应 ACTION 而改变。Reducers 通过接受先前的状态和 action 来工作，然后它返回一个新的状态。它根据操作的类型确定需要执行哪种更新，然后返回新的值。如果不需要完成任务，它会返回原来的状态。</p><h4 id="Store-在-Redux-中的意义是什么？"><a href="#Store-在-Redux-中的意义是什么？" class="headerlink" title="Store 在 Redux 中的意义是什么？"></a>Store 在 Redux 中的意义是什么？</h4><p>Store 是一个 JavaScript 对象，它可以保存程序的状态，并提供一些方法来访问状态、调度操作和注册侦听器。应用程序的整个状态/对象树保存在单一存储中。因此，Redux 非常简单且是可预测的。我们可以将中间件传递到 store 来处理数据，并记录改变存储状态的各种操作。所有操作都通过 reducer 返回一个新状态。</p><h4 id="什么是React-路由？"><a href="#什么是React-路由？" class="headerlink" title="什么是React 路由？"></a>什么是React 路由？</h4><p>React 路由是一个构建在 React 之上的强大的路由库，它有助于向应用程序添加新的屏幕和流。这使 URL 与网页上显示的数据保持同步。它负责维护标准化的结构和行为，并用于开发单页 Web 应用。 React 路由有一个简单的API。</p><h4 id="为什么React-Router-v4中使用-switch-关键字-？"><a href="#为什么React-Router-v4中使用-switch-关键字-？" class="headerlink" title="为什么React Router v4中使用 switch 关键字 ？"></a>为什么React Router v4中使用 switch 关键字 ？</h4><p>虽然 <div> ** 用于封装 Router 中的多个路由，当你想要仅显示要在多个定义的路线中呈现的单个路线时，可以使用 “switch” 关键字。使用时，<switch>** 标记会按顺序将已定义的 URL 与已定义的路由进行匹配。找到第一个匹配项后，它将渲染指定的路径。从而绕过其它路线。</p><h4 id="为什么需要-React-中的路由？"><a href="#为什么需要-React-中的路由？" class="headerlink" title="为什么需要 React 中的路由？"></a>为什么需要 React 中的路由？</h4><p>Router 用于定义多个路由，当用户定义特定的 URL 时，如果此 URL 与 Router 内定义的任何 “路由” 的路径匹配，则用户将重定向到该特定路由。所以基本上我们需要在自己的应用中添加一个 Router 库，允许创建多个路由，每个路由都会向我们提供一个独特的视图</p><h4 id="react性能优化的方案？"><a href="#react性能优化的方案？" class="headerlink" title="react性能优化的方案？"></a>react性能优化的方案？</h4><p>重写shouldComponentUpdate来避免不必要的dom操作。<br>使用 production 版本的react.js。<br>使用key来帮助React识别列表中所有子组件的最小变化。</p><h4 id="介绍一下webpack？"><a href="#介绍一下webpack？" class="headerlink" title="介绍一下webpack？"></a>介绍一下webpack？</h4><p>webpack是一个前端模块化打包工具，主要由入口，出口，loader，plugins四个部分。前端的打包工具还有一个gulp，不过gulp侧重于前端开发的过程，而webpack侧重于模块，例如他会将css文件看作一个模块，通过css-loader将css打包成符合css的静态资源。</p><h4 id="react生命周期中，最适合与服务端进行数据交互的是哪个函数？"><a href="#react生命周期中，最适合与服务端进行数据交互的是哪个函数？" class="headerlink" title="react生命周期中，最适合与服务端进行数据交互的是哪个函数？"></a>react生命周期中，最适合与服务端进行数据交互的是哪个函数？</h4><p>componentDidMount：在这个阶段，实例和dom已经挂载完成，可以进行相关的dom操作。</p><h4 id="shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）"><a href="#shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）" class="headerlink" title="shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）"></a>shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）</h4><p>询问组件是否需要更新的一个钩子函数，判断数据是否需要重新渲染，返回一个布尔值。默认的返回值是true，需要重新render()。若如果返回值是false则不触发渲染,利用这个生命周期函数可以强制关闭不需要更新的子组件来提升渲染性能。</p><p>这个方法用来判断是否需要调用 render 方法重新描绘 dom。<br>因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</p><h4 id="指出-组件-生命周期方法的不同？"><a href="#指出-组件-生命周期方法的不同？" class="headerlink" title="指出(组件)生命周期方法的不同？"></a>指出(组件)生命周期方法的不同？</h4><p>componentWillMount – 多用于根组件中的应用程序配置<br>componentDidMount – 在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据；如果需要设置事件监听，也可以在这完成<br>componentWillReceiveProps – 这个周期函数作用于特定的 prop 改变导致的 state 转换<br>shouldComponentUpdate – 如果你担心组件过度渲染，shouldComponentUpdate 是一个改善性能的地方，因为如果组件接收了新的 prop， 它可以阻止(组件)重新渲染。shouldComponentUpdate 应该返回一个布尔值来决定组件是否要重新渲染<br>componentWillUpdate – 很少使用。它可以用于代替组件的 componentWillReceiveProps 和 shouldComponentUpdate(但不能访问之前的 props)<br>componentDidUpdate – 常用于更新 DOM，响应 prop 或 state 的改变<br>componentWillUnmount – 在这你可以取消网络请求，或者移除所有与组件相关的事件监听器</p><h4 id="调用-setState-之后发生了什么？"><a href="#调用-setState-之后发生了什么？" class="headerlink" title="调用 setState 之后发生了什么？"></a>调用 setState 之后发生了什么？</h4><p>代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。</p><p>经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面；<br>在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染；<br>在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p><h4 id="react-diff-原理（常考，大厂必考）"><a href="#react-diff-原理（常考，大厂必考）" class="headerlink" title="react diff 原理（常考，大厂必考）"></a>react diff 原理（常考，大厂必考）</h4><p>把树形结构按照层级分解，只比较同级元素。<br>列表结构的每个单元添加唯一的 key 属性，方便比较。<br>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）<br>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.<br>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</p><h4 id="为什么建议传递给-setState-的参数是一个-callback-而不是一个对象？"><a href="#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象？" class="headerlink" title="为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？"></a>为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？</h4><p>因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state</p><h4 id="除了在构造函数中绑定-this，还有其它方式吗？"><a href="#除了在构造函数中绑定-this，还有其它方式吗？" class="headerlink" title="除了在构造函数中绑定 this，还有其它方式吗？"></a>除了在构造函数中绑定 this，还有其它方式吗？</h4><p>你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。<br>在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。</p><h4 id="setState第二个参数的作用"><a href="#setState第二个参数的作用" class="headerlink" title="setState第二个参数的作用?"></a>setState第二个参数的作用?</h4><p>因为setState是一个异步的过程，所以说执行完setState之后不能立刻更改state里面的值。如果需要对state数据更改监听，setState提供第二个参数，就是用来监听state里面数据的更改，当数据更改完成，调用回调函数。</p><h4 id="在构造函数中-调用-super-props-的目的是什么"><a href="#在构造函数中-调用-super-props-的目的是什么" class="headerlink" title="(在构造函数中)调用 super(props) 的目的是什么?"></a>(在构造函数中)调用 super(props) 的目的是什么?</h4><p>在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。<br>传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。</p><h4 id="在-React-当中-Element-和-Component-有何区别？"><a href="#在-React-当中-Element-和-Component-有何区别？" class="headerlink" title="在 React 当中 Element 和 Component 有何区别？"></a>在 React 当中 Element 和 Component 有何区别？</h4><p>React Element 是描述屏幕上所见内容的数据结构，是对于 UI 的对象表述。<br>典型的 React Element 就是利用 JSX 构建的声明式代码片然后被转化为 createElement 的调用组合。</p><p>React Component 是一个函数或一个类，可以接收参数输入，并且返回某个 React Element</p><h4 id="组件的-状态-state-和属性-props-之间有何不同"><a href="#组件的-状态-state-和属性-props-之间有何不同" class="headerlink" title="(组件的)状态(state)和属性(props)之间有何不同?"></a>(组件的)状态(state)和属性(props)之间有何不同?</h4><p>State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。<br>Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。</p><h4 id="受控组件和非受控组件区别"><a href="#受控组件和非受控组件区别" class="headerlink" title="受控组件和非受控组件区别?"></a>受控组件和非受控组件区别?</h4><p>受控组件：<br>1.没有维持自己的状态<br>2.数据由父组件控制<br>3.通过 props 获取当前值，然后通过回调通知更改</p><p>非受控组件：<br>1、保持着自己的状态<br>2、数据由 DOM 控制<br>3、Refs 用于获取其当前值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vue&quot;&gt;&lt;a href=&quot;#vue&quot; class=&quot;headerlink&quot; title=&quot;vue&quot;&gt;&lt;/a&gt;vue&lt;/h3&gt;&lt;h4 id=&quot;一-vue的特点是什么？&quot;&gt;&lt;a href=&quot;#一-vue的特点是什么？&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hook中的API</title>
    <link href="http://example.com/2020/12/26/Hook/"/>
    <id>http://example.com/2020/12/26/Hook/</id>
    <published>2020-12-26T01:02:04.000Z</published>
    <updated>2020-12-30T10:41:37.558Z</updated>
    
    <content type="html"><![CDATA[<p>Hook 是React 16.8的新增特性。它可以让你在不编写 class的情况下使用 state 以及其他的 React特性。<br>   Hook是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数<br>   Hook 不能在 class 组件中使用<br>   <code>const [state, setState] = useState(initialState)</code><br>   返回一个 state,以及更新 state 的函数<br>   当 state 为引用类型，修改时注意要合并其他值，不然会发生错误<br>   多个 state 最好分开写<br>   setState 也可以接收一个函数</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function Home()&#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(0)</span><br><span class="line">    &#x2F;&#x2F;也可以在state里写对象</span><br><span class="line">    const [person, setPerson] &#x3D; useState(&#123;</span><br><span class="line">        name:&#39;大黄&#39;,</span><br><span class="line">        age:&#39;18&#39;,</span><br><span class="line">        sex:&#39;女&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">    const [num,setNum] &#x3D; useState(100)</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            我是todolist</span><br><span class="line">            count:&#123;count&#125;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setCount(count+1)&#125;&#125;&gt;加+&lt;&#x2F;button&gt;</span><br><span class="line">            &#123;&#x2F;* setCount和class组件setState是一样的都是修改state的状态的*&#x2F;&#125;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                name:&#123;person.name&#125;</span><br><span class="line">                age:&#123;person.age&#125;</span><br><span class="line">                sex:&#123;person.sex&#125;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setPerson(&#123;age:19&#125;)&#125;&#125;&gt;给大黄过年&lt;&#x2F;button&gt;</span><br><span class="line">                &#123;&#x2F;* 这里当我们点击了按钮调用setState，只修改了age,虽然年龄变成了19，但是其他属性都为空了，所以说</span><br><span class="line">                    在调用setState时，如果它是个引用类型时我们要它另外值合并一下</span><br><span class="line">                    onClick&#x3D;&#123;()&#x3D;&gt;&#123;setPerson(&#123;age:19,name:person.name,sex:person.sex&#125;)&#125;&#125;</span><br><span class="line">                    这样写就没问题了</span><br><span class="line">                *&#x2F;&#125;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                计数：&#123;num&#125;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setNum((oval)&#x3D;&gt;&#123;console.log(oval);return oval+1&#125;)&#125;&#125;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">                &#123;&#x2F;* setState还可以接收一个函数 *&#x2F;&#125;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">export default Home</span><br></pre></td></tr></table></figure><h1 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;参数是个函数：也叫副作用函数</span><br><span class="line">         return ()&#x3D;&gt;&#123;&#125;&#x2F;&#x2F;返回函数 返回的函数式可选的  可以不写返回函数</span><br><span class="line">     &#125;,[])&#x2F;&#x2F;这里的数组是依赖参数   依赖也是可选的</span><br><span class="line">    作用函数：</span><br><span class="line">     1.当useEffect ,没有依赖参数时，副作用函数，会在组件挂载完成及组件更新完成时执行</span><br><span class="line">     2.当有依赖参数副作用函数，会在组件挂载完成及改依赖参数修改，引起的组件更新完成之后执行</span><br><span class="line">     3.当依赖参数为空数组时，会在组件挂载完成之后执行</span><br><span class="line">     4.返回函数在组件更新完成，或即将写在执行，一般返回函数用在即将卸载时</span><br><span class="line">     useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;当没有依赖参数和返回函数的时候，现在就相当于class组件的componentDidMount、componentUpdate生命周期</span><br><span class="line">    console.log(1,&#39;useEffect&#39;)&#x2F;&#x2F;一直触发btn，一直在打印</span><br><span class="line">&#125;)</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;当依赖参数为空和没有返回函数时，只执行了一次，后面在触发btn时，不在执行.相当于componentDidMount</span><br><span class="line">    console.log(2,&#39;useEffect&#39;)</span><br><span class="line">&#125;,[])</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(3,&#39;useEffect&#39;)</span><br><span class="line">&#125;,[name])&#x2F;&#x2F;在有依赖参数时，组件挂载完会执行一次，在后面触发btn时，如果依赖参数没有发生改变，不会再打印</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">    return ()&#x3D;&gt;&#123;</span><br><span class="line">        console.log(4,&#39;useEffect&#39;)</span><br><span class="line">    &#125;&#x2F;&#x2F;当没有依赖，有返回函数的时候，初次挂载完返回函数不会执行，但是当触发btn时，就是组件发生改变，它就会执行返回函数的代码</span><br><span class="line">&#125;,)&#x2F;&#x2F;如果此处有依赖，但不空，那就当依赖的参数发生改变的时候，返回函数内的代码也会执行</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">    return ()&#x3D;&gt;&#123;</span><br><span class="line">        console.log(&#39;更新或者卸载&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[count])&#x2F;&#x2F;也可以有依赖参数并且会更新用返回函数进行卸载或更新</span><br><span class="line">&#x2F;&#x2F;缺点：挂载前和更新前的生命周期要用到别的方法来配合使用useEffect。这里更多的是挂载完和更新完</span><br></pre></td></tr></table></figure><h1 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h1><p>其函数签名与useEffect相同，但它会在所有的DOM变更之后同步调用effect。可以使用它来读取DOM布局并同步触发重渲染，在浏览器执行绘制之前，useLayoutEffect内部的更新计划将不同步刷新</p><h1 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">一个简单的传参案例基本就能明白useContext是在干神马。</span><br><span class="line">import React,&#123;createContext, useContext&#125; from &#39;react&#39;</span><br><span class="line">const DemoContext &#x3D; createContext(&#123;data:&#39;hello&#39;&#125;)</span><br><span class="line">function A ()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;DemoContext.Provider value&#x3D;&#123;&#123;data:value&#125;&#125;&gt;</span><br><span class="line">            &lt;B&gt;&lt;&#x2F;B&gt;</span><br><span class="line">        &lt;&#x2F;DemoContext.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">function B()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            儿子组件</span><br><span class="line">            &lt;C&gt;&lt;&#x2F;C&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">function C()&#123;</span><br><span class="line">    const text &#x3D; useContext(DemoContext)</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            孙子组件</span><br><span class="line">            &#123;</span><br><span class="line">                text.data</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">export default A</span><br></pre></td></tr></table></figure><h1 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">在我们的需要处理的数据足够简单时，用useState就能完成。如果数据比较复杂了那么就可以考虑用useReducer</span><br><span class="line">这个先说下useReducer跟Store没关系，他只是借用了store的那套思想</span><br><span class="line">直接上案例</span><br><span class="line">import React, &#123; useState, useEffect, useReducer, useRef &#125; from &#39;react&#39;</span><br><span class="line">import &#123; withRouter &#125; from &#39;react-router-dom&#39;</span><br><span class="line">import &#123; connect &#125; from &#39;react-redux&#39;</span><br><span class="line">import s from &#39;.&#x2F;index.module.scss&#39;</span><br><span class="line">let init &#x3D; &#123; list: [&#123;</span><br><span class="line">    id:1,</span><br><span class="line">    name:&#39;澳门豆捞&#39;,</span><br><span class="line">    open:1</span><br><span class="line">&#125;] &#125;</span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &#39;add&#39;:</span><br><span class="line">            let arr &#x3D; JSON.parse(JSON.stringify(state.list)) </span><br><span class="line">            arr.push(&#123;</span><br><span class="line">                id: state.list.length &gt; 0 ? state.list[state.list.length-1].id + 1 : 1,</span><br><span class="line">                name: action.name,</span><br><span class="line">                open: 1,</span><br><span class="line">            &#125;)</span><br><span class="line">            return &#123;list:arr&#125;</span><br><span class="line">        case &#39;close&#39;:</span><br><span class="line">           for(let i&#x3D;0;i&lt;state.list.length;i++)&#123;</span><br><span class="line">               if(state.list[i].id&#x3D;&#x3D;action.id)&#123;</span><br><span class="line">                   state.list[i].open&#x3D;2</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return JSON.parse(JSON.stringify(state))</span><br><span class="line">        case &#39;open&#39;:</span><br><span class="line">           for(let i&#x3D;0;i&lt;state.list.length;i++)&#123;</span><br><span class="line">               if(state.list[i].id&#x3D;&#x3D;action.id)&#123;</span><br><span class="line">                   state.list[i].open&#x3D;1</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return JSON.parse(JSON.stringify(state))</span><br><span class="line">        case &#39;set&#39;:</span><br><span class="line">           for(let i&#x3D;0;i&lt;state.list.length;i++)&#123;</span><br><span class="line">               if(state.list[i].id&#x3D;&#x3D;action.id)&#123;</span><br><span class="line">                   state.list[i].open&#x3D;3</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return JSON.parse(JSON.stringify(state))</span><br><span class="line">        case &#39;del&#39;:</span><br><span class="line">           for(let i&#x3D;0;i&lt;state.list.length;i++)&#123;</span><br><span class="line">               if(state.list[i].id&#x3D;&#x3D;action.id)&#123;</span><br><span class="line">                   state.list.splice(i,1)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return JSON.parse(JSON.stringify(state))</span><br><span class="line">        default:</span><br><span class="line">            return state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Homet(props) &#123;</span><br><span class="line">    const inp &#x3D; useRef(null)</span><br><span class="line">    const [state, dispatch] &#x3D; useReducer(reducer, init)</span><br><span class="line">    function btn() &#123;</span><br><span class="line">        if (!inp.current.value) &#123;</span><br><span class="line">            alert(&#39;输入不能为空&#39;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: &#39;add&#39;,</span><br><span class="line">                name: inp.current.value,</span><br><span class="line">            &#125;)</span><br><span class="line">            inp.current.value&#x3D;null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div className&#x3D;&#123;s.homet&#125;&gt;</span><br><span class="line">            &lt;div className&#x3D;&#123;s.head&#125;&gt;</span><br><span class="line">                &lt;span&gt;Todo后台管理&lt;&#x2F;span&gt;</span><br><span class="line">                &lt;div className&#x3D;&#123;s.inpBox&#125;&gt;</span><br><span class="line">                    &lt;input ref&#x3D;&#123;inp&#125; placeholder&#x3D;&#39;请输入内容&#39; &#x2F;&gt;</span><br><span class="line">                    &lt;button onClick&#x3D;&#123;() &#x3D;&gt; btn()&#125; className&#x3D;&#123;s.btn&#125;&gt;添加&lt;&#x2F;button&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div className&#x3D;&#123;s.cont&#125;&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    state.list.length &gt; 0 ? state.list.map((item, i) &#x3D;&gt; &lt;div className&#x3D;&#123;s.item&#125; key&#x3D;&#123;i&#125;&gt;</span><br><span class="line">                        &lt;img &#x2F;&gt;</span><br><span class="line">                        &lt;div className&#x3D;&#123;s.all&#125;&gt;</span><br><span class="line">                            &lt;span className&#x3D;&#123;s.name&#125;&gt;&#123;item.name&#125;&lt;&#x2F;span&gt;</span><br><span class="line">                            &lt;span&gt;&#123;item.open &#x3D;&#x3D; 1 ? &#39;营业中&#39; : item.open &#x3D;&#x3D; 2 ? &#39;已打烊&#39; : &#39;装修中&#39;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">                        &lt;&#x2F;div&gt;</span><br><span class="line">                        &lt;div className&#x3D;&#123;s.del&#125;&gt;</span><br><span class="line">                            &#123;</span><br><span class="line">                                item.open &#x3D;&#x3D; 1 ? &lt;div className&#x3D;&#123;s.btnBox&#125;&gt;</span><br><span class="line">                                    &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;close&#39;,id:item.id&#125;)&#125; className&#x3D;&#123;s.margin&#125;&gt;打烊&lt;&#x2F;button&gt;</span><br><span class="line">                                    &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;set&#39;,id:item.id&#125;)&#125;&gt;装修&lt;&#x2F;button&gt;</span><br><span class="line">                                &lt;&#x2F;div&gt; : item.open &#x3D;&#x3D; 2 ? &lt;div className&#x3D;&#123;s.btnBox&#125;&gt;</span><br><span class="line">                                    &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;open&#39;,id:item.id&#125;)&#125; className&#x3D;&#123;s.margin&#125;&gt;营业&lt;&#x2F;button&gt;</span><br><span class="line">                                    &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;set&#39;,id:item.id&#125;)&#125;&gt;装修&lt;&#x2F;button&gt;</span><br><span class="line">                                &lt;&#x2F;div&gt; : &lt;div className&#x3D;&#123;s.btnBox&#125;&gt;</span><br><span class="line">                                            &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;open&#39;,id:item.id&#125;)&#125; className&#x3D;&#123;s.margin&#125;&gt;营业&lt;&#x2F;button&gt;</span><br><span class="line">                                            &lt;button&gt;待完成&lt;&#x2F;button&gt;</span><br><span class="line">                                        &lt;&#x2F;div&gt;</span><br><span class="line">                            &#125;</span><br><span class="line">                            &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;del&#39;,id:item.id&#125;)&#125; className&#x3D;&#123;s.shan&#125;&gt;删除&lt;&#x2F;button&gt;</span><br><span class="line">                        &lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;) : &lt;span className&#x3D;&#123;s.no&#125;&gt;暂无数据&lt;&#x2F;span&gt;</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">let mapStateToProps &#x3D; (state) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(state)</span><br><span class="line">    return &#123;</span><br><span class="line">        list: state.list.list</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let mapDispatchToProps &#x3D; (dispatch) &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Homet &#x3D; withRouter(Homet)</span><br><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(Homet)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hook 是React 16.8的新增特性。它可以让你在不编写 class的情况下使用 state 以及其他的 React特性。&lt;br&gt;   Hook是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数&lt;br&gt;   Hook 不能在 class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/12/25/hello-world/"/>
    <id>http://example.com/2020/12/25/hello-world/</id>
    <published>2020-12-25T01:36:20.562Z</published>
    <updated>2020-12-25T01:36:20.562Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简易防抖节流</title>
    <link href="http://example.com/2019/03/12/%E7%AE%80%E6%98%93%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>http://example.com/2019/03/12/%E7%AE%80%E6%98%93%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</id>
    <published>2019-03-12T10:28:25.000Z</published>
    <updated>2021-01-12T11:32:57.251Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var inp &#x3D; document.querySelector(&#39;.inp&#39;)</span><br><span class="line">    function fn(callBack,num)&#123;</span><br><span class="line">        let timer ;</span><br><span class="line">        return function ()&#123;</span><br><span class="line">            if(timer) clearTimeout(timer)</span><br><span class="line">            timer &#x3D; setTimeout(callBack,num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function handel()&#123;</span><br><span class="line">        console.log(&#39;函数防抖&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    inp.addEventListener(&#39;keyup&#39;,fn(handel,1000))</span><br></pre></td></tr></table></figure><h3 id="节流-在N秒内函数执行一次"><a href="#节流-在N秒内函数执行一次" class="headerlink" title="节流 在N秒内函数执行一次"></a>节流 在N秒内函数执行一次</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var inp &#x3D; document.queruSelector(&#39;.inp&#39;)</span><br><span class="line">    function fn(callBack,num)&#123;</span><br><span class="line">        let lock &#x3D; true</span><br><span class="line">        return function ()&#123;</span><br><span class="line">            lock &#x3D; false</span><br><span class="line">            setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">                lock&#x3D;true</span><br><span class="line">                callBack</span><br><span class="line">            &#125;,num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function handel()&#123;</span><br><span class="line">        console.log(&#39;节流&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    inp.addEventListener(&#39;click&#39;,fn(handel,1000))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;函数防抖&quot;&gt;&lt;a href=&quot;#函数防抖&quot; class=&quot;headerlink&quot; title=&quot;函数防抖&quot;&gt;&lt;/a&gt;函数防抖&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>history</title>
    <link href="http://example.com/2018/11/28/history/"/>
    <id>http://example.com/2018/11/28/history/</id>
    <published>2018-11-28T09:43:06.000Z</published>
    <updated>2021-01-28T10:00:22.160Z</updated>
    
    <content type="html"><![CDATA[<h4 id="history-接口允许操作浏览器的曾经在标签页或者框架里访问的绘画历史记录。"><a href="#history-接口允许操作浏览器的曾经在标签页或者框架里访问的绘画历史记录。" class="headerlink" title="history:接口允许操作浏览器的曾经在标签页或者框架里访问的绘画历史记录。"></a>history:接口允许操作浏览器的曾经在标签页或者框架里访问的绘画历史记录。</h4><p>history不继承任何接口。就是它不需要别的接口来调用它，想使用它直接使用就行。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol><li>history.length :它返回一个整数，该整数表示会话历史中元素的数目，包括当前加载的页。</li><li>history.scrollRestorration:允许Web应用程序在历史导航上显式地设置默认滚动恢复行为。此属性可以是自动的或者手动的</li><li>history.state:返回一个表示历史堆栈顶部的状态的值，这是一种可以不必等待popstate事件而查看状态的事件<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3></li><li>history.back() 在浏览器历史记录里前往上一页，用户可点击浏览器左上角的返回 等同于 history.go(-1)</li><li>history.forward() 在浏览器历史记录里前往下一页，用户可点击浏览器左上角的前进 等同于history.go(1)</li><li>history.pushState() 按指定的名称和URL（如果提供该参数）将数据push进会话历史栈，数据被DOM进行不透明处理；你可以指定任何可以被序列化的javascript对象。注意到Firefox现在忽略了这个title参数</li><li>history.replaceState() 按指定的数据，名称和URL(如果提供该参数)，更新历史栈上最新的入口。这个数据被DOM 进行了不透明处理。你可以指定任何可以被序列化的javascript对象。注意到Firefox现在忽略了这个title参数</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;history-接口允许操作浏览器的曾经在标签页或者框架里访问的绘画历史记录。&quot;&gt;&lt;a href=&quot;#history-接口允许操作浏览器的曾经在标签页或者框架里访问的绘画历史记录。&quot; class=&quot;headerlink&quot; title=&quot;history:接口允许操作</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Proxy</title>
    <link href="http://example.com/2018/10/11/Proxy/"/>
    <id>http://example.com/2018/10/11/Proxy/</id>
    <published>2018-10-11T12:54:45.000Z</published>
    <updated>2021-01-28T09:43:51.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="async函数默认返回一个Promise对象"><a href="#async函数默认返回一个Promise对象" class="headerlink" title="async函数默认返回一个Promise对象"></a>async函数默认返回一个Promise对象</h2><h3 id="proxy-对对象操作进行拦截"><a href="#proxy-对对象操作进行拦截" class="headerlink" title="proxy 对对象操作进行拦截"></a>proxy 对对象操作进行拦截</h3><h4 id="new-Proxy-接受两个参数，第一个是目标对象，另一个是拦截方法"><a href="#new-Proxy-接受两个参数，第一个是目标对象，另一个是拦截方法" class="headerlink" title="new Proxy()接受两个参数，第一个是目标对象，另一个是拦截方法"></a>new Proxy()接受两个参数，第一个是目标对象，另一个是拦截方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">        name:&#39;hello&#39;,</span><br><span class="line">        age:&#39;18&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;相当于proxy1代理了obj,需要通过proxy1 去操作代理的obj</span><br><span class="line">    let proxy1 &#x3D; new Proxy(obj,&#123;</span><br><span class="line">        get(target,key,proxy)&#123;&#x2F;&#x2F;get 方法只要是对对象进行获取操作就会触发get方法</span><br><span class="line">            console.log(arguments)&#x2F;&#x2F;得到target:目标对象和key:name属性名，以及proxy实例</span><br><span class="line">            &#x2F;&#x2F;这里return什么，就会返回什么，如果没有return，就是undefined</span><br><span class="line">            console.log(&#39;触发了&#39;)</span><br><span class="line">            return target[key]&#x2F;&#x2F;返回属性name的值</span><br><span class="line">    &#125;&#125;)</span><br><span class="line">    console.log(proxy1.name)&#x2F;&#x2F;&#39;触发了&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proxy 用于修改某些操作默认行为，等同于在语言层面做出修改，所以属于一种‘元编程’(meta progrmming),即对编程语言进行编程。</span><br><span class="line">Proxy 可以理解成，在目标对象之前架设一层‘拦截’，外界对该对象的访问，都必须先通过这层拦截，因此提供一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由他来‘代理’某些操作，可以译为‘代理器’。</span><br></pre></td></tr></table></figure><h3 id="为什么需要-Proxy"><a href="#为什么需要-Proxy" class="headerlink" title="为什么需要 Proxy"></a>为什么需要 Proxy</h3><p>1.被代理的对象不想直接被访问<br>2.控制和修改被代理对象的行为（调用属性、属性赋值、方法调用等等），使之可以进行访问控制和增加功能。</p><p>API 概览如下：</p><p>get(target, propKey, receiver)：拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’] 。<br>set(target, propKey, value, receiver)：拦截对象属性的设置，比如 proxy.foo = v 或 proxy[‘foo’] = v ，返回一个布尔值。<br>has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。<br>deleteProperty(target, propKey)：拦截 delete proxy[propKey]的操作，返回一个布尔值。<br>ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy) 、 Object.getOwnPropertySymbols(proxy) 、 Object.keys(proxy) 、 for…in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。<br>getOwnPropertyDescriptor(target, propKey)：拦截 Object.getOwnPropertyDescriptor(proxy, propKey) ，返回属性的描述对象。<br>defineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc） 、<br>Object.defineProperties(proxy, propDescs)，返回一个布尔值。<br>preventExtensions(target)：拦截 Object.preventExtensions(proxy) ，返回一个布尔值。<br>getPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy)，返回一个对象 。<br>isExtensible(target)：拦截 Object.isExtensible(proxy) ，返回一个布尔值。<br>setPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto) ，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。<br>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如 proxy(…args)、proxy.call(object, …args)、proxy.apply(…)`。<br>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(…args) 。</p><h4 id="最常用的一般就是-get-和set"><a href="#最常用的一般就是-get-和set" class="headerlink" title="最常用的一般就是 get()和set()"></a>最常用的一般就是 get()和set()</h4><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p><p>get方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">  name: &quot;张三&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var proxy &#x3D; new Proxy(person, &#123;</span><br><span class="line">  get: function(target, propKey) &#123;</span><br><span class="line">    if (propKey in target) &#123;</span><br><span class="line">      return target[propKey];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new ReferenceError(&quot;Prop name \&quot;&quot; + propKey + &quot;\&quot; does not exist.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name &#x2F;&#x2F; &quot;张三&quot;</span><br><span class="line">proxy.age &#x2F;&#x2F; 抛出一个错误</span><br><span class="line">上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">get方法可以继承。</span><br><span class="line">let proto &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get(target, propertyKey, receiver) &#123;</span><br><span class="line">    console.log(&#39;GET &#39; + propertyKey);</span><br><span class="line">    return target[propertyKey];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let obj &#x3D; Object.create(proto);</span><br><span class="line">obj.foo &#x2F;&#x2F; &quot;GET foo&quot;</span><br><span class="line">上面代码中，拦截操作定义在Prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">下面的例子使用get拦截，实现数组读取负数的索引。</span><br><span class="line">function createArray(...elements) &#123;</span><br><span class="line">  let handler &#x3D; &#123;</span><br><span class="line">    get(target, propKey, receiver) &#123;</span><br><span class="line">      let index &#x3D; Number(propKey);</span><br><span class="line">      if (index &lt; 0) &#123;</span><br><span class="line">        propKey &#x3D; String(target.length + index);</span><br><span class="line">      &#125;</span><br><span class="line">      return Reflect.get(target, propKey, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  let target &#x3D; [];</span><br><span class="line">  target.push(...elements);</span><br><span class="line">  return new Proxy(target, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr &#x3D; createArray(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);</span><br><span class="line">arr[-1] &#x2F;&#x2F; c</span><br><span class="line">上面代码中，数组的位置参数是-1，就会输出数组的倒数第一个成员。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。</span><br><span class="line">var pipe &#x3D; function (value) &#123;</span><br><span class="line">  var funcStack &#x3D; [];</span><br><span class="line">  var oproxy &#x3D; new Proxy(&#123;&#125; , &#123;</span><br><span class="line">    get : function (pipeObject, fnName) &#123;</span><br><span class="line">      if (fnName &#x3D;&#x3D;&#x3D; &#39;get&#39;) &#123;</span><br><span class="line">        return funcStack.reduce(function (val, fn) &#123;</span><br><span class="line">          return fn(val);</span><br><span class="line">        &#125;,value);</span><br><span class="line">      &#125;</span><br><span class="line">      funcStack.push(window[fnName]);</span><br><span class="line">      return oproxy;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return oproxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var double &#x3D; n &#x3D;&gt; n * 2;</span><br><span class="line">var pow    &#x3D; n &#x3D;&gt; n * n;</span><br><span class="line">var reverseInt &#x3D; n &#x3D;&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0;</span><br><span class="line"></span><br><span class="line">pipe(3).double.pow.reverseInt.get; &#x2F;&#x2F; 63</span><br><span class="line">上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">下面的例子则是利用get拦截，实现一个生成各种 DOM 节点的通用函数dom。</span><br><span class="line">const dom &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get(target, property) &#123;</span><br><span class="line">    return function(attrs &#x3D; &#123;&#125;, ...children) &#123;</span><br><span class="line">      const el &#x3D; document.createElement(property);</span><br><span class="line">      for (let prop of Object.keys(attrs)) &#123;</span><br><span class="line">        el.setAttribute(prop, attrs[prop]);</span><br><span class="line">      &#125;</span><br><span class="line">      for (let child of children) &#123;</span><br><span class="line">        if (typeof child &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">          child &#x3D; document.createTextNode(child);</span><br><span class="line">        &#125;</span><br><span class="line">        el.appendChild(child);</span><br><span class="line">      &#125;</span><br><span class="line">      return el;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const el &#x3D; dom.div(&#123;&#125;,</span><br><span class="line">  &#39;Hello, my name is &#39;,</span><br><span class="line">  dom.a(&#123;href: &#39;&#x2F;&#x2F;example.com&#39;&#125;, &#39;Mark&#39;),</span><br><span class="line">  &#39;. I like:&#39;,</span><br><span class="line">  dom.ul(&#123;&#125;,</span><br><span class="line">    dom.li(&#123;&#125;, &#39;The web&#39;),</span><br><span class="line">    dom.li(&#123;&#125;, &#39;Food&#39;),</span><br><span class="line">    dom.li(&#123;&#125;, &#39;…actually that\&#39;s it&#39;)</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">document.body.appendChild(el);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">下面是一个get方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</span><br><span class="line">const proxy &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function(target, key, receiver) &#123;</span><br><span class="line">    return receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.getReceiver &#x3D;&#x3D;&#x3D; proxy &#x2F;&#x2F; true</span><br><span class="line">上面代码中，proxy对象的getReceiver属性是由proxy对象提供的，所以receiver指向proxy对象。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const proxy &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function(target, key, receiver) &#123;</span><br><span class="line">    return receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const d &#x3D; Object.create(proxy);</span><br><span class="line">d.a &#x3D;&#x3D;&#x3D; d &#x2F;&#x2F; true</span><br><span class="line">上面代码中，d对象本身没有a属性，所以读取d.a的时候，会去d的原型proxy对象找。这时，receiver就指向d，代表原始的读操作所在的那个对象。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</span><br><span class="line">const target &#x3D; Object.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    value: 123,</span><br><span class="line">    writable: false,</span><br><span class="line">    configurable: false</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const handler &#x3D; &#123;</span><br><span class="line">  get(target, propKey) &#123;</span><br><span class="line">    return &#39;abc&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">proxy.foo</span><br><span class="line">&#x2F;&#x2F; TypeError: Invariant check failed</span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let obj&#x3D;&#123;</span><br><span class="line">        name:&#39;hello world&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">    let proxy2 &#x3D; new Proxy(obj,&#123;</span><br><span class="line">        get(target,key,receiver)&#123;</span><br><span class="line">            return target[key]&#x2F;&#x2F;获取想要得到的属性</span><br><span class="line">        &#125;,</span><br><span class="line">        set(target,key,value,receiver)&#123;</span><br><span class="line">            console.log(&#39;要设置&#39;)</span><br><span class="line">            console.log(arguments)</span><br><span class="line">            &#x2F;&#x2F;key这里就是要设置的那个age属性</span><br><span class="line">            target[key]&#x3D;value</span><br><span class="line">            return true &#x2F;&#x2F;最后返回一个布尔值</span><br><span class="line">        &#125;,</span><br><span class="line">        has(target,key)&#123;&#x2F;&#x2F;拦截in这个操作。接收两个参数，目标对象和判断的那个属性名</span><br><span class="line">            if(key.startsWith(&#39;_&#39;))&#123;&#x2F;&#x2F;判断下是否是带__的属性比如&#39;__proto__&#39;</span><br><span class="line">                return false</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return key in target</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    proxy2.age&#x3D;10&#x2F;&#x2F;这里我们想要给obj设置一个age为10的属性</span><br><span class="line">    console.log(obj)</span><br><span class="line">    console.log(&#39;name&#39; in proxy2)</span><br></pre></td></tr></table></figure><h3 id="apply-拦截实例作为函数调用的时候：proxy3"><a href="#apply-拦截实例作为函数调用的时候：proxy3" class="headerlink" title="apply()//拦截实例作为函数调用的时候：proxy3()"></a>apply()//拦截实例作为函数调用的时候：proxy3()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function query()&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">        return &#123;name:&#39;hello world&#39;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let obj &#x3D; &#123;name:&#39;北京&#39;&#125;</span><br><span class="line">    let proxy3 &#x3D; new Proxy(query,&#123;</span><br><span class="line">        apply(target,object,args)&#123;</span><br><span class="line">            &#x2F;&#x2F;函数直接执行()、通过call执行、apply执行，都会触发此处。</span><br><span class="line">            &#x2F;&#x2F;object 给函数修改this</span><br><span class="line">            &#x2F;&#x2F; args 函数执行的参数</span><br><span class="line">            console.log(&#39;执行&#39;)</span><br><span class="line">            console.log(target,object,args)</span><br><span class="line">            if(object)&#123;</span><br><span class="line">                object.fn&#x3D;target</span><br><span class="line">                object.fn(...args)</span><br><span class="line">                delete object.fn</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                target(...args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    proxy3()</span><br><span class="line">    console.log(proxy3.call(obj,1,2,3))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;async函数默认返回一个Promise对象&quot;&gt;&lt;a href=&quot;#async函数默认返回一个Promise对象&quot; class=&quot;headerlink&quot; title=&quot;async函数默认返回一个Promise对象&quot;&gt;&lt;/a&gt;async函数默认返回一个Promise</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>属性描述符</title>
    <link href="http://example.com/2018/10/02/%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
    <id>http://example.com/2018/10/02/%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/</id>
    <published>2018-10-02T13:59:58.000Z</published>
    <updated>2021-01-03T05:51:03.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>Object.defineProperty(obj,prop,desctiptor)接受3个参数。<br>obj:接受一个对象、prop:定义或修改的属性或Smybol、descriptor:属性描述符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> let obj &#x3D;&#123;</span><br><span class="line">    name:&#39;hello&#39;</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(obj,&#39;sex&#39;,&#123;value:&#39;world&#39;&#125;)</span><br><span class="line">console.log(Object.keys(obj))</span><br><span class="line">&#x2F;&#x2F;只拿到了name 因为用上面定义的方法给对象添加的属性是不可枚举的所以它并不能被拿到</span><br></pre></td></tr></table></figure><p>对象里目前存在属性描述符有两种主要形式：数据描述符合存取描述符。<br>数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。<br>存取描述符是由getter函数和setter函数所描述的属性。一个描述符只能是这两种其中之一，不能同时是两者<br>这两种描述符都是对象。他们共享一下可选键值(默认值是指咋使用Object.definPropety()定义属性时的默认值)<br>configurable<br>当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。<br>默认为 false。<br>enumerable<br>当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。<br>默认为 false。<br>数据描述符还具有以下可选键值：</p><p>value<br>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。<br>默认为 undefined。<br>writable<br>当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变。<br>默认为 false。<br>存取描述符还具有以下可选键值：</p><p>get<br>属性的 getter 函数，如果没有 getter，则为 undefined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。<br>默认为 undefined。<br>set<br>属性的 setter 函数，如果没有 setter，则为 undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。<br>默认为 undefined。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; &#123;&#125;; &#x2F;&#x2F; 创建一个新对象</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在对象中添加一个属性与数据描述符的示例</span><br><span class="line">Object.defineProperty(o, &quot;a&quot;, &#123;</span><br><span class="line">  value : 37,</span><br><span class="line">  writable : true,</span><br><span class="line">  enumerable : true,</span><br><span class="line">  configurable : true</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象 o 拥有了属性 a，值为 37</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在对象中添加一个设置了存取描述符属性的示例</span><br><span class="line">var bValue &#x3D; 38;</span><br><span class="line">Object.defineProperty(o, &quot;b&quot;, &#123;</span><br><span class="line">  &#x2F;&#x2F; 使用了方法名称缩写（ES2015 特性）</span><br><span class="line">  &#x2F;&#x2F; 下面两个缩写等价于：</span><br><span class="line">  &#x2F;&#x2F; get : function() &#123; return bValue; &#125;,</span><br><span class="line">  &#x2F;&#x2F; set : function(newValue) &#123; bValue &#x3D; newValue; &#125;,</span><br><span class="line">  get() &#123; return bValue; &#125;,</span><br><span class="line">  set(newValue) &#123; bValue &#x3D; newValue; &#125;,</span><br><span class="line">  enumerable : true,</span><br><span class="line">  configurable : true</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.b; &#x2F;&#x2F; 38</span><br><span class="line">&#x2F;&#x2F; 对象 o 拥有了属性 b，值为 38</span><br><span class="line">&#x2F;&#x2F; 现在，除非重新定义 o.b，o.b 的值总是与 bValue 相同</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数据描述符和存取描述符不能混合使用</span><br><span class="line">Object.defineProperty(o, &quot;conflict&quot;, &#123;</span><br><span class="line">  value: 0x9f91102,</span><br><span class="line">  get() &#123; return 0xdeadbeef; &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 抛出错误 TypeError: value appears only in data descriptors, get appears only in accessor descriptors</span><br></pre></td></tr></table></figure><h2 id="自定义-Setters-和-Getters"><a href="#自定义-Setters-和-Getters" class="headerlink" title="自定义 Setters 和 Getters"></a>自定义 Setters 和 Getters</h2><p>下面的例子展示了如何实现一个自存档对象。当设置temperature 属性时，archive 数组会收到日志条目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Archiver() &#123;</span><br><span class="line">  var temperature &#x3D; null;</span><br><span class="line">  var archive &#x3D; [];</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(this, &#39;temperature&#39;, &#123;</span><br><span class="line">    get: function() &#123;</span><br><span class="line">      console.log(&#39;get!&#39;);</span><br><span class="line">      return temperature;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(value) &#123;</span><br><span class="line">      temperature &#x3D; value;</span><br><span class="line">      archive.push(&#123; val: temperature &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  this.getArchive &#x3D; function() &#123; return archive; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arc &#x3D; new Archiver();</span><br><span class="line">arc.temperature; &#x2F;&#x2F; &#39;get!&#39;</span><br><span class="line">arc.temperature &#x3D; 11;</span><br><span class="line">arc.temperature &#x3D; 13;</span><br><span class="line">arc.getArchive(); &#x2F;&#x2F; [&#123; val: 11 &#125;, &#123; val: 13 &#125;]</span><br></pre></td></tr></table></figure><h2 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h2><p>如果访问者的属性是被继承的，它的 get 和 set 方法会在子对象的属性被访问或者修改时被调用。如果这些方法用一个变量存值，该值会被所有对象共享。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function myclass() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var value;</span><br><span class="line">Object.defineProperty(myclass.prototype, &quot;x&quot;, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;,</span><br><span class="line">  set(x) &#123;</span><br><span class="line">    value &#x3D; x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var a &#x3D; new myclass();</span><br><span class="line">var b &#x3D; new myclass();</span><br><span class="line">a.x &#x3D; 1;</span><br><span class="line">console.log(b.x); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><h1 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h1><p>Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let obj1 &#x3D; &#123;</span><br><span class="line">    name:&#39;hong&#39;,</span><br><span class="line">    sex:&#39;女&#39;</span><br><span class="line">&#125;</span><br><span class="line">let obj2 &#x3D; &#123;</span><br><span class="line">    age:&#39;18&#39;,</span><br><span class="line">    get sayName()&#123;</span><br><span class="line">        return &#39;hong&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let obj3 &#x3D; Object.assign(&#123;&#125;,obj1,obj2)</span><br><span class="line">console.log(obj3)&#x2F;&#x2F;此时合并完，就会把obj2里的存取属性给变成了数据属性</span><br><span class="line">&#x2F;&#x2F;应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。</span><br></pre></td></tr></table></figure><h3 id="异常会打断后续拷贝任务"><a href="#异常会打断后续拷贝任务" class="headerlink" title="异常会打断后续拷贝任务"></a>异常会打断后续拷贝任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const target &#x3D; Object.defineProperty(&#123;&#125;, &quot;foo&quot;, &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    writable: false</span><br><span class="line">&#125;); &#x2F;&#x2F; target 的 foo 属性是个只读属性。</span><br><span class="line"></span><br><span class="line">Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);</span><br><span class="line">&#x2F;&#x2F; TypeError: &quot;foo&quot; is read-only</span><br><span class="line">&#x2F;&#x2F; 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</span><br><span class="line"></span><br><span class="line">console.log(target.bar);  &#x2F;&#x2F; 2，说明第一个源对象拷贝成功了。</span><br><span class="line">console.log(target.foo2); &#x2F;&#x2F; 3，说明第二个源对象的第一个属性也拷贝成功了。</span><br><span class="line">console.log(target.foo);  &#x2F;&#x2F; 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span><br><span class="line">console.log(target.foo3); &#x2F;&#x2F; undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span><br><span class="line">console.log(target.baz);  &#x2F;&#x2F; undefined，第三个源对象更是不会被拷贝到的。</span><br></pre></td></tr></table></figure><h2 id="拷贝访问器-手动实现你原来是个存取属性，现在通过Object-assign-拷贝过来还是存取属性"><a href="#拷贝访问器-手动实现你原来是个存取属性，现在通过Object-assign-拷贝过来还是存取属性" class="headerlink" title="拷贝访问器(手动实现你原来是个存取属性，现在通过Object.assign()拷贝过来还是存取属性)"></a>拷贝访问器(手动实现你原来是个存取属性，现在通过Object.assign()拷贝过来还是存取属性)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  get bar() &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let copy &#x3D; Object.assign(&#123;&#125;, obj);</span><br><span class="line">console.log(copy); &#x2F;&#x2F; &#123; foo: 1, bar: 2 &#125; copy.bar的值来自obj.bar的getter函数的返回值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面这个函数会拷贝所有自有属性的属性描述符</span><br><span class="line">function completeAssign(target, ...sources) &#123;</span><br><span class="line">  sources.forEach(source &#x3D;&gt; &#123;</span><br><span class="line">    let descriptors &#x3D; Object.keys(source).reduce((descriptors, key) &#x3D;&gt; &#123;</span><br><span class="line">      descriptors[key] &#x3D; Object.getOwnPropertyDescriptor(source, key);</span><br><span class="line">      return descriptors;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Object.assign 默认也会拷贝可枚举的Symbols</span><br><span class="line">    Object.getOwnPropertySymbols(source).forEach(sym &#x3D;&gt; &#123;</span><br><span class="line">      let descriptor &#x3D; Object.getOwnPropertyDescriptor(source, sym);</span><br><span class="line">      if (descriptor.enumerable) &#123;</span><br><span class="line">        descriptors[sym] &#x3D; descriptor;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Object.defineProperties(target, descriptors);</span><br><span class="line">  &#125;);</span><br><span class="line">  return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copy &#x3D; completeAssign(&#123;&#125;, obj);</span><br><span class="line">console.log(copy);</span><br><span class="line">&#x2F;&#x2F; &#123; foo:1, get bar() &#123; return 2 &#125; &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Object-defineProperty&quot;&gt;&lt;a href=&quot;#Object-defineProperty&quot; class=&quot;headerlink&quot; title=&quot;Object.defineProperty&quot;&gt;&lt;/a&gt;Object.defineProperty&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>express</title>
    <link href="http://example.com/2018/08/30/express/"/>
    <id>http://example.com/2018/08/30/express/</id>
    <published>2018-08-30T13:57:46.000Z</published>
    <updated>2020-12-30T11:58:53.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单使用express"><a href="#简单使用express" class="headerlink" title="简单使用express"></a>简单使用express</h1><p>首先安装 npm i express 、body-parser (post请求需要用到)</p><p>1.分别引用：import express from ‘express’;(如果没有引用bable,可以用require()引用)</p><p>import baodyParser from ‘body-parser’;</p><p>import fs from ‘fs’</p><p>import path from ‘path’</p><ol start="2"><li><p>const app=express() //创建一个express应用</p></li><li><p>const post=3000 端口号</p></li><li><p>用一下body-parser :app.use(bodyParser.json())</p></li></ol><p>app.use(bodyParser.urlencoded({extended:false}))</p><p>下面就可以使用 get post 进行请求了</p><p>app.post(‘/post’,(req,res)=&gt;{</p><p>　　</p><p>})</p><p>app.get(‘/gett’,(req,res)=&gt;{</p><p>　　</p><p>})</p><p>app.listen(post,()=&gt;{//监听端口号</p><p> 　　console.log(post)</p><p>})</p><p> 题外：1.关于express中间件的简单概述：在use(),get(),post()等方法里面是都可以使用中间件的。写法：app.user((req,res,next)=&gt;{</p><p>　　console.log(‘继续往下走’)</p><p>　　next()//如果不写next它是不会继续执行下面代码的</p><p>　　由此可简单说一个例子：就是有了这个中间件我们可以把一些公共逻辑放在use()方法中来执行，如果可行就next()继续往下走，否则停止本次请求。因为use()方法不管什么请求都会走进来！我们可以在这里进行账号密码的校验，因为不论登录还是注册都是要校验的，所以不可能登录和注册的接口都要写一遍校验。这个时候我们可以把校验这段逻辑放在use()方法中，如果校验通过就可以继续请求，否则直接停止。所以有了它就可以减少代码冗余问题。</p><p>})</p><p>　　2. express 重定向：使用 express.get(‘*’,(req,res)=&gt;{//就是当所有的请求都找不到时，给它重定向到一个专门的404页面。第一个参数是 *（通配符 所有），后面依然是回调函数</p><p>　　express.redirect(‘404.网页’)//用redirect方法做重定向</p><p>})</p><p>　　3. 请求对象req的方法：</p><p>　　　　req.body :获取post请求体的数据</p><p>　　　　req.query获取get请求的数据</p><p>　　　　req.originnalUrl 获取原始url地址、当需要处理路径的时候可以还可以用req.baseUrl，req.path  这三个方法是可以操作url的。</p><p>　　　　req.get(‘Content-type’)用来获取请求头</p><p>　　4. 响应对象res的方法：</p><p>　　　　res.set(‘key’,value)设置响应头  key:响应头的字段名称  。 value:值。</p><p>　　　　res.send()发送数据</p><p>　　　　res.senfFile()发送文件</p><p>　　　　res.redirect()重新定向 参数是文件的地址</p><p>　　　　res.download()下载</p><p>　　　　res.jsonp()以jsonp的方式返回数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简单使用express&quot;&gt;&lt;a href=&quot;#简单使用express&quot; class=&quot;headerlink&quot; title=&quot;简单使用express&quot;&gt;&lt;/a&gt;简单使用express&lt;/h1&gt;&lt;p&gt;首先安装 npm i express 、body-parser (p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>手写Promise</title>
    <link href="http://example.com/2018/05/25/%E6%89%8B%E5%86%99Promise/"/>
    <id>http://example.com/2018/05/25/%E6%89%8B%E5%86%99Promise/</id>
    <published>2018-05-25T14:10:50.000Z</published>
    <updated>2020-12-27T12:35:16.339Z</updated>
    
    <content type="html"><![CDATA[<p><font> 手写Promise  主要是解决回调地狱的问题，在ES6中出现了promise来解决这个问题，但是同样也带来了多个.then()的问题<br>    //随着es7 async和await到来可以说彻底解决回调地狱。<br>    new Promise() //是谁执行了？直接new一个Promise是内置构造Promise执行了，但是它会报错。因为这里缺一个回调函数，平常大家也都是这么用的<br>    new Promise(()=&gt;{<br>       console.log(‘你大爷’)//‘你大爷’会执行吗？：这里new了一个Promose,Promise执行一次，那里面的回调函数也会执行，所以‘你大爷’成功被打印<br>    })<br>    function fn(callBack){</p><pre><code>&#125;new fn(()=&gt;&#123;&#125;)//fn执行，但是里面的回调并没有，Promise的回调会执行。//new Promise 是内置构造函数Promise执行一次//Promise的回调函数也会执行一次，这个回调函数会给我们提供两个形参（函数）：成功、失败//Promise的回调函数，又有两个参数分别是：resolve、reject两个函数//Promise类的实例没有then方法，应该是原型对象的方法var obj = new Promise((resolve,rejecct)=&gt;&#123;     console.log(resolve,reject)//两个函数&#125;)//obj是Promise的一个实例// 手写function myPromise(callBack)&#123;//接受传进来的回调函数    //状态属性    this.status=&#39;pending&#39;    //回调函数    callBack(resolve.bind(this),reject.bing(this))    //定义一个成功的函数    function resolve(hello,           params)&#123;        //那么console.log(hello)肯定是执行的（很早演示时写）        //修改状态（后写）        if(this.status===&#39;pending&#39;)&#123;//如果出事状态为pengding,            this.status=&#39;success&#39;//那就把它改成success成功            //这里还有一个上下文的问题。成功时resolve是怎么调用的？是函数名+小括号，也就是window.            //但这里就不该用window，因为将来获取服务器的数据实在.then()里的来获取。所以我们在初始化时就要给            //resolve和reject绑死这个类的实例：resolve.bind(this)  reject.bing(this) 走起上面绑死↑            //否则你在调用resolve和reject时他们就会指向window            //为什么绑死上下文为这个类的实例？因为我们要借用这个类的实例的成功和失败的方法74行里面成功与失败的回调            //所以↓            this.successCallBack(params)//这个是谁？它就是then的第一个参数也就是成功的回调，所以把参数直接注进来就行了            //失败同样        &#125;    &#125;    //定义一个失败的函数    function reject(err)&#123;        if(this.status===&#39;pending&#39;)&#123;            this.status=&#39;faile&#39;            this.faileCallBack(err)        &#125;    &#125;&#125;//调用new myPromise(()=&gt;&#123;//并且传进去一个回调函数。但是我们在实际运用中肯定要传2个参数进去。resolve,reject,并且37行回调也要接受这个2个函数    //console.log(&#39;我是Promise&#39;)//这里肯定会执行。打印。    //假如这里调用并传参resolve(&#39;hello&#39;)    //处理异步,一般promise就是处理异步的    setTimeout(()=&gt;&#123;        resolve(&#39;我是promise&#39;)    &#125;)&#125;)//假如我们是在处理异步请求那么肯定要在这.then()。但是能直接.then()吗？要注意.then()是在原型上面的。虽然链式语法可以这么写，但是这里并没有这个方法。.then()应该是原型上面类的原型的方法.then((data)=&gt;&#123;    console.log(data)&#125;,()=&gt;&#123;&#125;)//一般我们在调用then()的时候肯定要传2个参数进去，下面接收，就是相当于将then方法里面成功与失败的回调函数当做当前类的实例即可，当前类是谁？promise//所以原型上定义一个then的方法，应该是myPromise.prototype.then=function(success,faile)&#123;//接收上面调用then时传进来的来个函数。就是将then方法里面成功与失败的回到函数作为当前类的实例即可    this.successCallBack=success//相当于then传进一个成功的函数给了success,就是给myPromise的实例动态添加了属性就是success这个成功的箭头函数。还有一个失败的同样     this.faileCallBack=faile    //then()的两个函数相当于作为这个实例的两个方法&#125;//53行异步成功后执行，就是相当于调用了41行那个方法。失败同样//因为promise有3中状态，pending、成功、失败。所以此时我去上面给类定义个状态的属性，走起↑//如果说异步解决成功就调用resolve方法 。resolve就是41行函数执行。但是我们都是在then()来获取成功或失败的数据，(其实就是调用this.successCallBack，this.faileCallBack)。所以走起去上面↑，就是修改promise的状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(()&#x3D;&gt;&#123;</span><br><span class="line">    window.myPromise&#x3D;function(callBack)&#123;</span><br><span class="line">        &#x2F;&#x2F;状态属性</span><br><span class="line">        this.status&#x3D;&#39;pending&#39;</span><br><span class="line">        &#x2F;&#x2F;回调函数</span><br><span class="line">        callBack(resolve.bind(this),reject.bind(this))</span><br><span class="line">        &#x2F;&#x2F; 成功</span><br><span class="line">        function resolve(params)&#123;</span><br><span class="line">            if(this.status&#x3D;&#x3D;&#x3D;&#39;pending&#39;)&#123;</span><br><span class="line">                this.status&#x3D;&#39;success&#39;</span><br><span class="line">                this.successCallBack(params)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 失败</span><br><span class="line">        function reject(err)&#123;</span><br><span class="line">            if(this.status&#x3D;&#x3D;&#x3D;&#39;pending&#39;)&#123;</span><br><span class="line">                this.status&#x3D;&#39;faile&#39;</span><br><span class="line">                this.successCallBack(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;原型上定义一个then的方法</span><br><span class="line">    myPromise.prototype.then&#x3D;function(success,faile)&#123;</span><br><span class="line">        this.successCallBack&#x3D;success</span><br><span class="line">        this.faileCallBack&#x3D;faile</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">var obj &#x3D; new myPromise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        resolve(&#39;你真好&#39;)</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;).then((data)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(data)&#x2F;&#x2F;成功执行</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;font&gt; 手写Promise  主要是解决回调地狱的问题，在ES6中出现了promise来解决这个问题，但是同样也带来了多个.then()的问题&lt;br&gt;    //随着es7 async和await到来可以说彻底解决回调地狱。&lt;br&gt;    new Promise() </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Class的继承</title>
    <link href="http://example.com/2018/05/16/Class2/"/>
    <id>http://example.com/2018/05/16/Class2/</id>
    <published>2018-05-16T06:53:04.000Z</published>
    <updated>2020-12-30T06:09:50.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>Class可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承,要清晰和方便很多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Pointwo extends Point&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Pointwo extends Point&#123;</span><br><span class="line">    constructor(x,y,color)&#123;</span><br><span class="line">        super(x,y)&#x2F;&#x2F;调用父类的constructor(x,y)</span><br><span class="line">        this.color &#x3D; color</span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line">        return this.color + &#39;&#39; +super.toString()&#x2F;&#x2F;调用父类的toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码中，constructor方法和toString方法之中，都出现了super关键字，他在这里表示父类的构造函数，用来新建父类的this对象</span><br><span class="line">子类必须在constructor方法中调用super方法，否则新建实例时会报错，这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后对其进行加工，加上子类自己的实例属性和方法，如果不调用super方法，子类就得不到this对象</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123; &#x2F;* ... *&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cp &#x3D; new ColorPoint(); &#x2F;&#x2F; ReferenceError</span><br><span class="line">上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。</span><br><span class="line"></span><br><span class="line">ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</span><br><span class="line"></span><br><span class="line">如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(...args) &#123;</span><br><span class="line">    super(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    this.color &#x3D; color; &#x2F;&#x2F; ReferenceError</span><br><span class="line">    super(x, y);</span><br><span class="line">    this.color &#x3D; color; &#x2F;&#x2F; 正确</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。</span><br><span class="line"></span><br><span class="line">下面是生成子类实例的代码。</span><br><span class="line">let cp &#x3D; new ColorPoint(25, 8, &#39;green&#39;);</span><br><span class="line"></span><br><span class="line">cp instanceof ColorPoint &#x2F;&#x2F; true</span><br><span class="line">cp instanceof Point &#x2F;&#x2F; true</span><br><span class="line">上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后，父类的静态方法，也会被子类继承。</span><br></pre></td></tr></table></figure><p>class A {<br>  static hello() {<br>    console.log(‘hello world’);<br>  }<br>}</p><p>class B extends A {<br>}</p><p>B.hello()  // hello world<br>上面代码中，hello()是A类的静态方法，B继承A，也继承了A的静态方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.Object.getPrototypeOf()</span><br><span class="line">Object.getPrototypeOf()方法可以用来从子类上获取父类</span><br></pre></td></tr></table></figure><p>Object.getPrototypeOf(ColorPoint) === Point//true<br>因此，可以使用这个方法判断，一个类是否继承了另一个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.super关键字</span><br><span class="line">super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同</span><br><span class="line">第一种情况，super作为函数用时，代表父类的构造函数。ES6要求，子类的构造函数必须执行一次super函数。</span><br></pre></td></tr></table></figure><p>class A {}</p><p>class B extends A {<br>  constructor() {<br>    super();<br>  }<br>}<br>上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p><p>注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    console.log(new.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">new A() &#x2F;&#x2F; A</span><br><span class="line">new B() &#x2F;&#x2F; B</span><br><span class="line">上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。</span><br><span class="line"></span><br><span class="line">作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  m() &#123;</span><br><span class="line">    super(); &#x2F;&#x2F; 报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，super()用在B类的m方法之中，就会造成语法错误。</span><br></pre></td></tr></table></figure><p>第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    p()&#123;</span><br><span class="line">        return 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super()</span><br><span class="line">        console.log(super.p())&#x2F;&#x2F;&#x2F;2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; new B()</span><br><span class="line">代码中，子类B当中的super.p(),就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype,所以super.p()就相当于A.prototype.p()</span><br><span class="line">注意：由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.p &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  get m() &#123;</span><br><span class="line">    return super.p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">b.m &#x2F;&#x2F; undefined</span><br><span class="line">上面代码中，p是父类A实例的属性，super.p就引用不到它。</span><br></pre></td></tr></table></figure><p>如果属性定义在父类的原型对象上，super就可以取到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line">A.prototype.x &#x3D; 2;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super.x) &#x2F;&#x2F; 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">代码中,属性x是定义在A.prototype上面的，所以super.x可以取到它的值</span><br></pre></td></tr></table></figure><p>ES6规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.x &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    super.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">b.m() &#x2F;&#x2F; 2</span><br><span class="line">代码中，super.print()虽然调用的是A.prototype.print(),但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1.也就是说，实际上执行的是super.print.call(this)</span><br></pre></td></tr></table></figure><p>由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.x &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x &#x3D; 2;</span><br><span class="line">    super.x &#x3D; 3;</span><br><span class="line">    console.log(super.x); &#x2F;&#x2F; undefined</span><br><span class="line">    console.log(this.x); &#x2F;&#x2F; 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">代码中，super.x赋值为3，这时等同于对this.x赋值为3.而当读取super.x的时候，读的是A.prototype.x,所以返回undefined</span><br></pre></td></tr></table></figure><p>如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">    static myMethod(msg)&#123;</span><br><span class="line">        console.log(&#39;static&#39;,msg)</span><br><span class="line">    &#125;</span><br><span class="line">    myMethod(msg)&#123;</span><br><span class="line">        console.log(&#39;instance&#39;,msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent&#123;</span><br><span class="line">    static myMethod(msg)&#123;</span><br><span class="line">        super.myMethod(msg)</span><br><span class="line">    &#125;</span><br><span class="line">    myMethod(msg)&#123;</span><br><span class="line">        super.myMethod(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Child.myMethod(1))</span><br><span class="line">var child &#x3D; new Child()</span><br><span class="line">console.log(child.myMethod(2))</span><br><span class="line">上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</span><br></pre></td></tr></table></figure><p>另外，在子类的静态方法中通过super调用父类方法时，方法内部的this指向当前的子类，而不是子类的实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.x &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  static print() &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line">  static m() &#123;</span><br><span class="line">    super.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.x &#x3D; 3;</span><br><span class="line">B.m() &#x2F;&#x2F; 3</span><br><span class="line">上面代码中，静态方法B.m里面，super.print指向父类的静态方法。这个方法里面的this指向的是B，而不是B的实例。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</span><br><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super); &#x2F;&#x2F; 报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super.valueOf() instanceof B); &#x2F;&#x2F; true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super使得this指向B的实例，所以super.valueOf()返回的是一个B的实例。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &quot;MyObject: &quot; + super.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.toString(); &#x2F;&#x2F; MyObject: [object Object]</span><br></pre></td></tr></table></figure><p>4.类的 prototype 属性和__proto__属性<br>大多数浏览器的ES5实现中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性,因此同时存在两条继承链<br>(1) 子类的__proto__属性，表示构造函数的继承，总是指向父类。<br>(2) 子类的prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">B.__proto__ &#x3D;&#x3D;&#x3D; A &#x2F;&#x2F;true</span><br><span class="line">B.prototype.__proto__ &#x3D;&#x3D;&#x3D; A.prototype &#x2F;&#x2F;true</span><br><span class="line">代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性</span><br></pre></td></tr></table></figure><p>这样的结果是因为，类的继承是按照下面的模式实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class B&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Object.setPrototypeOf(B.prototype,A.prototype)&#x2F;&#x2F;B的实例继承A的实例</span><br><span class="line">Object.setPrototypeOf(B,A)&#x2F;&#x2F;B继承A的静态属性</span><br><span class="line">const b &#x3D; new B()</span><br><span class="line">《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf &#x3D; function (obj, proto) &#123;</span><br><span class="line">  obj.__proto__ &#x3D; proto;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line">因此就得到了上面这个结果</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">B.prototype.__proto__ &#x3D; A.prototype;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(B, A);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">B.__proto__ &#x3D; A;</span><br><span class="line">这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B.prototype &#x3D; Object.create(A.prototype);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">B.prototype.__proto__ &#x3D; A.prototype;</span><br></pre></td></tr></table></figure><p>extends关键字后面可以跟多种类型的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class B extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。</span><br></pre></td></tr></table></figure><p>下面，讨论两种情况。第一种，子类继承Object类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A extends Object &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ &#x3D;&#x3D;&#x3D; Object &#x2F;&#x2F; true</span><br><span class="line">A.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; true</span><br><span class="line">这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。</span><br></pre></td></tr></table></figure><p>第二种情况，不存在任何继承。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ &#x3D;&#x3D;&#x3D; Function.prototype &#x2F;&#x2F; true</span><br><span class="line">A.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; true</span><br><span class="line">这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。</span><br></pre></td></tr></table></figure><p>实例的 <strong>proto</strong> 属性<br>子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Point(2, 3);</span><br><span class="line">var p2 &#x3D; new ColorPoint(2, 3, &#39;red&#39;);</span><br><span class="line"></span><br><span class="line">p2.__proto__ &#x3D;&#x3D;&#x3D; p1.__proto__ &#x2F;&#x2F; false</span><br><span class="line">p2.__proto__.__proto__ &#x3D;&#x3D;&#x3D; p1.__proto__ &#x2F;&#x2F; true</span><br><span class="line">上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。</span><br></pre></td></tr></table></figure><p>因此，通过子类实例的<strong>proto</strong>.__proto__属性，可以修改父类实例的行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p2.__proto__.__proto__.printName &#x3D; function () &#123;</span><br><span class="line">  console.log(&#39;Ha&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() &#x2F;&#x2F; &quot;Ha&quot;</span><br><span class="line">上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h1&gt;&lt;p&gt;Class可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承,要清晰和方便很多。&lt;/p&gt;
&lt;figur</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Class的基本语法</title>
    <link href="http://example.com/2018/05/15/Class1/"/>
    <id>http://example.com/2018/05/15/Class1/</id>
    <published>2018-05-15T14:02:45.000Z</published>
    <updated>2020-12-29T06:52:30.506Z</updated>
    
    <content type="html"><![CDATA[<p>class的基本语法:<br>一.类的由来<br>JS中生成实力对象的传统方法是通过构造函数，下面请看一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Point(x,y)&#123;</span><br><span class="line">    this.x&#x3D;x</span><br><span class="line">    this.y&#x3D;y</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.toString&#x3D;function ()&#123;</span><br><span class="line">    return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39;</span><br><span class="line">&#125;</span><br><span class="line">var p &#x3D; new Point(1,2)</span><br><span class="line">console.log(p)</span><br></pre></td></tr></table></figure><p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</p><p>基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">    constructor(x,y)&#123;</span><br><span class="line">        this.x&#x3D;x</span><br><span class="line">        this.y&#x3D;y</span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line">            return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p &#x3D;new Point(1,2)</span><br><span class="line">console.log(p)</span><br></pre></td></tr></table></figure><p>这个是定义了一个类，有一个constructor()方法，就是构造方法而this关键字就是实力的对象。这种新的Class写法，最开始ES5的构造函数Point是一样的。</p><p>Point类除了构造方法，还定义了一个toString方法。注意，这里定义toString()方法，是不用加上function关键字的。直接定义就可以，并且不用逗号隔开，加了会报错。</p><p>ES6的类，完全可以看做构造函数的另一种写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(typeof Point)&#x2F;&#x2F;function 说明类的数据类型是函数，类本身就指向构造函数</span><br><span class="line">console.log(Point&#x3D;&#x3D;&#x3D;Point.prototype.constructor)&#x2F;&#x2F;true</span><br><span class="line">使用的时候也是直接对类使用new 命令，跟构造函数的用法完全一致。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Bar&#123;</span><br><span class="line">    todo()&#123;</span><br><span class="line">        console.log(&#39;类&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const b &#x3D; new Bar()</span><br><span class="line">b.todo()&#x2F;&#x2F;&#39;类&#39;</span><br><span class="line">构造函数的prototype属性，在ES6的 类上面继续存在。事实上，类的所有方法都定义在类的 prototype属性上面</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">        constructor() &#123;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        toString() &#123;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        toValue() &#123;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 等同于</span><br><span class="line"></span><br><span class="line">        Point.prototype &#x3D; &#123;</span><br><span class="line">        constructor() &#123;&#125;,</span><br><span class="line">        toString() &#123;&#125;,</span><br><span class="line">        toValue() &#123;&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        上面代码中，所有的方法，其实都是定义在Point.prototype上面</span><br><span class="line">        因此，在类的实例上面调用方法，其实就是调用原型上的方法</span><br></pre></td></tr></table></figure><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class B&#123;&#125;</span><br><span class="line">const b &#x3D; new B()</span><br><span class="line">console.log(b.constructor &#x3D;&#x3D;&#x3D; B.prototype.constructor)&#x2F;&#x2F;true</span><br><span class="line">b是B类的实例，b的constructor()方法就是B类原型的constructor()方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。</span><br><span class="line">Object.assign()方法可以很方便地一次向类天机多个方法。比如：</span><br><span class="line">class Point&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Object.assign(Point.prototype,&#123;</span><br><span class="line">    toString()&#123;&#125;,</span><br><span class="line">    toValue()&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prototype对象的constructor()属性，直接指向&#39;类&#39;的本身，这与ES5的行为是一致的。</span><br><span class="line">Point.prototype.constructor&#x3D;&#x3D;&#x3D;Point &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>另外，类的内部所有定义的方法，都是不可枚举的(non-enumerabal)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">    constructor(x,y)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.keys(Point.prototype))&#x2F;&#x2F;[]</span><br><span class="line">console.log(Object.getOwnPropertyNames(Point.prototype))&#x2F;&#x2F;[&#39;constructor&#39;,&#39;toString&#39;]</span><br><span class="line">这里，toString()方法是Point类 内部定义的方法，它是不可枚举的。这一点与ES5是不一样的</span><br></pre></td></tr></table></figure></code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    var Point &#x3D; function (x,y)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.toString &#x3D; function ()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.keys(Point.prototype))&#x2F;&#x2F;[&#39;toString&#39;]</span><br><span class="line">console.log(Object.getOwnPropertyNames(Point.prototype))&#x2F;&#x2F;[&#39;constructor&#39;,&#39;toString&#39;]</span><br><span class="line">这是ES5 的写法，toString()方法就是可枚举的。</span><br></pre></td></tr></table></figure><p>Constructor()方法<br>    constructor()方法是类的默认方法，是通过new 命令生成对象实例时，自动调用该方法。一个类必须有constructor()<br>    方法，如果没有显示定义，一个空德constructor()方法也会被默认添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Ponit&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;等同于</span><br><span class="line">    class Point&#123;</span><br><span class="line">        constructor()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">这里，定义了一个空的类Point,JS引擎会自动给他添加一个空的constructor()方法。</span><br><span class="line">constructor()方法默认返回实例对象(即this),完全可以指定返回另一个对象</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        return Object.create(null)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Foo() instanceof Foo)&#x2F;&#x2F;false</span><br><span class="line">这里，constructor()函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。</span><br><span class="line">类必须使用new调用，否则会报错，这是它跟普通构造函数的一个主要区别，后者不用new也可以执行</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        return Object.create(null)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo()&#x2F;&#x2F;Class constructor Foo cannot be invoked without &#39;new&#39;</span><br></pre></td></tr></table></figure><p>类的实例！<br>    生成类的实例的写法，与ES5 完全一样，也是使用 new命令。如果没有用 new，像函数那样调用class,将会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> var point &#x3D; Point(2,3)&#x2F;&#x2F;报错</span><br><span class="line"> var point &#x3D; new Point(2,3)&#x2F;&#x2F;正确</span><br></pre></td></tr></table></figure><p>与ES5 一样，实例的属性除非显示定义在其本身(即定义在this上)，否则都是定义在原型上(即定义在class上)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">    constructor(x,y)&#123;</span><br><span class="line">        this.x&#x3D;x</span><br><span class="line">        this.y&#x3D;y</span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line">        return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var point &#x3D; new Point(2,3)</span><br><span class="line">console.log(point.toString(2,3))&#x2F;&#x2F;(2,3)</span><br><span class="line">console.log(point.hasOwnProperty(&#39;x&#39;))&#x2F;&#x2F;true</span><br><span class="line">console.log(point.hasOwnProperty(&#39;y&#39;))&#x2F;&#x2F;true</span><br><span class="line">console.log(point.hasOwnProperty(&#39;toString&#39;))&#x2F;&#x2F;false</span><br><span class="line">console.log(point.__proto__.hasOwnProperty(&#39;toString&#39;))&#x2F;&#x2F;true</span><br><span class="line">上面代码中，x和y都是实例对象point自身属性(因为定义在this变量上)，所以hasOwnProperty()方法返回true，而toString()</span><br><span class="line">是原型对象的属性(因为定义在Point类上)，所以hasOwnProperty()方法返回false,这些都与ES5的行为保持一致</span><br></pre></td></tr></table></figure><p>与ES5一样，类的所有实例共享一个原型对象！！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Point(2,3)</span><br><span class="line">var p2 &#x3D; new Point(1,3)</span><br><span class="line">p1.__proto&#x3D;&#x3D;&#x3D;p2.__proto__&#x2F;&#x2F;true</span><br><span class="line">上面代码中。p1和p2都是Point的实例，他们的原型都是Point.prototype,所以__proto__属性是相等的。</span><br><span class="line">这也意味着，可以通过实例的__proto__属性为&#39;类&#39;添加方法</span><br></pre></td></tr></table></figure><p><strong>proto</strong> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Point(2,3);</span><br><span class="line">var p2 &#x3D; new Point(3,2);</span><br><span class="line"></span><br><span class="line">p1.__proto__.printName &#x3D; function () &#123; return &#39;Oops&#39; &#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class="line">p2.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class="line"></span><br><span class="line">var p3 &#x3D; new Point(4,2);</span><br><span class="line">p3.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class="line">上面代码在p1的原型上添加了一个printName()方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</span><br></pre></td></tr></table></figure><p>取值函(getter)和存值函数(setter)<br>与ES5一样，在’类’的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MyClass&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    get prop()&#123;</span><br><span class="line">        return &#39;getter&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    set prop(value)&#123;</span><br><span class="line">        console.log(&#39;setter:&#39;+value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let inst &#x3D; new MyClass()</span><br><span class="line">console.log(inst.props&#x3D;123)&#x2F;&#x2F;&#39;setter:123&#39;</span><br><span class="line">console.log(inst.prop)&#x2F;&#x2F;&#39;getter&#39;</span><br><span class="line">上面，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了</span><br></pre></td></tr></table></figure><p>存值函数和取值函数式设置在属性的 Desscriptor对象上的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class CustomHTMLElement &#123;</span><br><span class="line">    constructor(element)&#123;</span><br><span class="line">        this.element &#x3D; element</span><br><span class="line">    &#125;</span><br><span class="line">    get html()&#123;</span><br><span class="line">        return thi.element.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">    set html(value)&#123;</span><br><span class="line">        this.element.innerHTML&#x3D;value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var descriptor &#x3D; Object.getOwnPropertyDescriptor(</span><br><span class="line">    CustomHTMLElement.proptotype,&#39;html&#39;</span><br><span class="line">)</span><br><span class="line">&#39;get&#39; in descriptor&#x2F;&#x2F;true</span><br><span class="line">&#39;set&#39; in descriptor&#x2F;&#x2F;true</span><br><span class="line">上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。</span><br></pre></td></tr></table></figure><p>属性表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let nethodName &#x3D; &#39;getArea&#39;</span><br><span class="line">class Square &#123;</span><br><span class="line">    constructor(length)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    [methodName]()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码中，Square类的方法名getArea,是从表达式得到的。</span><br></pre></td></tr></table></figure><p>Class 表达式<br>与函数一样，类也可以使用表达式的形式定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> const MyClass &#x3D; class Me&#123;</span><br><span class="line">    getClassName()&#123;</span><br><span class="line">        return Me.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这里使用表达式定义了一个类，类的名字是Me,但是Me只在Class的内部可用，指代当前类。在Class外部，这个类只能用myClass引用</span><br><span class="line">let inst &#x3D; new MyClass()</span><br><span class="line">console.log(inst.getClassName())&#x2F;&#x2F;Me</span><br><span class="line">Me.name&#x2F;&#x2F;Me is not defined</span><br><span class="line">这里就可以说明，Me只在Class内部有定义</span><br><span class="line"></span><br><span class="line">如果类的内部没有用到的话，可以省略Me,也就是可以下面的形式</span><br><span class="line">const MyClass &#x3D; class &#123;&#x2F;&#x2F;....&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">采用Class 表达式，可以写出立即执行的Class</span><br><span class="line">let person &#x3D; new class&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(&#39;李华&#39;)</span><br><span class="line">person.sayName()</span><br><span class="line">这里 person是一个立即执行的类的实例</span><br></pre></td></tr></table></figure><p>注意点<br>（1）严格模式</p><p>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。<br>（2）不存在提升<br>累不存在变量提升，这一点与ES5完全不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Foo()</span><br><span class="line">class Foo&#123;&#125;</span><br><span class="line">上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承者有关，必须保证子类在父类之后定义。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let Foo &#x3D; class&#123;&#125;</span><br><span class="line">    class Bar extends Foo&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。</span><br></pre></td></tr></table></figure><p>（3）name 属性<br>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;&#125;</span><br><span class="line">Point.name&#x2F;&#x2F;&#39;Point&#39;</span><br><span class="line">name属性总是返回紧跟在class关键字后面的类。</span><br></pre></td></tr></table></figure><p>（4）Generator 方法<br>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    constructor(...args)&#123;</span><br><span class="line">        this.args &#x3D; args</span><br><span class="line">    &#125;</span><br><span class="line">    *[Symbol.iterator]()&#123;</span><br><span class="line">        for(let arg of this.args)&#123;</span><br><span class="line">            yield arg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(let x of new Foo(&#39;hello&#39;,&#39;world&#39;))&#123;</span><br><span class="line">    console.log(x)</span><br><span class="line">&#125;</span><br><span class="line">上面的代码中，Foo类的Symbol.interator方法前有一个星号，表示该方法是一个Generator 函数。Symbol.interator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。</span><br></pre></td></tr></table></figure><p>5）this 的指向<br>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Logger&#123;</span><br><span class="line">    printName(name&#x3D;&#39;there&#39;)&#123;</span><br><span class="line">        this.print(&#96;Hello $&#123;name&#125;&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">    print(text)&#123;</span><br><span class="line">        console.log(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const logger &#x3D; new Logger()</span><br><span class="line">const &#123; printName&#125; &#x3D; logger</span><br><span class="line">console.log(printName())&#x2F;&#x2F;Cannot read property &#39;print&#39; of undefined</span><br><span class="line">上面代码中，printName方法中的this，默认指向Logger类的实例，但是。如果将这个方法提取出来单独使用，this会指向该方法运行是所在的环境(由于class内部是严格模式，所以this实际指向的是undefined),从而导致找不到print方法而报错。</span><br><span class="line">一个比较简单的解决方法是，在构造函数中绑定this。这样就不会找不到print方法了。</span><br><span class="line">class Logger &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.printName &#x3D; this.printName.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">另一种解决方法是使用箭头函数。</span><br><span class="line">class Obj&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.getThis &#x3D; () &#x3D;&gt; this</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const myObj &#x3D; new Obj()</span><br><span class="line">myObj.getThis() &#x3D;&#x3D;&#x3D; myObj&#x2F;&#x2F;true</span><br><span class="line">箭头函数内部的this总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，实在构造函数执行的时候，这时，箭头函数所在的运行环境，肯定是实例对象，所以this会总是指向实例对象</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。</span><br><span class="line">function selfish (target) &#123;</span><br><span class="line">  const cache &#x3D; new WeakMap();</span><br><span class="line">  const handler &#x3D; &#123;</span><br><span class="line">    get (target, key) &#123;</span><br><span class="line">      const value &#x3D; Reflect.get(target, key);</span><br><span class="line">      if (typeof value !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        return value;</span><br><span class="line">      &#125;</span><br><span class="line">      if (!cache.has(value)) &#123;</span><br><span class="line">        cache.set(value, value.bind(target));</span><br><span class="line">      &#125;</span><br><span class="line">      return cache.get(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  const proxy &#x3D; new Proxy(target, handler);</span><br><span class="line">  return proxy;</span><br><span class="line">&#125;</span><br><span class="line">const logger &#x3D; selfish(new Logger());</span><br></pre></td></tr></table></figure><p>2.静态方法<br>类相当于实例的原型。所有在类中定义的方法，都会被实例继承，如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为‘静态方法’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    static classMethod()&#123;</span><br><span class="line">        return &#39;hello&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Foo.classMethod())&#x2F;&#x2F;&#39;hello&#39;</span><br><span class="line">var foo &#x3D; new Foo()</span><br><span class="line">console.log(foo.classMethod())&#x2F;&#x2F;foo.classMethod is not a function</span><br><span class="line">上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用</span><br><span class="line">(Foo.classMethod()),而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法</span><br></pre></td></tr></table></figure><p>注意：如果静态方法包含this关键字，这个this指的是类，而不是实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    static bar()&#123;</span><br><span class="line">        this.baz()</span><br><span class="line">    &#125;</span><br><span class="line">    static baz()&#123;</span><br><span class="line">        console.log(&#39;hello&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    baz()&#123;</span><br><span class="line">        console.log(&#39;world&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    console.log(Foo.bar())&#x2F;&#x2F;hello</span><br><span class="line"></span><br><span class="line">上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo的类，而不是Foo的实例，等同于调用Foo.baz.另外，从这个例子还可以看出，静态方法可以与非静态方法重名</span><br></pre></td></tr></table></figure><p>父类的静态方法，可以被子类继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    static classMethod()&#123;</span><br><span class="line">        return &#39;hello&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Bar extends Foo&#123;&#125;</span><br><span class="line">console.log(Bar.classMethod())&#x2F;&#x2F;hello</span><br><span class="line">这里，父类Foo有一个静态方法，子类Bar可以调用这个方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">静态方法也是可以从super对象上调用的</span><br><span class="line">class Foo&#123;</span><br><span class="line">    static classMethod()&#123;</span><br><span class="line">        return &#39;hello&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Bar extends Foo&#123;</span><br><span class="line">    static classMethod()&#123;</span><br><span class="line">        return super.classMethod()+&#39;,too&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Bar.classMethod())&#x2F;&#x2F;hello,too</span><br></pre></td></tr></table></figure><p>3.实例属性的新写法<br>实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class IncreasingCounter&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this._count &#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">    get value()&#123;</span><br><span class="line">        console.log(&#39;Getting the current value&#39;)</span><br><span class="line">        return this._count</span><br><span class="line">    &#125;</span><br><span class="line">    increment()&#123;</span><br><span class="line">        this._count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码中，实例属性this._count定义在constructor()方法里面，另一种写法是，这个属性也可以定义在类的最顶层，其他都不变</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class IncreasingCounter&#123;</span><br><span class="line">    _count &#x3D; 0</span><br><span class="line">    get value()&#123;</span><br><span class="line">        console.log(&#39;Getter the current value&#39;)</span><br><span class="line">        return this._count</span><br><span class="line">    &#125;</span><br><span class="line">    increment()&#123;</span><br><span class="line">        this._count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码中，实例属性_count与取值函数value()和increment()方法，处于同一层级。这时，不需要在实例属性前面加上this。</span><br><span class="line">这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class foo&#123;</span><br><span class="line">    bar &#x3D; &#39;hello&#39;</span><br><span class="line">    baz &#x3D; &#39;world&#39;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码中，一眼就能看出，foo类有两个实例属性，一目了然。另外，写起来也比较简洁</span><br></pre></td></tr></table></figure><p>4.静态属性<br>静态属性指的是Class 本身的属性，即Class.porpName,而不是定义在实例对象(this)上的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop &#x3D; 1</span><br><span class="line">Foo.prop &#x2F;&#x2F;1</span><br><span class="line">上面的写法为Foo类定义了一个静态属性prop</span><br></pre></td></tr></table></figure><p>目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性。写法是在实例属性的前面，加上static关键字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyClass&#123;</span><br><span class="line">    static myStaticProp &#x3D; 42</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        console.log(MyClass.myStaticProp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">new MyClass()</span><br><span class="line">这个新写法大大方便了静态属性的表达</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;&#x2F;&#x2F;老写法</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop &#x3D;1</span><br><span class="line">class Foo&#123;&#x2F;&#x2F;新写法</span><br><span class="line">    static prop &#x3D;1</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，老写法的静态属性定义在类的外部，整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative）,而不是赋值处理，语义更好。</span><br></pre></td></tr></table></figure><p>5.私有方法和私有属性<br>现在的解决方案<br>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问，这是常见需求，有利于代码的封装，但ES6不提供，只能通过变通方法模拟实现。<br>一种做法是在命名上加以区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Widget&#123;</span><br><span class="line">    &#x2F;&#x2F;公有方法</span><br><span class="line">    foo(baz)&#123;</span><br><span class="line">        this._bar(baz)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;私有属性</span><br><span class="line">    _bar(baz)&#123;</span><br><span class="line">        return this.snaf &#x3D; baz</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，_bar()方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是这种命名是不保险的。在类的外部，还是可以调用到这个方法</span><br></pre></td></tr></table></figure><p>另一种方法就是索性将私有方法移出类，因为类内部的所有方法都是对外可见的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    bar.call(this, baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar(baz) &#123;</span><br><span class="line">  return this.snaf &#x3D; baz;</span><br><span class="line">&#125;</span><br><span class="line">上面代码中，foo是公开方法，内部调用了bar.call(this, baz)。这使得bar()实际上成为了当前类的私有方法。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;class的基本语法:&lt;br&gt;一.类的由来&lt;br&gt;JS中生成实力对象的传统方法是通过构造函数，下面请看一个例子&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>变量提升</title>
    <link href="http://example.com/2018/05/08/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    <id>http://example.com/2018/05/08/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</id>
    <published>2018-05-08T06:01:41.000Z</published>
    <updated>2020-12-30T06:09:49.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="var的变量提升"><a href="#var的变量提升" class="headerlink" title="var的变量提升"></a>var的变量提升</h1><p>es3/es5<br>1.变量提升：当栈内存（作用域）形成，JS代码自上而下执行之前，浏览器首先会把所有带var和function关键字的进行提前的<br>声明或定义.这种预先处理机制称之为变量提升。<br>3.声明（declare）：var a或function sum<br>4.定义（defined）:a=12 也就是赋值<br>5.变量提升阶段：<br>6.带var的只声明未定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(a)&#x2F;&#x2F;undefined</span><br><span class="line">    var a &#x3D; 12;</span><br><span class="line">    function b(arr)&#123;&#x2F;&#x2F;变量提升阶段function就完成了声明和赋值，浏览器会在全局作用域声明一个b，然后再形成一个堆内存里面</span><br><span class="line">        &#x2F;&#x2F;是函数体里面的代码字符串。这个堆内存会有一个16进制的地址，而全局里面声明的那个b就会指向这个地址</span><br><span class="line">        &#x2F;&#x2F;因为函数在变量提升阶段就完成了声明和赋值，所以在代码执行阶段在遇到b这个函数就不会在重复声明赋值，就会直接跳过</span><br><span class="line">        for(let i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">            console.log(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;跳过后就会执行下面这个函数调用，传了一个数组进去。</span><br><span class="line">    &#x2F;&#x2F;而执行一个函数也就是形成了一个私有栈内存。当私有的作用域形成后也不是立即代码执行，而是先进行变量提升（变量提升前，先形参赋值）</span><br><span class="line">    b([1,2,3,4])</span><br><span class="line">    &#x2F;&#x2F;在ES3和ES5语法规范中,只有全局作用域和函数执行的私有作用域（栈内存），其他大括号不会形成栈内存</span><br></pre></td></tr></table></figure><h1 id="带var与不带var"><a href="#带var与不带var" class="headerlink" title="带var与不带var"></a>带var与不带var</h1><p>在全局作用域下声明一个变量，也相当于给window全局对象设置了一个属性，变量的值就是属性值（私有作用域下声明的私有变量和window没有关系）<br>带function的声明和赋值都完成了<br>变量提升至发生在当前作用域（例如：开始加载页面的时候只对全局作用域下的进行提升，因为此时函数中存储的都是字符串）<br>在全局作用域先声明的函数或者变量是‘全局变量’，同理，在私有作用域下声明的变量是‘私有变量’[带var和function才是声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">console.log(i)&#x2F;&#x2F;undefined</span><br><span class="line">    console.log(window.i)&#x2F;&#x2F;undefined</span><br><span class="line">    console.log(&#39;i&#39; in window)&#x2F;&#x2F;true   在变量提升阶段，在全局作用域中声明了一个变量i，此时就已经把i当做属性值赋值</span><br><span class="line">    &#x2F;&#x2F;给了window了，只不过此时还没有给i赋值，默认是undefined  </span><br><span class="line">    &#x2F;&#x2F; in? ：检测某个属性是否隶属于这个对象</span><br><span class="line">    var i &#x3D; 9&#x2F;&#x2F;变量值修改window的值也跟着修改</span><br><span class="line">    console.log(i)&#x2F;&#x2F;9</span><br><span class="line">    console.log(window.i)&#x2F;&#x2F;9  window的一个属性名为i</span><br><span class="line">    i&#x3D;13</span><br><span class="line">    console.log(window.i)&#x2F;&#x2F;13</span><br><span class="line">    window.i&#x3D;14</span><br><span class="line">    console.log(i)&#x2F;&#x2F;14    重点：全局变量和window的属性存在‘映射机制’，就是有一个改变另一个也跟着改变</span><br></pre></td></tr></table></figure><h1 id="不带var-不带var的本质是window的属性"><a href="#不带var-不带var的本质是window的属性" class="headerlink" title="不带var 不带var的本质是window的属性"></a>不带var 不带var的本质是window的属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;console.log(j)&#x2F;&#x2F;j is not defined   这里的J是按照变量的来识别的</span><br><span class="line">   &#x2F;&#x2F;console.log(window.j)&#x2F;&#x2F;undefined    这里是按照window的属性来识别的，因为对象没有某一个属性返回的就是undefined</span><br><span class="line">   &#x2F;&#x2F;console.log(window.j)&#x2F;&#x2F;false 不存在这个属性</span><br><span class="line">   j&#x3D;10&#x2F;&#x2F; 这里不带var 就相当于给window加了一个属性叫j,值是10</span><br><span class="line">   console.log(j)&#x2F;&#x2F;10</span><br><span class="line">   console.log(window.a)&#x2F;&#x2F;12</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; var q &#x3D;10,</span><br><span class="line">   &#x2F;&#x2F;     s &#x3D;11 &#x2F;&#x2F;这样写s是带var</span><br><span class="line">   &#x2F;&#x2F; var q &#x3D; s &#x3D;11 &#x2F;&#x2F; 这样写不带var  </span><br><span class="line">   &#x2F;&#x2F;在私有作用域中带var和不带var也有区别：带var在私有作用域变量提升阶段都声明为私有变量和外界没有任何关系</span><br><span class="line">   &#x2F;&#x2F;不带var 不是私有变量，它会想它的上级作用域查找，看它是否是上级的变量，不是继续向上查找，一直找到window为止</span><br><span class="line">   &#x2F;&#x2F;这种查找机制叫‘作用域链’</span><br><span class="line">   &#x2F;&#x2F;console.log(n,m)&#x2F;&#x2F;undefined undefined</span><br><span class="line">   var n &#x3D;13;</span><br><span class="line">       m &#x3D;13;</span><br><span class="line">   function fn()&#123;</span><br><span class="line">       console.log(n,m)&#x2F;&#x2F;变量提升阶段先var了一个n所以是 undefined 但是m不带var，向上级查找所以m是13  ；</span><br><span class="line">       var n &#x3D; m &#x3D; 14&#x2F;&#x2F;此时都是14</span><br><span class="line">       console.log(n,m)&#x2F;&#x2F;14 14</span><br><span class="line">   &#125;</span><br><span class="line">   fn()</span><br><span class="line">   console.log(a,m)&#x2F;&#x2F; 这里的a是全局的所以是13，b在函数里被重新赋值所以是14</span><br></pre></td></tr></table></figure><h1 id="在私有作用域中如果向上级查找变量到window的时候发现window也没有这个属性时又是怎么做的呢？"><a href="#在私有作用域中如果向上级查找变量到window的时候发现window也没有这个属性时又是怎么做的呢？" class="headerlink" title="在私有作用域中如果向上级查找变量到window的时候发现window也没有这个属性时又是怎么做的呢？"></a>在私有作用域中如果向上级查找变量到window的时候发现window也没有这个属性时又是怎么做的呢？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unction f()&#123;</span><br><span class="line">        b &#x3D; 13</span><br><span class="line">        console.log(&#39;b&#39; in window)&#x2F;&#x2F;true  在作用域查找的过程中，如果找到window也没有这个变量，相当于给window设置了</span><br><span class="line">        &#x2F;&#x2F;了一个属性b</span><br><span class="line">        console.log(b)&#x2F;&#x2F;13</span><br><span class="line">    &#125;</span><br><span class="line">    f()</span><br><span class="line">    console.log(b)&#x2F;&#x2F;13</span><br></pre></td></tr></table></figure><h1 id="只对等于号左边进行变量提升"><a href="#只对等于号左边进行变量提升" class="headerlink" title="只对等于号左边进行变量提升"></a>只对等于号左边进行变量提升</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fnn()&#x2F;&#x2F; fnn is not a function </span><br><span class="line">    sun()&#x2F;&#x2F;2 </span><br><span class="line">    var fnn &#x3D; function ()&#123;&#x2F;&#x2F;函数表达式声明 因为是用var关键字声明在变量提升阶段只提升了等号左边的fnn,</span><br><span class="line">        &#x2F;&#x2F;但是并没有定义或赋值，所以在上面调用时报错</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;</span><br><span class="line">    fnn()</span><br><span class="line">    function sun ()&#123;&#x2F;&#x2F;普通方式声明的函数在 变量提升阶段就已经声明和定义完毕 所以上面可以直接执行</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;</span><br><span class="line">    sun()</span><br></pre></td></tr></table></figure><h1 id="条件判断下变量提升"><a href="#条件判断下变量提升" class="headerlink" title="条件判断下变量提升"></a>条件判断下变量提升</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">console.log(z)</span><br><span class="line">    if(1&#x3D;&#x3D;&#x3D;2)&#123;&#x2F;&#x2F;在当前作用域下，不管条件是否成功都要进行变量提升，</span><br><span class="line">        &#x2F;&#x2F;带var的还是只是声明</span><br><span class="line">        &#x2F;&#x2F;带function的在老版本浏览器渲染机制下，声明+定义都处理，但是为了迎合es6中的块级作用域，新版浏览器对于函数</span><br><span class="line">        &#x2F;&#x2F;（在条件判断中的函数），不管条件是否成立，都是先声明，没有赋值。</span><br><span class="line">        var z &#x3D; 10</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(z)</span><br><span class="line"></span><br><span class="line">    if(1&#x3D;&#x3D;&#x3D;1)&#123;</span><br><span class="line">        console.log(fs)&#x2F;&#x2F;函数本身：当条件成立，进入到判断体中（ES6中它是以个块级作用域）第一件事并不是变量提升，</span><br><span class="line">        &#x2F;&#x2F;先把fs声明并定义，也就是判断体中代买执行前，fs就已经赋值了</span><br><span class="line">        function fs()&#123;</span><br><span class="line">            console.log(&#39;ok&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(fs)&#x2F;&#x2F;函数本身</span><br></pre></td></tr></table></figure><h1 id="ES6中let创建的变量不存在变量提升。不允许重复定义-暂时性死区-切断了全局变量和window属性的映射机制"><a href="#ES6中let创建的变量不存在变量提升。不允许重复定义-暂时性死区-切断了全局变量和window属性的映射机制" class="headerlink" title="ES6中let创建的变量不存在变量提升。不允许重复定义  暂时性死区 ,切断了全局变量和window属性的映射机制"></a>ES6中let创建的变量不存在变量提升。不允许重复定义  暂时性死区 ,切断了全局变量和window属性的映射机制</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(a)&#x2F;&#x2F;a is not defined</span><br><span class="line">    let a &#x3D;12</span><br><span class="line">    console.log(window.a)&#x2F;&#x2F;undefined</span><br><span class="line">    console&#x2F;log(a)&#x2F;&#x2F;12</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;var的变量提升&quot;&gt;&lt;a href=&quot;#var的变量提升&quot; class=&quot;headerlink&quot; title=&quot;var的变量提升&quot;&gt;&lt;/a&gt;var的变量提升&lt;/h1&gt;&lt;p&gt;es3/es5&lt;br&gt;1.变量提升：当栈内存（作用域）形成，JS代码自上而下执行之前，浏览器</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>去重排序</title>
    <link href="http://example.com/2018/03/10/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2018/03/10/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%8E%92%E5%BA%8F/</id>
    <published>2018-03-10T10:38:33.000Z</published>
    <updated>2021-01-12T11:30:03.626Z</updated>
    
    <content type="html"><![CDATA[<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序</span><br><span class="line">let arr &#x3D; [23,46,2,5,767,7,4,3]</span><br><span class="line">    for (let i&#x3D;0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">        for(let j&#x3D;0;j&lt;arr.length-1-i;j++)&#123;</span><br><span class="line">            if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">                let temp&#x3D;arr[j+1]</span><br><span class="line">                arr[j+1]&#x3D;arr[j]</span><br><span class="line">                arr[j]&#x3D;temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(arr)&#x2F;&#x2F;[2, 3, 4, 5, 7, 23, 46, 767]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">插入排序</span><br><span class="line">let arr &#x3D; [23,46,2,5,767,7,4,3]</span><br><span class="line">    for(let i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        for(let j&#x3D;i;j&gt;0&amp;&amp;arr[j]&lt;arr[j-1];j--)&#123;</span><br><span class="line">            let temp &#x3D; arr[j]</span><br><span class="line">            arr[j]&#x3D;arr[j-1]</span><br><span class="line">            arr[j-1]&#x3D;temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(arr)&#x2F;&#x2F;[2, 3, 4, 5, 7, 23, 46, 767]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>函数的length</title>
    <link href="http://example.com/2018/03/05/%E5%87%BD%E6%95%B0%E7%9A%84length/"/>
    <id>http://example.com/2018/03/05/%E5%87%BD%E6%95%B0%E7%9A%84length/</id>
    <published>2018-03-05T12:36:48.000Z</published>
    <updated>2021-01-05T11:29:09.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6中的函数length属性"><a href="#ES6中的函数length属性" class="headerlink" title="ES6中的函数length属性"></a>ES6中的函数length属性</h2><p>ES6中函数的length属性，将返回没有指定默认值的参数个数。也就是说指定了默认值后，length属性将失真。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在es6之前函数的length就是指函数声明形参的个数</span><br><span class="line">function fn1()&#123;&#125; &#x2F;&#x2F;length为0</span><br><span class="line">function fn2(a,b)&#123;&#125; &#x2F;&#x2F;length为1</span><br><span class="line">function fn3(a,b,c) &#x2F;&#x2F;length为3</span><br></pre></td></tr></table></figure><p>但是在ES6之后，就发生了变化，因为ES6更新了一个新特性，让函数可以给形参设置默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function fn1(a,b&#x3D;10)&#123;&#125;</span><br><span class="line">&#x2F;&#x2F;这种写法在ES6之前是不允许的</span><br></pre></td></tr></table></figure><p>有了这一新特性之后，length的解释就要修改成这样：length的值是指函数的第一个具有默认值得形参之前的形参的个数！！！<br>写点代码更好理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fn1(a,b)&#123;&#125; &#x2F;&#x2F;因为a,b 没有默认值，length的值为2！</span><br><span class="line">function fn2(a&#x3D;1,b)&#123;&#125; &#x2F;&#x2F;因为a 为‘第一个具有默认值得形参’，而a的前面没有其他形参了，所以length为1</span><br><span class="line">function fn3(a,b&#x3D;1,c)&#123;&#125; &#x2F;&#x2F;b为‘第一个具有默认值的形参’，前面还有一个a，length为1 。</span><br><span class="line">function fn4(a,b,c&#x3D;1)&#123;&#125; &#x2F;&#x2F;所以length为2 因为‘c为第一个具有默认值的形参’</span><br><span class="line">function fn5(a,b&#x3D;1,c,d&#x3D;2)&#123;&#125; &#x2F;&#x2F;length为1。因为‘b为第一个具有默认值的形参’，它前面只有一个a,并且只算</span><br><span class="line">&#x2F;&#x2F;具有默认值形参前面的形参的个数，后面的不算所以是1个。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意，当函数拥有剩余参数时，比如</span><br><span class="line">function fn1(a,...args)&#123;&#125; &#x2F;&#x2F;length为1，剩余参数也有默认值，默认为空数组。前面有只有一个a，所以length为1</span><br><span class="line">function fn1(...args)&#123;&#125; &#x2F;&#x2F;如果函数形参只有一个默认参数，那么length为0！</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ES6中的函数length属性&quot;&gt;&lt;a href=&quot;#ES6中的函数length属性&quot; class=&quot;headerlink&quot; title=&quot;ES6中的函数length属性&quot;&gt;&lt;/a&gt;ES6中的函数length属性&lt;/h2&gt;&lt;p&gt;ES6中函数的length属性，将返</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>嘛是跨域？</title>
    <link href="http://example.com/2018/03/02/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://example.com/2018/03/02/%E8%B7%A8%E5%9F%9F/</id>
    <published>2018-03-02T12:00:36.000Z</published>
    <updated>2020-12-30T12:47:21.577Z</updated>
    
    <content type="html"><![CDATA[<p>资源所在的服务器地址和资源内发起请求的目标服务器地址不同！（两个服务器是不同的）</p><p>　　这里就要说一下浏览器的同源策略问题（服务器之间是没有同源策略的），如果两个URL的协议/主机(域名，IP地址)/端口（默认是80），都相同的话就是同源。如有一个不一样就会发生跨域问题，就是非同源。注意：同源策略是指针对AJXS请求而言，如果不是Ajxs即便非同源也是能请求的。如果用ajxs发起的请求地址和后端地址不同就会跨域</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;资源所在的服务器地址和资源内发起请求的目标服务器地址不同！（两个服务器是不同的）&lt;/p&gt;
&lt;p&gt;　　这里就要说一下浏览器的同源策略问题（服务器之间是没有同源策略的），如果两个URL的协议/主机(域名，IP地址)/端口（默认是80），都相同的话就是同源。如有一个不一样就会发生</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>居中总结</title>
    <link href="http://example.com/2017/06/10/%E5%B1%85%E4%B8%AD%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2017/06/10/%E5%B1%85%E4%B8%AD%E6%80%BB%E7%BB%93/</id>
    <published>2017-06-10T11:55:00.000Z</published>
    <updated>2020-12-30T11:55:35.913Z</updated>
    
    <content type="html"><![CDATA[<p>剧中总结！<br>水平居中</p><p>绝对定位+left+margin-left</p><p>.first{<br>    position: absolute;<br>    left: 50%;<br>    margin-left: -50px;//也就是1/2width<br>}</p><a id="more"></a><p>☠️必须得知道物体的宽高</p><p>2.绝对定位+left+transform</p><p>.second{<br>    position: absolute;<br>    left:50%;<br>    -webkit-transform: translate(-50%);<br>    -moz-transform: translate(-50%);<br>    -ms-transform: translate(-50%);<br>    -o-transform: translate(-50%);<br>    transform: translate(-50%);<br>}<br>😍transform的妙用，translate位移是针对自身的，所以可以不知道自身的宽度，是上面的升级版。</p><p>3.绝对定位+margin+左右</p><p>.third{<br>     margin:auto;<br>     position: absolute;<br>     left:0;<br>     right:0;<br> }<br>😍margin的妙用，如果设置左右为0，那么水平居中，如果设置上下左右都为0，那么就在整个页面居中（也就是水平也居中垂直也居中），换言之，如果值设置上下为0，那么垂直方向居中。</p><p>4.flex布局</p><p>.box{<br>  display:flex;<br>  justify-content:center;<br>}<br>😍很简洁的样子，给父元素设置两行就能做到水平居中了</p><p>相对定位+margin</p><p>.fouth{<br>    position:relative;<br>    margin:x auto x;//x代表随意的数值<br>}<br>😍好简洁</p><p>5.text-align</p><p>.box{<br>    text-align:center;<br>}<br>😍text-align属性只对行内元素有效，比如图片、文字、span等，当然也能让它对div奏效，把块级元素设为行内元素就行了。这个属性是设置在父盒子上面的。一般用来设置图片和文字居中比较多。</p><p>垂直居中</p><p>1.line-height</p><p>.box{<br>  line-height:50px;<br>}<br>😍设置行高，子元素会垂直居中，不论是行内还是块级子元素都有效。 ☠️只对单行文字有效。</p><p>2.多行文字垂直居中</p><p>//第一种<br>.box{<br>  display:table;<br>  height:200px;<br>}<br>.child{<br>  display:table-sell;<br>  vertical-aligh:middle;<br>}<br>//第二种<br>.box{<br>  display:table-sell;<br>  height:200px;<br>  vertical-align:middle;<br>}<br>.child{<br>  display:inline-block;<br>}<br>👉vertical-align是用来指定行内元素和表格单元格（table-sell）元素的垂直对齐方式</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;剧中总结！&lt;br&gt;水平居中&lt;/p&gt;
&lt;p&gt;绝对定位+left+margin-left&lt;/p&gt;
&lt;p&gt;.first{&lt;br&gt;    position: absolute;&lt;br&gt;    left: 50%;&lt;br&gt;    margin-left: -50px;//也就是1/2width&lt;br&gt;}&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
