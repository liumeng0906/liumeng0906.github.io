{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"js严格模式","slug":"js严格模式","date":"2021-06-09T10:47:35.000Z","updated":"2020-12-30T11:00:42.499Z","comments":true,"path":"2021/06/09/js严格模式/","link":"","permalink":"http://example.com/2021/06/09/js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"JavaScript 严格模式(use strict)使用 “use strict” 指令“use strict” 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。 它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。 “use strict” 的目的是指定代码在严格条件下执行。 严格模式下你不能使用未声明的变量。支持严格模式的浏览器:Internet Explorer 10 +、 Firefox 4+ Chrome 13+、 Safari 5.1+、 Opera 12+。 严格模式声明严格模式通过在脚本或者函数的头部添加 ‘use static;表达式来声明 123&quot;use strict&quot;;x &#x3D; 3.14; &#x2F;&#x2F; 报错 (x 未定义)严格模式下，需要用var let 或者 const 来声明 1234567&quot;use strict&quot;;myFunction();function myFunction() &#123; y &#x3D; 3.14; &#x2F;&#x2F; 报错 (y 未定义)&#125;在函数内部声明是局部作用域 (只在函数内使用严格模式): 1234567x &#x3D; 3.14; &#x2F;&#x2F; 不报错myFunction();function myFunction() &#123; &quot;use strict&quot;; y &#x3D; 3.14; &#x2F;&#x2F; 报错 (y 未定义)&#125; 为什么使用严格模式: 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;消除代码运行的一些不安全之处，保证代码运行的安全；提高编译器效率，增加运行速度；为未来新版本的Javascript做好铺垫。“严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。 另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。 1234&quot;use strict&quot;;var x &#x3D; 3.14;delete x; 不允许删除变量或对象 123&quot;use strict&quot;;function x(p1, p1) &#123;&#125;; 不允许变量重名 123&quot;use strict&quot;;var x &#x3D; 010; &#x2F;&#x2F; 报错不允许使用八进制 123&quot;use strict&quot;;var x &#x3D; \\010; &#x2F;&#x2F; 报错不允许使用转义字符: 123456&quot;use strict&quot;;var obj &#x3D; &#123;&#125;;Object.defineProperty(obj, &quot;x&quot;, &#123;value:0, writable:false&#125;);obj.x &#x3D; 3.14; &#x2F;&#x2F; 报错不允许对只读属性赋值 12345&quot;use strict&quot;;var obj &#x3D; &#123;get x() &#123;return 0&#125; &#125;;obj.x &#x3D; 3.14; &#x2F;&#x2F; 报错不允许对一个使用getter方法读取的属性进行赋值 123&quot;use strict&quot;;delete Object.prototype; &#x2F;&#x2F; 报错不允许删除一个不允许删除的属性 123&quot;use strict&quot;;var eval &#x3D; 3.14; &#x2F;&#x2F; 报错变量名不能使用 &quot;eval&quot; 字符串: 123&quot;use strict&quot;;var arguments &#x3D; 3.14; &#x2F;&#x2F; 报错变量名不能使用 &quot;arguments&quot; 字符串 123&quot;use strict&quot;;with (Math)&#123;x &#x3D; cos(2)&#125;; &#x2F;&#x2F; 报错\\不允许使用一下语句 1234&quot;use strict&quot;;eval (&quot;var x &#x3D; 2&quot;);alert (x); &#x2F;&#x2F; 报错由于一些安全原因，在作用域 eval() 创建的变量不能被调用： 1234567891011禁止this关键字指向全局对象。function f()&#123; return !this;&#125; &#x2F;&#x2F; 返回false，因为&quot;this&quot;指向全局对象，&quot;!this&quot;就是falsefunction f()&#123; &quot;use strict&quot;; return !this;&#125; &#x2F;&#x2F; 返回true，因为严格模式下，this的值为undefined，所以&quot;!this&quot;为true。 123456因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。function f()&#123; &quot;use strict&quot;; this.a &#x3D; 1;&#125;;f();&#x2F;&#x2F; 报错，this未定义","categories":[],"tags":[]},{"title":"hook中的API","slug":"Hook","date":"2020-12-26T01:02:04.000Z","updated":"2020-12-30T10:41:37.558Z","comments":true,"path":"2020/12/26/Hook/","link":"","permalink":"http://example.com/2020/12/26/Hook/","excerpt":"","text":"Hook 是React 16.8的新增特性。它可以让你在不编写 class的情况下使用 state 以及其他的 React特性。 Hook是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数 Hook 不能在 class 组件中使用 const [state, setState] = useState(initialState) 返回一个 state,以及更新 state 的函数 当 state 为引用类型，修改时注意要合并其他值，不然会发生错误 多个 state 最好分开写 setState 也可以接收一个函数 1234567891011121314151617181920212223242526272829303132333435function Home()&#123; const [count, setCount] &#x3D; useState(0) &#x2F;&#x2F;也可以在state里写对象 const [person, setPerson] &#x3D; useState(&#123; name:&#39;大黄&#39;, age:&#39;18&#39;, sex:&#39;女&#39; &#125;) const [num,setNum] &#x3D; useState(100) return ( &lt;div&gt; 我是todolist count:&#123;count&#125; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setCount(count+1)&#125;&#125;&gt;加+&lt;&#x2F;button&gt; &#123;&#x2F;* setCount和class组件setState是一样的都是修改state的状态的*&#x2F;&#125; &lt;div&gt; name:&#123;person.name&#125; age:&#123;person.age&#125; sex:&#123;person.sex&#125; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setPerson(&#123;age:19&#125;)&#125;&#125;&gt;给大黄过年&lt;&#x2F;button&gt; &#123;&#x2F;* 这里当我们点击了按钮调用setState，只修改了age,虽然年龄变成了19，但是其他属性都为空了，所以说 在调用setState时，如果它是个引用类型时我们要它另外值合并一下 onClick&#x3D;&#123;()&#x3D;&gt;&#123;setPerson(&#123;age:19,name:person.name,sex:person.sex&#125;)&#125;&#125; 这样写就没问题了 *&#x2F;&#125; &lt;&#x2F;div&gt; &lt;div&gt; 计数：&#123;num&#125; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setNum((oval)&#x3D;&gt;&#123;console.log(oval);return oval+1&#125;)&#125;&#125;&gt;&lt;&#x2F;button&gt; &#123;&#x2F;* setState还可以接收一个函数 *&#x2F;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; )&#125;export default Home useEffect12345678910111213141516171819202122232425262728 useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;参数是个函数：也叫副作用函数 return ()&#x3D;&gt;&#123;&#125;&#x2F;&#x2F;返回函数 返回的函数式可选的 可以不写返回函数 &#125;,[])&#x2F;&#x2F;这里的数组是依赖参数 依赖也是可选的 作用函数： 1.当useEffect ,没有依赖参数时，副作用函数，会在组件挂载完成及组件更新完成时执行 2.当有依赖参数副作用函数，会在组件挂载完成及改依赖参数修改，引起的组件更新完成之后执行 3.当依赖参数为空数组时，会在组件挂载完成之后执行 4.返回函数在组件更新完成，或即将写在执行，一般返回函数用在即将卸载时 useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;当没有依赖参数和返回函数的时候，现在就相当于class组件的componentDidMount、componentUpdate生命周期 console.log(1,&#39;useEffect&#39;)&#x2F;&#x2F;一直触发btn，一直在打印&#125;)useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;当依赖参数为空和没有返回函数时，只执行了一次，后面在触发btn时，不在执行.相当于componentDidMount console.log(2,&#39;useEffect&#39;)&#125;,[])useEffect(()&#x3D;&gt;&#123; console.log(3,&#39;useEffect&#39;)&#125;,[name])&#x2F;&#x2F;在有依赖参数时，组件挂载完会执行一次，在后面触发btn时，如果依赖参数没有发生改变，不会再打印useEffect(()&#x3D;&gt;&#123; return ()&#x3D;&gt;&#123; console.log(4,&#39;useEffect&#39;) &#125;&#x2F;&#x2F;当没有依赖，有返回函数的时候，初次挂载完返回函数不会执行，但是当触发btn时，就是组件发生改变，它就会执行返回函数的代码&#125;,)&#x2F;&#x2F;如果此处有依赖，但不空，那就当依赖的参数发生改变的时候，返回函数内的代码也会执行useEffect(()&#x3D;&gt;&#123; return ()&#x3D;&gt;&#123; console.log(&#39;更新或者卸载&#39;) &#125;&#125;,[count])&#x2F;&#x2F;也可以有依赖参数并且会更新用返回函数进行卸载或更新&#x2F;&#x2F;缺点：挂载前和更新前的生命周期要用到别的方法来配合使用useEffect。这里更多的是挂载完和更新完 useLayoutEffect其函数签名与useEffect相同，但它会在所有的DOM变更之后同步调用effect。可以使用它来读取DOM布局并同步触发重渲染，在浏览器执行绘制之前，useLayoutEffect内部的更新计划将不同步刷新 useContext123456789101112131415161718192021222324252627282930一个简单的传参案例基本就能明白useContext是在干神马。import React,&#123;createContext, useContext&#125; from &#39;react&#39;const DemoContext &#x3D; createContext(&#123;data:&#39;hello&#39;&#125;)function A ()&#123; return ( &lt;DemoContext.Provider value&#x3D;&#123;&#123;data:value&#125;&#125;&gt; &lt;B&gt;&lt;&#x2F;B&gt; &lt;&#x2F;DemoContext.Provider&gt; )&#125;function B()&#123; return ( &lt;div&gt; 儿子组件 &lt;C&gt;&lt;&#x2F;C&gt; &lt;&#x2F;div&gt; )&#125;function C()&#123; const text &#x3D; useContext(DemoContext) return ( &lt;div&gt; 孙子组件 &#123; text.data &#125; &lt;&#x2F;div&gt; )&#125;export default A useReducer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119在我们的需要处理的数据足够简单时，用useState就能完成。如果数据比较复杂了那么就可以考虑用useReducer这个先说下useReducer跟Store没关系，他只是借用了store的那套思想直接上案例import React, &#123; useState, useEffect, useReducer, useRef &#125; from &#39;react&#39;import &#123; withRouter &#125; from &#39;react-router-dom&#39;import &#123; connect &#125; from &#39;react-redux&#39;import s from &#39;.&#x2F;index.module.scss&#39;let init &#x3D; &#123; list: [&#123; id:1, name:&#39;澳门豆捞&#39;, open:1&#125;] &#125;function reducer(state, action) &#123; switch (action.type) &#123; case &#39;add&#39;: let arr &#x3D; JSON.parse(JSON.stringify(state.list)) arr.push(&#123; id: state.list.length &gt; 0 ? state.list[state.list.length-1].id + 1 : 1, name: action.name, open: 1, &#125;) return &#123;list:arr&#125; case &#39;close&#39;: for(let i&#x3D;0;i&lt;state.list.length;i++)&#123; if(state.list[i].id&#x3D;&#x3D;action.id)&#123; state.list[i].open&#x3D;2 &#125; &#125; return JSON.parse(JSON.stringify(state)) case &#39;open&#39;: for(let i&#x3D;0;i&lt;state.list.length;i++)&#123; if(state.list[i].id&#x3D;&#x3D;action.id)&#123; state.list[i].open&#x3D;1 &#125; &#125; return JSON.parse(JSON.stringify(state)) case &#39;set&#39;: for(let i&#x3D;0;i&lt;state.list.length;i++)&#123; if(state.list[i].id&#x3D;&#x3D;action.id)&#123; state.list[i].open&#x3D;3 &#125; &#125; return JSON.parse(JSON.stringify(state)) case &#39;del&#39;: for(let i&#x3D;0;i&lt;state.list.length;i++)&#123; if(state.list[i].id&#x3D;&#x3D;action.id)&#123; state.list.splice(i,1) &#125; &#125; return JSON.parse(JSON.stringify(state)) default: return state &#125;&#125;function Homet(props) &#123; const inp &#x3D; useRef(null) const [state, dispatch] &#x3D; useReducer(reducer, init) function btn() &#123; if (!inp.current.value) &#123; alert(&#39;输入不能为空&#39;) &#125; else &#123; dispatch(&#123; type: &#39;add&#39;, name: inp.current.value, &#125;) inp.current.value&#x3D;null &#125; &#125; return ( &lt;div className&#x3D;&#123;s.homet&#125;&gt; &lt;div className&#x3D;&#123;s.head&#125;&gt; &lt;span&gt;Todo后台管理&lt;&#x2F;span&gt; &lt;div className&#x3D;&#123;s.inpBox&#125;&gt; &lt;input ref&#x3D;&#123;inp&#125; placeholder&#x3D;&#39;请输入内容&#39; &#x2F;&gt; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; btn()&#125; className&#x3D;&#123;s.btn&#125;&gt;添加&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div className&#x3D;&#123;s.cont&#125;&gt; &#123; state.list.length &gt; 0 ? state.list.map((item, i) &#x3D;&gt; &lt;div className&#x3D;&#123;s.item&#125; key&#x3D;&#123;i&#125;&gt; &lt;img &#x2F;&gt; &lt;div className&#x3D;&#123;s.all&#125;&gt; &lt;span className&#x3D;&#123;s.name&#125;&gt;&#123;item.name&#125;&lt;&#x2F;span&gt; &lt;span&gt;&#123;item.open &#x3D;&#x3D; 1 ? &#39;营业中&#39; : item.open &#x3D;&#x3D; 2 ? &#39;已打烊&#39; : &#39;装修中&#39;&#125;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;div className&#x3D;&#123;s.del&#125;&gt; &#123; item.open &#x3D;&#x3D; 1 ? &lt;div className&#x3D;&#123;s.btnBox&#125;&gt; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;close&#39;,id:item.id&#125;)&#125; className&#x3D;&#123;s.margin&#125;&gt;打烊&lt;&#x2F;button&gt; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;set&#39;,id:item.id&#125;)&#125;&gt;装修&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; : item.open &#x3D;&#x3D; 2 ? &lt;div className&#x3D;&#123;s.btnBox&#125;&gt; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;open&#39;,id:item.id&#125;)&#125; className&#x3D;&#123;s.margin&#125;&gt;营业&lt;&#x2F;button&gt; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;set&#39;,id:item.id&#125;)&#125;&gt;装修&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; : &lt;div className&#x3D;&#123;s.btnBox&#125;&gt; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;open&#39;,id:item.id&#125;)&#125; className&#x3D;&#123;s.margin&#125;&gt;营业&lt;&#x2F;button&gt; &lt;button&gt;待完成&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &#125; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;del&#39;,id:item.id&#125;)&#125; className&#x3D;&#123;s.shan&#125;&gt;删除&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;) : &lt;span className&#x3D;&#123;s.no&#125;&gt;暂无数据&lt;&#x2F;span&gt; &#125; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; )&#125;let mapStateToProps &#x3D; (state) &#x3D;&gt; &#123; console.log(state) return &#123; list: state.list.list &#125;&#125;let mapDispatchToProps &#x3D; (dispatch) &#x3D;&gt; &#123; return &#123; &#125;&#125;Homet &#x3D; withRouter(Homet)export default connect(mapStateToProps, mapDispatchToProps)(Homet)","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-12-25T01:36:20.562Z","updated":"2020-12-25T01:36:20.562Z","comments":true,"path":"2020/12/25/hello-world/","link":"","permalink":"http://example.com/2020/12/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"简易防抖节流","slug":"简易防抖节流","date":"2019-03-12T10:28:25.000Z","updated":"2021-01-12T11:32:57.251Z","comments":true,"path":"2019/03/12/简易防抖节流/","link":"","permalink":"http://example.com/2019/03/12/%E7%AE%80%E6%98%93%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/","excerpt":"","text":"函数防抖123456789101112var inp &#x3D; document.querySelector(&#39;.inp&#39;) function fn(callBack,num)&#123; let timer ; return function ()&#123; if(timer) clearTimeout(timer) timer &#x3D; setTimeout(callBack,num) &#125; &#125; function handel()&#123; console.log(&#39;函数防抖&#39;) &#125; inp.addEventListener(&#39;keyup&#39;,fn(handel,1000)) 节流 在N秒内函数执行一次123456789101112131415var inp &#x3D; document.queruSelector(&#39;.inp&#39;) function fn(callBack,num)&#123; let lock &#x3D; true return function ()&#123; lock &#x3D; false setTimeout(()&#x3D;&gt;&#123; lock&#x3D;true callBack &#125;,num) &#125; &#125; function handel()&#123; console.log(&#39;节流&#39;) &#125; inp.addEventListener(&#39;click&#39;,fn(handel,1000))","categories":[],"tags":[]},{"title":"history","slug":"history","date":"2018-11-28T09:43:06.000Z","updated":"2021-01-28T10:00:22.160Z","comments":true,"path":"2018/11/28/history/","link":"","permalink":"http://example.com/2018/11/28/history/","excerpt":"","text":"history:接口允许操作浏览器的曾经在标签页或者框架里访问的绘画历史记录。history不继承任何接口。就是它不需要别的接口来调用它，想使用它直接使用就行。 属性 history.length :它返回一个整数，该整数表示会话历史中元素的数目，包括当前加载的页。 history.scrollRestorration:允许Web应用程序在历史导航上显式地设置默认滚动恢复行为。此属性可以是自动的或者手动的 history.state:返回一个表示历史堆栈顶部的状态的值，这是一种可以不必等待popstate事件而查看状态的事件方法 history.back() 在浏览器历史记录里前往上一页，用户可点击浏览器左上角的返回 等同于 history.go(-1) history.forward() 在浏览器历史记录里前往下一页，用户可点击浏览器左上角的前进 等同于history.go(1) history.pushState() 按指定的名称和URL（如果提供该参数）将数据push进会话历史栈，数据被DOM进行不透明处理；你可以指定任何可以被序列化的javascript对象。注意到Firefox现在忽略了这个title参数 history.replaceState() 按指定的数据，名称和URL(如果提供该参数)，更新历史栈上最新的入口。这个数据被DOM 进行了不透明处理。你可以指定任何可以被序列化的javascript对象。注意到Firefox现在忽略了这个title参数","categories":[],"tags":[]},{"title":"Proxy","slug":"Proxy","date":"2018-10-11T12:54:45.000Z","updated":"2021-01-28T09:43:51.520Z","comments":true,"path":"2018/10/11/Proxy/","link":"","permalink":"http://example.com/2018/10/11/Proxy/","excerpt":"","text":"async函数默认返回一个Promise对象proxy 对对象操作进行拦截new Proxy()接受两个参数，第一个是目标对象，另一个是拦截方法12345678910111213let obj &#x3D; &#123; name:&#39;hello&#39;, age:&#39;18&#39; &#125; &#x2F;&#x2F;相当于proxy1代理了obj,需要通过proxy1 去操作代理的obj let proxy1 &#x3D; new Proxy(obj,&#123; get(target,key,proxy)&#123;&#x2F;&#x2F;get 方法只要是对对象进行获取操作就会触发get方法 console.log(arguments)&#x2F;&#x2F;得到target:目标对象和key:name属性名，以及proxy实例 &#x2F;&#x2F;这里return什么，就会返回什么，如果没有return，就是undefined console.log(&#39;触发了&#39;) return target[key]&#x2F;&#x2F;返回属性name的值 &#125;&#125;) console.log(proxy1.name)&#x2F;&#x2F;&#39;触发了&#39; 12Proxy 用于修改某些操作默认行为，等同于在语言层面做出修改，所以属于一种‘元编程’(meta progrmming),即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层‘拦截’，外界对该对象的访问，都必须先通过这层拦截，因此提供一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由他来‘代理’某些操作，可以译为‘代理器’。 为什么需要 Proxy1.被代理的对象不想直接被访问2.控制和修改被代理对象的行为（调用属性、属性赋值、方法调用等等），使之可以进行访问控制和增加功能。 API 概览如下： get(target, propKey, receiver)：拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’] 。set(target, propKey, value, receiver)：拦截对象属性的设置，比如 proxy.foo = v 或 proxy[‘foo’] = v ，返回一个布尔值。has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。deleteProperty(target, propKey)：拦截 delete proxy[propKey]的操作，返回一个布尔值。ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy) 、 Object.getOwnPropertySymbols(proxy) 、 Object.keys(proxy) 、 for…in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。getOwnPropertyDescriptor(target, propKey)：拦截 Object.getOwnPropertyDescriptor(proxy, propKey) ，返回属性的描述对象。defineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc） 、Object.defineProperties(proxy, propDescs)，返回一个布尔值。preventExtensions(target)：拦截 Object.preventExtensions(proxy) ，返回一个布尔值。getPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy)，返回一个对象 。isExtensible(target)：拦截 Object.isExtensible(proxy) ，返回一个布尔值。setPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto) ，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如 proxy(…args)、proxy.call(object, …args)、proxy.apply(…)`。construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(…args) 。 最常用的一般就是 get()和set()get()get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。 get方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。 1234567891011121314151617var person &#x3D; &#123; name: &quot;张三&quot;&#125;;var proxy &#x3D; new Proxy(person, &#123; get: function(target, propKey) &#123; if (propKey in target) &#123; return target[propKey]; &#125; else &#123; throw new ReferenceError(&quot;Prop name \\&quot;&quot; + propKey + &quot;\\&quot; does not exist.&quot;); &#125; &#125;&#125;);proxy.name &#x2F;&#x2F; &quot;张三&quot;proxy.age &#x2F;&#x2F; 抛出一个错误上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。 1234567891011get方法可以继承。let proto &#x3D; new Proxy(&#123;&#125;, &#123; get(target, propertyKey, receiver) &#123; console.log(&#39;GET &#39; + propertyKey); return target[propertyKey]; &#125;&#125;);let obj &#x3D; Object.create(proto);obj.foo &#x2F;&#x2F; &quot;GET foo&quot;上面代码中，拦截操作定义在Prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效。 1234567891011121314151617181920下面的例子使用get拦截，实现数组读取负数的索引。function createArray(...elements) &#123; let handler &#x3D; &#123; get(target, propKey, receiver) &#123; let index &#x3D; Number(propKey); if (index &lt; 0) &#123; propKey &#x3D; String(target.length + index); &#125; return Reflect.get(target, propKey, receiver); &#125; &#125;; let target &#x3D; []; target.push(...elements); return new Proxy(target, handler);&#125;let arr &#x3D; createArray(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);arr[-1] &#x2F;&#x2F; c上面代码中，数组的位置参数是-1，就会输出数组的倒数第一个成员。 123456789101112131415161718192021222324利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。var pipe &#x3D; function (value) &#123; var funcStack &#x3D; []; var oproxy &#x3D; new Proxy(&#123;&#125; , &#123; get : function (pipeObject, fnName) &#123; if (fnName &#x3D;&#x3D;&#x3D; &#39;get&#39;) &#123; return funcStack.reduce(function (val, fn) &#123; return fn(val); &#125;,value); &#125; funcStack.push(window[fnName]); return oproxy; &#125; &#125;); return oproxy;&#125;var double &#x3D; n &#x3D;&gt; n * 2;var pow &#x3D; n &#x3D;&gt; n * n;var reverseInt &#x3D; n &#x3D;&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0;pipe(3).double.pow.reverseInt.get; &#x2F;&#x2F; 63上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。 12345678910111213141516171819202122232425262728293031下面的例子则是利用get拦截，实现一个生成各种 DOM 节点的通用函数dom。const dom &#x3D; new Proxy(&#123;&#125;, &#123; get(target, property) &#123; return function(attrs &#x3D; &#123;&#125;, ...children) &#123; const el &#x3D; document.createElement(property); for (let prop of Object.keys(attrs)) &#123; el.setAttribute(prop, attrs[prop]); &#125; for (let child of children) &#123; if (typeof child &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123; child &#x3D; document.createTextNode(child); &#125; el.appendChild(child); &#125; return el; &#125; &#125;&#125;);const el &#x3D; dom.div(&#123;&#125;, &#39;Hello, my name is &#39;, dom.a(&#123;href: &#39;&#x2F;&#x2F;example.com&#39;&#125;, &#39;Mark&#39;), &#39;. I like:&#39;, dom.ul(&#123;&#125;, dom.li(&#123;&#125;, &#39;The web&#39;), dom.li(&#123;&#125;, &#39;Food&#39;), dom.li(&#123;&#125;, &#39;…actually that\\&#39;s it&#39;) ));document.body.appendChild(el); 12345678下面是一个get方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。const proxy &#x3D; new Proxy(&#123;&#125;, &#123; get: function(target, key, receiver) &#123; return receiver; &#125;&#125;);proxy.getReceiver &#x3D;&#x3D;&#x3D; proxy &#x2F;&#x2F; true上面代码中，proxy对象的getReceiver属性是由proxy对象提供的，所以receiver指向proxy对象。 123456789const proxy &#x3D; new Proxy(&#123;&#125;, &#123; get: function(target, key, receiver) &#123; return receiver; &#125;&#125;);const d &#x3D; Object.create(proxy);d.a &#x3D;&#x3D;&#x3D; d &#x2F;&#x2F; true上面代码中，d对象本身没有a属性，所以读取d.a的时候，会去d的原型proxy对象找。这时，receiver就指向d，代表原始的读操作所在的那个对象。 123456789101112131415161718如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。const target &#x3D; Object.defineProperties(&#123;&#125;, &#123; foo: &#123; value: 123, writable: false, configurable: false &#125;,&#125;);const handler &#x3D; &#123; get(target, propKey) &#123; return &#39;abc&#39;; &#125;&#125;;const proxy &#x3D; new Proxy(target, handler);proxy.foo&#x2F;&#x2F; TypeError: Invariant check failed set()12345678910111213141516171819202122232425let obj&#x3D;&#123; name:&#39;hello world&#39;, &#125; let proxy2 &#x3D; new Proxy(obj,&#123; get(target,key,receiver)&#123; return target[key]&#x2F;&#x2F;获取想要得到的属性 &#125;, set(target,key,value,receiver)&#123; console.log(&#39;要设置&#39;) console.log(arguments) &#x2F;&#x2F;key这里就是要设置的那个age属性 target[key]&#x3D;value return true &#x2F;&#x2F;最后返回一个布尔值 &#125;, has(target,key)&#123;&#x2F;&#x2F;拦截in这个操作。接收两个参数，目标对象和判断的那个属性名 if(key.startsWith(&#39;_&#39;))&#123;&#x2F;&#x2F;判断下是否是带__的属性比如&#39;__proto__&#39; return false &#125;else&#123; return key in target &#125; &#125;, &#125;) proxy2.age&#x3D;10&#x2F;&#x2F;这里我们想要给obj设置一个age为10的属性 console.log(obj) console.log(&#39;name&#39; in proxy2) apply()//拦截实例作为函数调用的时候：proxy3()1234567891011121314151617181920212223function query()&#123; console.log(this) return &#123;name:&#39;hello world&#39;&#125; &#125; let obj &#x3D; &#123;name:&#39;北京&#39;&#125; let proxy3 &#x3D; new Proxy(query,&#123; apply(target,object,args)&#123; &#x2F;&#x2F;函数直接执行()、通过call执行、apply执行，都会触发此处。 &#x2F;&#x2F;object 给函数修改this &#x2F;&#x2F; args 函数执行的参数 console.log(&#39;执行&#39;) console.log(target,object,args) if(object)&#123; object.fn&#x3D;target object.fn(...args) delete object.fn &#125;else&#123; target(...args) &#125; &#125; &#125;) proxy3() console.log(proxy3.call(obj,1,2,3))","categories":[],"tags":[]},{"title":"属性描述符","slug":"属性描述符","date":"2018-10-02T13:59:58.000Z","updated":"2021-01-03T05:51:03.870Z","comments":true,"path":"2018/10/02/属性描述符/","link":"","permalink":"http://example.com/2018/10/02/%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/","excerpt":"","text":"Object.definePropertyObject.defineProperty(obj,prop,desctiptor)接受3个参数。obj:接受一个对象、prop:定义或修改的属性或Smybol、descriptor:属性描述符 123456 let obj &#x3D;&#123; name:&#39;hello&#39;&#125;Object.defineProperty(obj,&#39;sex&#39;,&#123;value:&#39;world&#39;&#125;)console.log(Object.keys(obj))&#x2F;&#x2F;只拿到了name 因为用上面定义的方法给对象添加的属性是不可枚举的所以它并不能被拿到 对象里目前存在属性描述符有两种主要形式：数据描述符合存取描述符。数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。存取描述符是由getter函数和setter函数所描述的属性。一个描述符只能是这两种其中之一，不能同时是两者这两种描述符都是对象。他们共享一下可选键值(默认值是指咋使用Object.definPropety()定义属性时的默认值)configurable当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。enumerable当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。默认为 false。数据描述符还具有以下可选键值： value该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。writable当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变。默认为 false。存取描述符还具有以下可选键值： get属性的 getter 函数，如果没有 getter，则为 undefined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。默认为 undefined。set属性的 setter 函数，如果没有 setter，则为 undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined。 1234567891011121314151617181920212223242526272829303132333435var o &#x3D; &#123;&#125;; &#x2F;&#x2F; 创建一个新对象&#x2F;&#x2F; 在对象中添加一个属性与数据描述符的示例Object.defineProperty(o, &quot;a&quot;, &#123; value : 37, writable : true, enumerable : true, configurable : true&#125;);&#x2F;&#x2F; 对象 o 拥有了属性 a，值为 37&#x2F;&#x2F; 在对象中添加一个设置了存取描述符属性的示例var bValue &#x3D; 38;Object.defineProperty(o, &quot;b&quot;, &#123; &#x2F;&#x2F; 使用了方法名称缩写（ES2015 特性） &#x2F;&#x2F; 下面两个缩写等价于： &#x2F;&#x2F; get : function() &#123; return bValue; &#125;, &#x2F;&#x2F; set : function(newValue) &#123; bValue &#x3D; newValue; &#125;, get() &#123; return bValue; &#125;, set(newValue) &#123; bValue &#x3D; newValue; &#125;, enumerable : true, configurable : true&#125;);o.b; &#x2F;&#x2F; 38&#x2F;&#x2F; 对象 o 拥有了属性 b，值为 38&#x2F;&#x2F; 现在，除非重新定义 o.b，o.b 的值总是与 bValue 相同&#x2F;&#x2F; 数据描述符和存取描述符不能混合使用Object.defineProperty(o, &quot;conflict&quot;, &#123; value: 0x9f91102, get() &#123; return 0xdeadbeef; &#125;&#125;);&#x2F;&#x2F; 抛出错误 TypeError: value appears only in data descriptors, get appears only in accessor descriptors 自定义 Setters 和 Getters下面的例子展示了如何实现一个自存档对象。当设置temperature 属性时，archive 数组会收到日志条目。 1234567891011121314151617181920212223function Archiver() &#123; var temperature &#x3D; null; var archive &#x3D; []; Object.defineProperty(this, &#39;temperature&#39;, &#123; get: function() &#123; console.log(&#39;get!&#39;); return temperature; &#125;, set: function(value) &#123; temperature &#x3D; value; archive.push(&#123; val: temperature &#125;); &#125; &#125;); this.getArchive &#x3D; function() &#123; return archive; &#125;;&#125;var arc &#x3D; new Archiver();arc.temperature; &#x2F;&#x2F; &#39;get!&#39;arc.temperature &#x3D; 11;arc.temperature &#x3D; 13;arc.getArchive(); &#x2F;&#x2F; [&#123; val: 11 &#125;, &#123; val: 13 &#125;] 继承属性如果访问者的属性是被继承的，它的 get 和 set 方法会在子对象的属性被访问或者修改时被调用。如果这些方法用一个变量存值，该值会被所有对象共享。 1234567891011121314151617function myclass() &#123;&#125;var value;Object.defineProperty(myclass.prototype, &quot;x&quot;, &#123; get() &#123; return value; &#125;, set(x) &#123; value &#x3D; x; &#125;&#125;);var a &#x3D; new myclass();var b &#x3D; new myclass();a.x &#x3D; 1;console.log(b.x); &#x2F;&#x2F; 1 Object.assign()Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。 12345678910111213let obj1 &#x3D; &#123; name:&#39;hong&#39;, sex:&#39;女&#39;&#125;let obj2 &#x3D; &#123; age:&#39;18&#39;, get sayName()&#123; return &#39;hong&#39; &#125;&#125;let obj3 &#x3D; Object.assign(&#123;&#125;,obj1,obj2)console.log(obj3)&#x2F;&#x2F;此时合并完，就会把obj2里的存取属性给变成了数据属性&#x2F;&#x2F;应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。 异常会打断后续拷贝任务1234567891011121314const target &#x3D; Object.defineProperty(&#123;&#125;, &quot;foo&quot;, &#123; value: 1, writable: false&#125;); &#x2F;&#x2F; target 的 foo 属性是个只读属性。Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);&#x2F;&#x2F; TypeError: &quot;foo&quot; is read-only&#x2F;&#x2F; 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。console.log(target.bar); &#x2F;&#x2F; 2，说明第一个源对象拷贝成功了。console.log(target.foo2); &#x2F;&#x2F; 3，说明第二个源对象的第一个属性也拷贝成功了。console.log(target.foo); &#x2F;&#x2F; 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。console.log(target.foo3); &#x2F;&#x2F; undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。console.log(target.baz); &#x2F;&#x2F; undefined，第三个源对象更是不会被拷贝到的。 拷贝访问器(手动实现你原来是个存取属性，现在通过Object.assign()拷贝过来还是存取属性)123456789101112131415161718192021222324252627282930313233const obj &#x3D; &#123; foo: 1, get bar() &#123; return 2; &#125;&#125;;let copy &#x3D; Object.assign(&#123;&#125;, obj);console.log(copy); &#x2F;&#x2F; &#123; foo: 1, bar: 2 &#125; copy.bar的值来自obj.bar的getter函数的返回值&#x2F;&#x2F; 下面这个函数会拷贝所有自有属性的属性描述符function completeAssign(target, ...sources) &#123; sources.forEach(source &#x3D;&gt; &#123; let descriptors &#x3D; Object.keys(source).reduce((descriptors, key) &#x3D;&gt; &#123; descriptors[key] &#x3D; Object.getOwnPropertyDescriptor(source, key); return descriptors; &#125;, &#123;&#125;); &#x2F;&#x2F; Object.assign 默认也会拷贝可枚举的Symbols Object.getOwnPropertySymbols(source).forEach(sym &#x3D;&gt; &#123; let descriptor &#x3D; Object.getOwnPropertyDescriptor(source, sym); if (descriptor.enumerable) &#123; descriptors[sym] &#x3D; descriptor; &#125; &#125;); Object.defineProperties(target, descriptors); &#125;); return target;&#125;copy &#x3D; completeAssign(&#123;&#125;, obj);console.log(copy);&#x2F;&#x2F; &#123; foo:1, get bar() &#123; return 2 &#125; &#125;","categories":[],"tags":[]},{"title":"express","slug":"express","date":"2018-08-30T13:57:46.000Z","updated":"2020-12-30T11:58:53.011Z","comments":true,"path":"2018/08/30/express/","link":"","permalink":"http://example.com/2018/08/30/express/","excerpt":"","text":"简单使用express首先安装 npm i express 、body-parser (post请求需要用到) 1.分别引用：import express from ‘express’;(如果没有引用bable,可以用require()引用) import baodyParser from ‘body-parser’; import fs from ‘fs’ import path from ‘path’ const app=express() //创建一个express应用 const post=3000 端口号 用一下body-parser :app.use(bodyParser.json()) app.use(bodyParser.urlencoded({extended:false})) 下面就可以使用 get post 进行请求了 app.post(‘/post’,(req,res)=&gt;{ }) app.get(‘/gett’,(req,res)=&gt;{ }) app.listen(post,()=&gt;{//监听端口号 console.log(post) }) 题外：1.关于express中间件的简单概述：在use(),get(),post()等方法里面是都可以使用中间件的。写法：app.user((req,res,next)=&gt;{ console.log(‘继续往下走’) next()//如果不写next它是不会继续执行下面代码的 由此可简单说一个例子：就是有了这个中间件我们可以把一些公共逻辑放在use()方法中来执行，如果可行就next()继续往下走，否则停止本次请求。因为use()方法不管什么请求都会走进来！我们可以在这里进行账号密码的校验，因为不论登录还是注册都是要校验的，所以不可能登录和注册的接口都要写一遍校验。这个时候我们可以把校验这段逻辑放在use()方法中，如果校验通过就可以继续请求，否则直接停止。所以有了它就可以减少代码冗余问题。 }) 2. express 重定向：使用 express.get(‘*’,(req,res)=&gt;{//就是当所有的请求都找不到时，给它重定向到一个专门的404页面。第一个参数是 *（通配符 所有），后面依然是回调函数 express.redirect(‘404.网页’)//用redirect方法做重定向 }) 3. 请求对象req的方法： req.body :获取post请求体的数据 req.query获取get请求的数据 req.originnalUrl 获取原始url地址、当需要处理路径的时候可以还可以用req.baseUrl，req.path 这三个方法是可以操作url的。 req.get(‘Content-type’)用来获取请求头 4. 响应对象res的方法： res.set(‘key’,value)设置响应头 key:响应头的字段名称 。 value:值。 res.send()发送数据 res.senfFile()发送文件 res.redirect()重新定向 参数是文件的地址 res.download()下载 res.jsonp()以jsonp的方式返回数据","categories":[],"tags":[]},{"title":"手写Promise","slug":"手写Promise","date":"2018-05-25T14:10:50.000Z","updated":"2020-12-27T12:35:16.339Z","comments":true,"path":"2018/05/25/手写Promise/","link":"","permalink":"http://example.com/2018/05/25/%E6%89%8B%E5%86%99Promise/","excerpt":"","text":"手写Promise 主要是解决回调地狱的问题，在ES6中出现了promise来解决这个问题，但是同样也带来了多个.then()的问题 //随着es7 async和await到来可以说彻底解决回调地狱。 new Promise() //是谁执行了？直接new一个Promise是内置构造Promise执行了，但是它会报错。因为这里缺一个回调函数，平常大家也都是这么用的 new Promise(()=&gt;{ console.log(‘你大爷’)//‘你大爷’会执行吗？：这里new了一个Promose,Promise执行一次，那里面的回调函数也会执行，所以‘你大爷’成功被打印 }) function fn(callBack){ &#125; new fn(()=&gt;&#123; &#125;)//fn执行，但是里面的回调并没有，Promise的回调会执行。 //new Promise 是内置构造函数Promise执行一次 //Promise的回调函数也会执行一次，这个回调函数会给我们提供两个形参（函数）：成功、失败 //Promise的回调函数，又有两个参数分别是：resolve、reject两个函数 //Promise类的实例没有then方法，应该是原型对象的方法 var obj = new Promise((resolve,rejecct)=&gt;&#123; console.log(resolve,reject)//两个函数 &#125;)//obj是Promise的一个实例 // 手写 function myPromise(callBack)&#123;//接受传进来的回调函数 //状态属性 this.status=&#39;pending&#39; //回调函数 callBack(resolve.bind(this),reject.bing(this)) //定义一个成功的函数 function resolve(hello, params)&#123; //那么console.log(hello)肯定是执行的（很早演示时写） //修改状态（后写） if(this.status===&#39;pending&#39;)&#123;//如果出事状态为pengding, this.status=&#39;success&#39;//那就把它改成success成功 //这里还有一个上下文的问题。成功时resolve是怎么调用的？是函数名+小括号，也就是window. //但这里就不该用window，因为将来获取服务器的数据实在.then()里的来获取。所以我们在初始化时就要给 //resolve和reject绑死这个类的实例：resolve.bind(this) reject.bing(this) 走起上面绑死↑ //否则你在调用resolve和reject时他们就会指向window //为什么绑死上下文为这个类的实例？因为我们要借用这个类的实例的成功和失败的方法74行里面成功与失败的回调 //所以↓ this.successCallBack(params)//这个是谁？它就是then的第一个参数也就是成功的回调，所以把参数直接注进来就行了 //失败同样 &#125; &#125; //定义一个失败的函数 function reject(err)&#123; if(this.status===&#39;pending&#39;)&#123; this.status=&#39;faile&#39; this.faileCallBack(err) &#125; &#125; &#125; //调用 new myPromise(()=&gt;&#123;//并且传进去一个回调函数。但是我们在实际运用中肯定要传2个参数进去。resolve,reject,并且37行回调也要接受这个2个函数 //console.log(&#39;我是Promise&#39;)//这里肯定会执行。打印。 //假如这里调用并传参resolve(&#39;hello&#39;) //处理异步,一般promise就是处理异步的 setTimeout(()=&gt;&#123; resolve(&#39;我是promise&#39;) &#125;) &#125;)//假如我们是在处理异步请求那么肯定要在这.then()。但是能直接.then()吗？要注意.then()是在原型上面的。虽然链式语法可以这么写，但是这里并没有这个方法。.then()应该是原型上面类的原型的方法 .then((data)=&gt;&#123; console.log(data) &#125;,()=&gt;&#123;&#125;)//一般我们在调用then()的时候肯定要传2个参数进去，下面接收，就是相当于将then方法里面成功与失败的回调函数当做当前类的实例即可，当前类是谁？promise //所以原型上定义一个then的方法，应该是 myPromise.prototype.then=function(success,faile)&#123;//接收上面调用then时传进来的来个函数。就是将then方法里面成功与失败的回到函数作为当前类的实例即可 this.successCallBack=success//相当于then传进一个成功的函数给了success,就是给myPromise的实例动态添加了属性就是success这个成功的箭头函数。还有一个失败的同样 this.faileCallBack=faile //then()的两个函数相当于作为这个实例的两个方法 &#125; //53行异步成功后执行，就是相当于调用了41行那个方法。失败同样 //因为promise有3中状态，pending、成功、失败。所以此时我去上面给类定义个状态的属性，走起↑ //如果说异步解决成功就调用resolve方法 。resolve就是41行函数执行。但是我们都是在then()来获取成功或失败的数据，(其实就是调用this.successCallBack，this.faileCallBack)。所以走起去上面↑，就是修改promise的状态 12345678910111213141516171819202122232425262728293031323334(()&#x3D;&gt;&#123; window.myPromise&#x3D;function(callBack)&#123; &#x2F;&#x2F;状态属性 this.status&#x3D;&#39;pending&#39; &#x2F;&#x2F;回调函数 callBack(resolve.bind(this),reject.bind(this)) &#x2F;&#x2F; 成功 function resolve(params)&#123; if(this.status&#x3D;&#x3D;&#x3D;&#39;pending&#39;)&#123; this.status&#x3D;&#39;success&#39; this.successCallBack(params) &#125; &#125; &#x2F;&#x2F; 失败 function reject(err)&#123; if(this.status&#x3D;&#x3D;&#x3D;&#39;pending&#39;)&#123; this.status&#x3D;&#39;faile&#39; this.successCallBack(err) &#125; &#125; &#125; &#x2F;&#x2F;原型上定义一个then的方法 myPromise.prototype.then&#x3D;function(success,faile)&#123; this.successCallBack&#x3D;success this.faileCallBack&#x3D;faile &#125;&#125;)()var obj &#x3D; new myPromise((resolve,reject)&#x3D;&gt;&#123; setTimeout(()&#x3D;&gt;&#123; resolve(&#39;你真好&#39;) &#125;,1000)&#125;).then((data)&#x3D;&gt;&#123; console.log(data)&#x2F;&#x2F;成功执行&#125;)","categories":[],"tags":[]},{"title":"Class的继承","slug":"Class2","date":"2018-05-16T06:53:04.000Z","updated":"2020-12-30T06:09:50.885Z","comments":true,"path":"2018/05/16/Class2/","link":"","permalink":"http://example.com/2018/05/16/Class2/","excerpt":"","text":"1.简介Class可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承,要清晰和方便很多。 123456class Point&#123;&#125;class Pointwo extends Point&#123; &#125; 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。 1234567891011class Pointwo extends Point&#123; constructor(x,y,color)&#123; super(x,y)&#x2F;&#x2F;调用父类的constructor(x,y) this.color &#x3D; color &#125; toString()&#123; return this.color + &#39;&#39; +super.toString()&#x2F;&#x2F;调用父类的toString() &#125;&#125;代码中，constructor方法和toString方法之中，都出现了super关键字，他在这里表示父类的构造函数，用来新建父类的this对象子类必须在constructor方法中调用super方法，否则新建实例时会报错，这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后对其进行加工，加上子类自己的实例属性和方法，如果不调用super方法，子类就得不到this对象 12345678910111213class Point &#123; &#x2F;* ... *&#x2F; &#125;class ColorPoint extends Point &#123; constructor() &#123; &#125;&#125;let cp &#x3D; new ColorPoint(); &#x2F;&#x2F; ReferenceError上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。 12345678910class ColorPoint extends Point &#123;&#125;&#x2F;&#x2F; 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125;另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。 12345678910111213141516171819202122class Point &#123; constructor(x, y) &#123; this.x &#x3D; x; this.y &#x3D; y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color &#x3D; color; &#x2F;&#x2F; ReferenceError super(x, y); this.color &#x3D; color; &#x2F;&#x2F; 正确 &#125;&#125;上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。下面是生成子类实例的代码。let cp &#x3D; new ColorPoint(25, 8, &#39;green&#39;);cp instanceof ColorPoint &#x2F;&#x2F; truecp instanceof Point &#x2F;&#x2F; true上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。 1最后，父类的静态方法，也会被子类继承。 class A { static hello() { console.log(‘hello world’); }} class B extends A {} B.hello() // hello world上面代码中，hello()是A类的静态方法，B继承A，也继承了A的静态方法。 122.Object.getPrototypeOf()Object.getPrototypeOf()方法可以用来从子类上获取父类 Object.getPrototypeOf(ColorPoint) === Point//true因此，可以使用这个方法判断，一个类是否继承了另一个类 1233.super关键字super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同第一种情况，super作为函数用时，代表父类的构造函数。ES6要求，子类的构造函数必须执行一次super函数。 class A {} class B extends A { constructor() { super(); }}上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。 注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。 12345678910111213141516&#96;&#96;&#96;class A &#123; constructor() &#123; console.log(new.target.name); &#125;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125;new A() &#x2F;&#x2F; Anew B() &#x2F;&#x2F; B上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。 12345678class A &#123;&#125;class B extends A &#123; m() &#123; super(); &#x2F;&#x2F; 报错 &#125;&#125;上面代码中，super()用在B类的m方法之中，就会造成语法错误。 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类 1234567891011121314class A&#123; p()&#123; return 2 &#125;&#125;class B extends A&#123; constructor()&#123; super() console.log(super.p())&#x2F;&#x2F;&#x2F;2 &#125;&#125;let b &#x3D; new B()代码中，子类B当中的super.p(),就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype,所以super.p()就相当于A.prototype.p()注意：由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。 123456789101112131415class A &#123; constructor() &#123; this.p &#x3D; 2; &#125;&#125;class B extends A &#123; get m() &#123; return super.p; &#125;&#125;let b &#x3D; new B();b.m &#x2F;&#x2F; undefined上面代码中，p是父类A实例的属性，super.p就引用不到它。 如果属性定义在父类的原型对象上，super就可以取到 1234567891011class A &#123;&#125;A.prototype.x &#x3D; 2;class B extends A &#123; constructor() &#123; super(); console.log(super.x) &#x2F;&#x2F; 2 &#125;&#125;let b &#x3D; new B();代码中,属性x是定义在A.prototype上面的，所以super.x可以取到它的值 ES6规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例 12345678910111213141516171819202122class A &#123; constructor() &#123; this.x &#x3D; 1; &#125; print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x &#x3D; 2; &#125; m() &#123; super.print(); &#125;&#125;let b &#x3D; new B();b.m() &#x2F;&#x2F; 2代码中，super.print()虽然调用的是A.prototype.print(),但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1.也就是说，实际上执行的是super.print.call(this) 由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性 123456789101112131415161718class A &#123; constructor() &#123; this.x &#x3D; 1; &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x &#x3D; 2; super.x &#x3D; 3; console.log(super.x); &#x2F;&#x2F; undefined console.log(this.x); &#x2F;&#x2F; 3 &#125;&#125;let b &#x3D; new B();代码中，super.x赋值为3，这时等同于对this.x赋值为3.而当读取super.x的时候，读的是A.prototype.x,所以返回undefined 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象 1234567891011121314151617181920class Parent&#123; static myMethod(msg)&#123; console.log(&#39;static&#39;,msg) &#125; myMethod(msg)&#123; console.log(&#39;instance&#39;,msg) &#125;&#125;class Child extends Parent&#123; static myMethod(msg)&#123; super.myMethod(msg) &#125; myMethod(msg)&#123; super.myMethod(msg) &#125;&#125;console.log(Child.myMethod(1))var child &#x3D; new Child()console.log(child.myMethod(2))上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。 另外，在子类的静态方法中通过super调用父类方法时，方法内部的this指向当前的子类，而不是子类的实例 12345678910111213141516171819202122class A &#123; constructor() &#123; this.x &#x3D; 1; &#125; static print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x &#x3D; 2; &#125; static m() &#123; super.print(); &#125;&#125;B.x &#x3D; 3;B.m() &#x2F;&#x2F; 3上面代码中，静态方法B.m里面，super.print指向父类的静态方法。这个方法里面的this指向的是B，而不是B的实例。 12345678910使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super); &#x2F;&#x2F; 报错 &#125;&#125;上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。 1234567891011class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.valueOf() instanceof B); &#x2F;&#x2F; true &#125;&#125;let b &#x3D; new B();上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super使得this指向B的实例，所以super.valueOf()返回的是一个B的实例。 12345678最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。var obj &#x3D; &#123; toString() &#123; return &quot;MyObject: &quot; + super.toString(); &#125;&#125;;obj.toString(); &#x2F;&#x2F; MyObject: [object Object] 4.类的 prototype 属性和__proto__属性大多数浏览器的ES5实现中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性,因此同时存在两条继承链(1) 子类的__proto__属性，表示构造函数的继承，总是指向父类。(2) 子类的prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性 123456789class A&#123;&#125;class B extends A&#123;&#125;B.__proto__ &#x3D;&#x3D;&#x3D; A &#x2F;&#x2F;trueB.prototype.__proto__ &#x3D;&#x3D;&#x3D; A.prototype &#x2F;&#x2F;true代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性 这样的结果是因为，类的继承是按照下面的模式实现的。 12345678910class A&#123;&#125;class B&#123;&#125;Object.setPrototypeOf(B.prototype,A.prototype)&#x2F;&#x2F;B的实例继承A的实例Object.setPrototypeOf(B,A)&#x2F;&#x2F;B继承A的静态属性const b &#x3D; new B()《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。 12345Object.setPrototypeOf &#x3D; function (obj, proto) &#123; obj.__proto__ &#x3D; proto; return obj;&#125;因此就得到了上面这个结果 12345678Object.setPrototypeOf(B.prototype, A.prototype);&#x2F;&#x2F; 等同于B.prototype.__proto__ &#x3D; A.prototype;Object.setPrototypeOf(B, A);&#x2F;&#x2F; 等同于B.__proto__ &#x3D; A;这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。 123B.prototype &#x3D; Object.create(A.prototype);&#x2F;&#x2F; 等同于B.prototype.__proto__ &#x3D; A.prototype; extends关键字后面可以跟多种类型的值 1234class B extends A&#123;&#125;上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。 下面，讨论两种情况。第一种，子类继承Object类。 123456class A extends Object &#123;&#125;A.__proto__ &#x3D;&#x3D;&#x3D; Object &#x2F;&#x2F; trueA.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; true这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。 第二种情况，不存在任何继承。 123456class A &#123;&#125;A.__proto__ &#x3D;&#x3D;&#x3D; Function.prototype &#x2F;&#x2F; trueA.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; true这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。 实例的 proto 属性子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。 123456var p1 &#x3D; new Point(2, 3);var p2 &#x3D; new ColorPoint(2, 3, &#39;red&#39;);p2.__proto__ &#x3D;&#x3D;&#x3D; p1.__proto__ &#x2F;&#x2F; falsep2.__proto__.__proto__ &#x3D;&#x3D;&#x3D; p1.__proto__ &#x2F;&#x2F; true上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。 因此，通过子类实例的proto.__proto__属性，可以修改父类实例的行为。 123456p2.__proto__.__proto__.printName &#x3D; function () &#123; console.log(&#39;Ha&#39;);&#125;;p1.printName() &#x2F;&#x2F; &quot;Ha&quot;上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。","categories":[],"tags":[]},{"title":"Class的基本语法","slug":"Class1","date":"2018-05-15T14:02:45.000Z","updated":"2020-12-29T06:52:30.506Z","comments":true,"path":"2018/05/15/Class1/","link":"","permalink":"http://example.com/2018/05/15/Class1/","excerpt":"","text":"class的基本语法:一.类的由来JS中生成实力对象的传统方法是通过构造函数，下面请看一个例子 123456789function Point(x,y)&#123; this.x&#x3D;x this.y&#x3D;y&#125;Point.prototype.toString&#x3D;function ()&#123; return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39;&#125;var p &#x3D; new Point(1,2)console.log(p) 上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。 ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。 1234567891011class Point&#123; constructor(x,y)&#123; this.x&#x3D;x this.y&#x3D;y &#125; toString()&#123; return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39; &#125;&#125;let p &#x3D;new Point(1,2)console.log(p) 这个是定义了一个类，有一个constructor()方法，就是构造方法而this关键字就是实力的对象。这种新的Class写法，最开始ES5的构造函数Point是一样的。 Point类除了构造方法，还定义了一个toString方法。注意，这里定义toString()方法，是不用加上function关键字的。直接定义就可以，并且不用逗号隔开，加了会报错。 ES6的类，完全可以看做构造函数的另一种写法。 1234567class Point&#123;&#125;console.log(typeof Point)&#x2F;&#x2F;function 说明类的数据类型是函数，类本身就指向构造函数console.log(Point&#x3D;&#x3D;&#x3D;Point.prototype.constructor)&#x2F;&#x2F;true使用的时候也是直接对类使用new 命令，跟构造函数的用法完全一致。 12345678class Bar&#123; todo()&#123; console.log(&#39;类&#39;) &#125;&#125;const b &#x3D; new Bar()b.todo()&#x2F;&#x2F;&#39;类&#39;构造函数的prototype属性，在ES6的 类上面继续存在。事实上，类的所有方法都定义在类的 prototype属性上面 1234567891011121314151617181920212223class Point &#123; constructor() &#123; &#x2F;&#x2F; ... &#125; toString() &#123; &#x2F;&#x2F; ... &#125; toValue() &#123; &#x2F;&#x2F; ... &#125; &#125; &#x2F;&#x2F; 等同于 Point.prototype &#x3D; &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;, &#125;; 上面代码中，所有的方法，其实都是定义在Point.prototype上面 因此，在类的实例上面调用方法，其实就是调用原型上的方法 1234class B&#123;&#125;const b &#x3D; new B()console.log(b.constructor &#x3D;&#x3D;&#x3D; B.prototype.constructor)&#x2F;&#x2F;trueb是B类的实例，b的constructor()方法就是B类原型的constructor()方法 1234567891011由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign()方法可以很方便地一次向类天机多个方法。比如：class Point&#123; constructor()&#123; &#125;&#125;Object.assign(Point.prototype,&#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;) 12prototype对象的constructor()属性，直接指向&#39;类&#39;的本身，这与ES5的行为是一致的。Point.prototype.constructor&#x3D;&#x3D;&#x3D;Point &#x2F;&#x2F;true 另外，类的内部所有定义的方法，都是不可枚举的(non-enumerabal) 1234567891011class Point&#123; constructor(x,y)&#123; &#125; toString()&#123; &#125;&#125;console.log(Object.keys(Point.prototype))&#x2F;&#x2F;[]console.log(Object.getOwnPropertyNames(Point.prototype))&#x2F;&#x2F;[&#39;constructor&#39;,&#39;toString&#39;]这里，toString()方法是Point类 内部定义的方法，它是不可枚举的。这一点与ES5是不一样的 123456789 var Point &#x3D; function (x,y)&#123;&#125;Point.prototype.toString &#x3D; function ()&#123;&#125;console.log(Object.keys(Point.prototype))&#x2F;&#x2F;[&#39;toString&#39;]console.log(Object.getOwnPropertyNames(Point.prototype))&#x2F;&#x2F;[&#39;constructor&#39;,&#39;toString&#39;]这是ES5 的写法，toString()方法就是可枚举的。 Constructor()方法 constructor()方法是类的默认方法，是通过new 命令生成对象实例时，自动调用该方法。一个类必须有constructor() 方法，如果没有显示定义，一个空德constructor()方法也会被默认添加 1234567891011class Ponit&#123; &#125; &#x2F;&#x2F;等同于 class Point&#123; constructor()&#123; &#125; &#125;这里，定义了一个空的类Point,JS引擎会自动给他添加一个空的constructor()方法。constructor()方法默认返回实例对象(即this),完全可以指定返回另一个对象 12345678class Foo&#123; constructor()&#123; return Object.create(null) &#125;&#125;console.log(new Foo() instanceof Foo)&#x2F;&#x2F;false这里，constructor()函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。类必须使用new调用，否则会报错，这是它跟普通构造函数的一个主要区别，后者不用new也可以执行 123456class Foo&#123; constructor()&#123; return Object.create(null) &#125;&#125;Foo()&#x2F;&#x2F;Class constructor Foo cannot be invoked without &#39;new&#39; 类的实例！ 生成类的实例的写法，与ES5 完全一样，也是使用 new命令。如果没有用 new，像函数那样调用class,将会报错 12345class Point&#123; &#125; var point &#x3D; Point(2,3)&#x2F;&#x2F;报错 var point &#x3D; new Point(2,3)&#x2F;&#x2F;正确 与ES5 一样，实例的属性除非显示定义在其本身(即定义在this上)，否则都是定义在原型上(即定义在class上) 1234567891011121314151617class Point&#123; constructor(x,y)&#123; this.x&#x3D;x this.y&#x3D;y &#125; toString()&#123; return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39; &#125;&#125;var point &#x3D; new Point(2,3)console.log(point.toString(2,3))&#x2F;&#x2F;(2,3)console.log(point.hasOwnProperty(&#39;x&#39;))&#x2F;&#x2F;trueconsole.log(point.hasOwnProperty(&#39;y&#39;))&#x2F;&#x2F;trueconsole.log(point.hasOwnProperty(&#39;toString&#39;))&#x2F;&#x2F;falseconsole.log(point.__proto__.hasOwnProperty(&#39;toString&#39;))&#x2F;&#x2F;true上面代码中，x和y都是实例对象point自身属性(因为定义在this变量上)，所以hasOwnProperty()方法返回true，而toString()是原型对象的属性(因为定义在Point类上)，所以hasOwnProperty()方法返回false,这些都与ES5的行为保持一致 与ES5一样，类的所有实例共享一个原型对象！！！！ 12345var p1 &#x3D; new Point(2,3)var p2 &#x3D; new Point(1,3)p1.__proto&#x3D;&#x3D;&#x3D;p2.__proto__&#x2F;&#x2F;true上面代码中。p1和p2都是Point的实例，他们的原型都是Point.prototype,所以__proto__属性是相等的。这也意味着，可以通过实例的__proto__属性为&#39;类&#39;添加方法 proto 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。 1234567891011var p1 &#x3D; new Point(2,3);var p2 &#x3D; new Point(3,2);p1.__proto__.printName &#x3D; function () &#123; return &#39;Oops&#39; &#125;;p1.printName() &#x2F;&#x2F; &quot;Oops&quot;p2.printName() &#x2F;&#x2F; &quot;Oops&quot;var p3 &#x3D; new Point(4,2);p3.printName() &#x2F;&#x2F; &quot;Oops&quot;上面代码在p1的原型上添加了一个printName()方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。 取值函(getter)和存值函数(setter)与ES5一样，在’类’的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为 123456789101112131415class MyClass&#123; constructor()&#123; &#125; get prop()&#123; return &#39;getter&#39; &#125; set prop(value)&#123; console.log(&#39;setter:&#39;+value) &#125;&#125;let inst &#x3D; new MyClass()console.log(inst.props&#x3D;123)&#x2F;&#x2F;&#39;setter:123&#39;console.log(inst.prop)&#x2F;&#x2F;&#39;getter&#39;上面，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了 存值函数和取值函数式设置在属性的 Desscriptor对象上的。 1234567891011121314151617class CustomHTMLElement &#123; constructor(element)&#123; this.element &#x3D; element &#125; get html()&#123; return thi.element.innerHTML &#125; set html(value)&#123; this.element.innerHTML&#x3D;value &#125;&#125;var descriptor &#x3D; Object.getOwnPropertyDescriptor( CustomHTMLElement.proptotype,&#39;html&#39;)&#39;get&#39; in descriptor&#x2F;&#x2F;true&#39;set&#39; in descriptor&#x2F;&#x2F;true上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。 属性表达式 12345678910let nethodName &#x3D; &#39;getArea&#39;class Square &#123; constructor(length)&#123; &#125; [methodName]()&#123; &#125;&#125;代码中，Square类的方法名getArea,是从表达式得到的。 Class 表达式与函数一样，类也可以使用表达式的形式定义 12345678910111213 const MyClass &#x3D; class Me&#123; getClassName()&#123; return Me.name &#125;&#125;这里使用表达式定义了一个类，类的名字是Me,但是Me只在Class的内部可用，指代当前类。在Class外部，这个类只能用myClass引用let inst &#x3D; new MyClass()console.log(inst.getClassName())&#x2F;&#x2F;MeMe.name&#x2F;&#x2F;Me is not defined这里就可以说明，Me只在Class内部有定义如果类的内部没有用到的话，可以省略Me,也就是可以下面的形式const MyClass &#x3D; class &#123;&#x2F;&#x2F;....&#125; 1234567891011采用Class 表达式，可以写出立即执行的Classlet person &#x3D; new class&#123; constructor(name)&#123; this.name &#x3D; name &#125; sayName()&#123; console.log(this.name) &#125;&#125;(&#39;李华&#39;)person.sayName()这里 person是一个立即执行的类的实例 注意点（1）严格模式 类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。（2）不存在提升累不存在变量提升，这一点与ES5完全不同 123new Foo()class Foo&#123;&#125;上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承者有关，必须保证子类在父类之后定义。 12345&#123; let Foo &#x3D; class&#123;&#125; class Bar extends Foo&#123;&#125;&#125;上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。 （3）name 属性由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。 123class Point&#123;&#125;Point.name&#x2F;&#x2F;&#39;Point&#39;name属性总是返回紧跟在class关键字后面的类。 （4）Generator 方法如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。 1234567891011121314class Foo&#123; constructor(...args)&#123; this.args &#x3D; args &#125; *[Symbol.iterator]()&#123; for(let arg of this.args)&#123; yield arg &#125; &#125;&#125;for(let x of new Foo(&#39;hello&#39;,&#39;world&#39;))&#123; console.log(x)&#125;上面的代码中，Foo类的Symbol.interator方法前有一个星号，表示该方法是一个Generator 函数。Symbol.interator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。 5）this 的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 1234567891011121314151617181920212223242526272829class Logger&#123; printName(name&#x3D;&#39;there&#39;)&#123; this.print(&#96;Hello $&#123;name&#125;&#96;) &#125; print(text)&#123; console.log(text) &#125;&#125;const logger &#x3D; new Logger()const &#123; printName&#125; &#x3D; loggerconsole.log(printName())&#x2F;&#x2F;Cannot read property &#39;print&#39; of undefined上面代码中，printName方法中的this，默认指向Logger类的实例，但是。如果将这个方法提取出来单独使用，this会指向该方法运行是所在的环境(由于class内部是严格模式，所以this实际指向的是undefined),从而导致找不到print方法而报错。一个比较简单的解决方法是，在构造函数中绑定this。这样就不会找不到print方法了。class Logger &#123; constructor() &#123; this.printName &#x3D; this.printName.bind(this); &#125; &#x2F;&#x2F; ...&#125;另一种解决方法是使用箭头函数。class Obj&#123; constructor()&#123; this.getThis &#x3D; () &#x3D;&gt; this &#125;&#125;const myObj &#x3D; new Obj()myObj.getThis() &#x3D;&#x3D;&#x3D; myObj&#x2F;&#x2F;true箭头函数内部的this总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，实在构造函数执行的时候，这时，箭头函数所在的运行环境，肯定是实例对象，所以this会总是指向实例对象 12345678910111213141516171819还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。function selfish (target) &#123; const cache &#x3D; new WeakMap(); const handler &#x3D; &#123; get (target, key) &#123; const value &#x3D; Reflect.get(target, key); if (typeof value !&#x3D;&#x3D; &#39;function&#39;) &#123; return value; &#125; if (!cache.has(value)) &#123; cache.set(value, value.bind(target)); &#125; return cache.get(value); &#125; &#125;; const proxy &#x3D; new Proxy(target, handler); return proxy;&#125;const logger &#x3D; selfish(new Logger()); 2.静态方法类相当于实例的原型。所有在类中定义的方法，都会被实例继承，如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为‘静态方法’ 12345678910class Foo&#123; static classMethod()&#123; return &#39;hello&#39; &#125;&#125;console.log(Foo.classMethod())&#x2F;&#x2F;&#39;hello&#39;var foo &#x3D; new Foo()console.log(foo.classMethod())&#x2F;&#x2F;foo.classMethod is not a function上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用(Foo.classMethod()),而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法 注意：如果静态方法包含this关键字，这个this指的是类，而不是实例 1234567891011121314class Foo&#123; static bar()&#123; this.baz() &#125; static baz()&#123; console.log(&#39;hello&#39;) &#125; baz()&#123; console.log(&#39;world&#39;) &#125;&#125; console.log(Foo.bar())&#x2F;&#x2F;hello上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo的类，而不是Foo的实例，等同于调用Foo.baz.另外，从这个例子还可以看出，静态方法可以与非静态方法重名 父类的静态方法，可以被子类继承 12345678class Foo&#123; static classMethod()&#123; return &#39;hello&#39; &#125;&#125;class Bar extends Foo&#123;&#125;console.log(Bar.classMethod())&#x2F;&#x2F;hello这里，父类Foo有一个静态方法，子类Bar可以调用这个方法 123456789101112静态方法也是可以从super对象上调用的class Foo&#123; static classMethod()&#123; return &#39;hello&#39; &#125;&#125;class Bar extends Foo&#123; static classMethod()&#123; return super.classMethod()+&#39;,too&#39; &#125;&#125;console.log(Bar.classMethod())&#x2F;&#x2F;hello,too 3.实例属性的新写法实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。 12345678910111213class IncreasingCounter&#123; constructor()&#123; this._count &#x3D; 0 &#125; get value()&#123; console.log(&#39;Getting the current value&#39;) return this._count &#125; increment()&#123; this._count++ &#125;&#125;代码中，实例属性this._count定义在constructor()方法里面，另一种写法是，这个属性也可以定义在类的最顶层，其他都不变 123456789101112class IncreasingCounter&#123; _count &#x3D; 0 get value()&#123; console.log(&#39;Getter the current value&#39;) return this._count &#125; increment()&#123; this._count++ &#125;&#125;代码中，实例属性_count与取值函数value()和increment()方法，处于同一层级。这时，不需要在实例属性前面加上this。这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性 12345678class foo&#123; bar &#x3D; &#39;hello&#39; baz &#x3D; &#39;world&#39; constructor()&#123; &#125;&#125;代码中，一眼就能看出，foo类有两个实例属性，一目了然。另外，写起来也比较简洁 4.静态属性静态属性指的是Class 本身的属性，即Class.porpName,而不是定义在实例对象(this)上的属性 123456class Foo&#123;&#125;Foo.prop &#x3D; 1Foo.prop &#x2F;&#x2F;1上面的写法为Foo类定义了一个静态属性prop 目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性。写法是在实例属性的前面，加上static关键字。 12345678class MyClass&#123; static myStaticProp &#x3D; 42 constructor()&#123; console.log(MyClass.myStaticProp) &#125;&#125;new MyClass()这个新写法大大方便了静态属性的表达 12345678class Foo&#123;&#x2F;&#x2F;老写法&#125;Foo.prop &#x3D;1class Foo&#123;&#x2F;&#x2F;新写法 static prop &#x3D;1&#125;上面代码中，老写法的静态属性定义在类的外部，整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative）,而不是赋值处理，语义更好。 5.私有方法和私有属性现在的解决方案私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问，这是常见需求，有利于代码的封装，但ES6不提供，只能通过变通方法模拟实现。一种做法是在命名上加以区别。 1234567891011class Widget&#123; &#x2F;&#x2F;公有方法 foo(baz)&#123; this._bar(baz) &#125; &#x2F;&#x2F;私有属性 _bar(baz)&#123; return this.snaf &#x3D; baz &#125;&#125;上面代码中，_bar()方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是这种命名是不保险的。在类的外部，还是可以调用到这个方法 另一种方法就是索性将私有方法移出类，因为类内部的所有方法都是对外可见的。 123456789101112class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; &#x2F;&#x2F; ...&#125;function bar(baz) &#123; return this.snaf &#x3D; baz;&#125;上面代码中，foo是公开方法，内部调用了bar.call(this, baz)。这使得bar()实际上成为了当前类的私有方法。","categories":[],"tags":[]},{"title":"变量提升","slug":"变量提升","date":"2018-05-08T06:01:41.000Z","updated":"2020-12-30T06:09:49.333Z","comments":true,"path":"2018/05/08/变量提升/","link":"","permalink":"http://example.com/2018/05/08/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/","excerpt":"","text":"var的变量提升es3/es51.变量提升：当栈内存（作用域）形成，JS代码自上而下执行之前，浏览器首先会把所有带var和function关键字的进行提前的声明或定义.这种预先处理机制称之为变量提升。3.声明（declare）：var a或function sum4.定义（defined）:a=12 也就是赋值5.变量提升阶段：6.带var的只声明未定义 12345678910111213console.log(a)&#x2F;&#x2F;undefined var a &#x3D; 12; function b(arr)&#123;&#x2F;&#x2F;变量提升阶段function就完成了声明和赋值，浏览器会在全局作用域声明一个b，然后再形成一个堆内存里面 &#x2F;&#x2F;是函数体里面的代码字符串。这个堆内存会有一个16进制的地址，而全局里面声明的那个b就会指向这个地址 &#x2F;&#x2F;因为函数在变量提升阶段就完成了声明和赋值，所以在代码执行阶段在遇到b这个函数就不会在重复声明赋值，就会直接跳过 for(let i&#x3D;0;i&lt;arr.length;i++)&#123; console.log(i) &#125; &#125; &#x2F;&#x2F;跳过后就会执行下面这个函数调用，传了一个数组进去。 &#x2F;&#x2F;而执行一个函数也就是形成了一个私有栈内存。当私有的作用域形成后也不是立即代码执行，而是先进行变量提升（变量提升前，先形参赋值） b([1,2,3,4]) &#x2F;&#x2F;在ES3和ES5语法规范中,只有全局作用域和函数执行的私有作用域（栈内存），其他大括号不会形成栈内存 带var与不带var在全局作用域下声明一个变量，也相当于给window全局对象设置了一个属性，变量的值就是属性值（私有作用域下声明的私有变量和window没有关系）带function的声明和赋值都完成了变量提升至发生在当前作用域（例如：开始加载页面的时候只对全局作用域下的进行提升，因为此时函数中存储的都是字符串）在全局作用域先声明的函数或者变量是‘全局变量’，同理，在私有作用域下声明的变量是‘私有变量’[带var和function才是声明 123456789101112console.log(i)&#x2F;&#x2F;undefined console.log(window.i)&#x2F;&#x2F;undefined console.log(&#39;i&#39; in window)&#x2F;&#x2F;true 在变量提升阶段，在全局作用域中声明了一个变量i，此时就已经把i当做属性值赋值 &#x2F;&#x2F;给了window了，只不过此时还没有给i赋值，默认是undefined &#x2F;&#x2F; in? ：检测某个属性是否隶属于这个对象 var i &#x3D; 9&#x2F;&#x2F;变量值修改window的值也跟着修改 console.log(i)&#x2F;&#x2F;9 console.log(window.i)&#x2F;&#x2F;9 window的一个属性名为i i&#x3D;13 console.log(window.i)&#x2F;&#x2F;13 window.i&#x3D;14 console.log(i)&#x2F;&#x2F;14 重点：全局变量和window的属性存在‘映射机制’，就是有一个改变另一个也跟着改变 不带var 不带var的本质是window的属性1234567891011121314151617181920212223&#x2F;&#x2F;console.log(j)&#x2F;&#x2F;j is not defined 这里的J是按照变量的来识别的 &#x2F;&#x2F;console.log(window.j)&#x2F;&#x2F;undefined 这里是按照window的属性来识别的，因为对象没有某一个属性返回的就是undefined &#x2F;&#x2F;console.log(window.j)&#x2F;&#x2F;false 不存在这个属性 j&#x3D;10&#x2F;&#x2F; 这里不带var 就相当于给window加了一个属性叫j,值是10 console.log(j)&#x2F;&#x2F;10 console.log(window.a)&#x2F;&#x2F;12 &#x2F;&#x2F; var q &#x3D;10, &#x2F;&#x2F; s &#x3D;11 &#x2F;&#x2F;这样写s是带var &#x2F;&#x2F; var q &#x3D; s &#x3D;11 &#x2F;&#x2F; 这样写不带var &#x2F;&#x2F;在私有作用域中带var和不带var也有区别：带var在私有作用域变量提升阶段都声明为私有变量和外界没有任何关系 &#x2F;&#x2F;不带var 不是私有变量，它会想它的上级作用域查找，看它是否是上级的变量，不是继续向上查找，一直找到window为止 &#x2F;&#x2F;这种查找机制叫‘作用域链’ &#x2F;&#x2F;console.log(n,m)&#x2F;&#x2F;undefined undefined var n &#x3D;13; m &#x3D;13; function fn()&#123; console.log(n,m)&#x2F;&#x2F;变量提升阶段先var了一个n所以是 undefined 但是m不带var，向上级查找所以m是13 ； var n &#x3D; m &#x3D; 14&#x2F;&#x2F;此时都是14 console.log(n,m)&#x2F;&#x2F;14 14 &#125; fn() console.log(a,m)&#x2F;&#x2F; 这里的a是全局的所以是13，b在函数里被重新赋值所以是14 在私有作用域中如果向上级查找变量到window的时候发现window也没有这个属性时又是怎么做的呢？12345678unction f()&#123; b &#x3D; 13 console.log(&#39;b&#39; in window)&#x2F;&#x2F;true 在作用域查找的过程中，如果找到window也没有这个变量，相当于给window设置了 &#x2F;&#x2F;了一个属性b console.log(b)&#x2F;&#x2F;13 &#125; f() console.log(b)&#x2F;&#x2F;13 只对等于号左边进行变量提升1234567891011fnn()&#x2F;&#x2F; fnn is not a function sun()&#x2F;&#x2F;2 var fnn &#x3D; function ()&#123;&#x2F;&#x2F;函数表达式声明 因为是用var关键字声明在变量提升阶段只提升了等号左边的fnn, &#x2F;&#x2F;但是并没有定义或赋值，所以在上面调用时报错 console.log(1) &#125; fnn() function sun ()&#123;&#x2F;&#x2F;普通方式声明的函数在 变量提升阶段就已经声明和定义完毕 所以上面可以直接执行 console.log(2) &#125; sun() 条件判断下变量提升1234567891011121314151617console.log(z) if(1&#x3D;&#x3D;&#x3D;2)&#123;&#x2F;&#x2F;在当前作用域下，不管条件是否成功都要进行变量提升， &#x2F;&#x2F;带var的还是只是声明 &#x2F;&#x2F;带function的在老版本浏览器渲染机制下，声明+定义都处理，但是为了迎合es6中的块级作用域，新版浏览器对于函数 &#x2F;&#x2F;（在条件判断中的函数），不管条件是否成立，都是先声明，没有赋值。 var z &#x3D; 10 &#125; console.log(z) if(1&#x3D;&#x3D;&#x3D;1)&#123; console.log(fs)&#x2F;&#x2F;函数本身：当条件成立，进入到判断体中（ES6中它是以个块级作用域）第一件事并不是变量提升， &#x2F;&#x2F;先把fs声明并定义，也就是判断体中代买执行前，fs就已经赋值了 function fs()&#123; console.log(&#39;ok&#39;) &#125; &#125; console.log(fs)&#x2F;&#x2F;函数本身 ES6中let创建的变量不存在变量提升。不允许重复定义 暂时性死区 ,切断了全局变量和window属性的映射机制1234console.log(a)&#x2F;&#x2F;a is not defined let a &#x3D;12 console.log(window.a)&#x2F;&#x2F;undefined console&#x2F;log(a)&#x2F;&#x2F;12","categories":[],"tags":[]},{"title":"去重排序","slug":"数组去重排序","date":"2018-03-10T10:38:33.000Z","updated":"2021-01-12T11:30:03.626Z","comments":true,"path":"2018/03/10/数组去重排序/","link":"","permalink":"http://example.com/2018/03/10/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%8E%92%E5%BA%8F/","excerpt":"","text":"排序123456789101112冒泡排序let arr &#x3D; [23,46,2,5,767,7,4,3] for (let i&#x3D;0;i&lt;arr.length-1;i++)&#123; for(let j&#x3D;0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; let temp&#x3D;arr[j+1] arr[j+1]&#x3D;arr[j] arr[j]&#x3D;temp &#125; &#125; &#125; console.log(arr)&#x2F;&#x2F;[2, 3, 4, 5, 7, 23, 46, 767] 12345678910插入排序let arr &#x3D; [23,46,2,5,767,7,4,3] for(let i&#x3D;0;i&lt;arr.length;i++)&#123; for(let j&#x3D;i;j&gt;0&amp;&amp;arr[j]&lt;arr[j-1];j--)&#123; let temp &#x3D; arr[j] arr[j]&#x3D;arr[j-1] arr[j-1]&#x3D;temp &#125; &#125; console.log(arr)&#x2F;&#x2F;[2, 3, 4, 5, 7, 23, 46, 767]","categories":[],"tags":[]},{"title":"函数的length","slug":"函数的length","date":"2018-03-05T12:36:48.000Z","updated":"2021-01-05T11:29:09.507Z","comments":true,"path":"2018/03/05/函数的length/","link":"","permalink":"http://example.com/2018/03/05/%E5%87%BD%E6%95%B0%E7%9A%84length/","excerpt":"","text":"ES6中的函数length属性ES6中函数的length属性，将返回没有指定默认值的参数个数。也就是说指定了默认值后，length属性将失真。 1234在es6之前函数的length就是指函数声明形参的个数function fn1()&#123;&#125; &#x2F;&#x2F;length为0function fn2(a,b)&#123;&#125; &#x2F;&#x2F;length为1function fn3(a,b,c) &#x2F;&#x2F;length为3 但是在ES6之后，就发生了变化，因为ES6更新了一个新特性，让函数可以给形参设置默认值 12function fn1(a,b&#x3D;10)&#123;&#125;&#x2F;&#x2F;这种写法在ES6之前是不允许的 有了这一新特性之后，length的解释就要修改成这样：length的值是指函数的第一个具有默认值得形参之前的形参的个数！！！写点代码更好理解 123456function fn1(a,b)&#123;&#125; &#x2F;&#x2F;因为a,b 没有默认值，length的值为2！function fn2(a&#x3D;1,b)&#123;&#125; &#x2F;&#x2F;因为a 为‘第一个具有默认值得形参’，而a的前面没有其他形参了，所以length为1function fn3(a,b&#x3D;1,c)&#123;&#125; &#x2F;&#x2F;b为‘第一个具有默认值的形参’，前面还有一个a，length为1 。function fn4(a,b,c&#x3D;1)&#123;&#125; &#x2F;&#x2F;所以length为2 因为‘c为第一个具有默认值的形参’function fn5(a,b&#x3D;1,c,d&#x3D;2)&#123;&#125; &#x2F;&#x2F;length为1。因为‘b为第一个具有默认值的形参’，它前面只有一个a,并且只算&#x2F;&#x2F;具有默认值形参前面的形参的个数，后面的不算所以是1个。 123注意，当函数拥有剩余参数时，比如function fn1(a,...args)&#123;&#125; &#x2F;&#x2F;length为1，剩余参数也有默认值，默认为空数组。前面有只有一个a，所以length为1function fn1(...args)&#123;&#125; &#x2F;&#x2F;如果函数形参只有一个默认参数，那么length为0！","categories":[],"tags":[]},{"title":"嘛是跨域？","slug":"跨域","date":"2018-03-02T12:00:36.000Z","updated":"2020-12-30T12:47:21.577Z","comments":true,"path":"2018/03/02/跨域/","link":"","permalink":"http://example.com/2018/03/02/%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"资源所在的服务器地址和资源内发起请求的目标服务器地址不同！（两个服务器是不同的） 这里就要说一下浏览器的同源策略问题（服务器之间是没有同源策略的），如果两个URL的协议/主机(域名，IP地址)/端口（默认是80），都相同的话就是同源。如有一个不一样就会发生跨域问题，就是非同源。注意：同源策略是指针对AJXS请求而言，如果不是Ajxs即便非同源也是能请求的。如果用ajxs发起的请求地址和后端地址不同就会跨域","categories":[],"tags":[]},{"title":"vue、react面试题","slug":"vue、react","date":"2018-02-22T07:17:05.000Z","updated":"2021-02-23T01:19:21.930Z","comments":true,"path":"2018/02/22/vue、react/","link":"","permalink":"http://example.com/2018/02/22/vue%E3%80%81react/","excerpt":"","text":"vue一.vue的特点是什么？1.遵循MVVM模式数据驱动视图2.双向绑定3.摒弃了原始的dom操作3.可以轻松引入Vue插件或其他第三方库开发项目 二.vue的原理是什么？vue2.0采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter,getter,在数据变动时发布消息给订阅者,触发响应的监听回调 三.computed 和 watch 有什么区别及运用场景?computed 计算属性 : 依赖其它属性值,并且 computed 的值有缓存,只有它依赖的属性值发生改变,下一次获取 computed 的值时才会重新计算 computed 的值。 watch 侦听器 : 更多的是「观察」的作用,无缓存性,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作。 运用场景： 当我们需要进行数值计算,并且依赖于其它数据时,应该使用 computed,因为可以利用 computed 的缓存特性,避免每次获取值时,都要重新计算。 当我们需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),限制我们执行该操作的频率,并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。 四.Vue 中的 key 到底有什么用？key 的特殊属性主要用在 Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。 五.什么是MVVM？MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。 六.mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。 区别：vue数据驱动，通过数据来显示视图层而不是节点操作。场景：数据操作比较多的场景，更加便捷 七.vuex是什么？怎么使用？哪种功能场景使用它？vuex是管理vue状态的一个库任何组件都可以和store通信它是单一数据源 八.vuex有哪几种属性？有五种，分别是 State、 Getter、Mutation 、Action、 Module · vuex的State特性A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的dataB、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中 · vuex的Getter特性A、getters 可以对State进行计算操作，它就是Store的计算属性B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用C、 如果一个状态只在一个组件内使用，是可以不用getters · vuex的Mutation特性Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。 九. v-show和v-if指令的共同点和不同点v-show指令是通过修改元素的display的CSS属性让其显示或者隐藏v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果 十.vue-router有哪几种导航钩子？三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件 十一.什么是vue生命周期Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。 十二.vue生命周期的作用是什么它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 十三.第一次页面加载会触发哪几个钩子第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子 十四.简单描述每个周期具体适合哪些场景生命周期钩子的一些使用方法：beforecreate : 可以在这加个loading事件，在加载实例时触发created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用mounted : 挂载元素，获取到DOM节点updated : 如果对数据统一处理，在这里写上相应函数beforeDestroy : 可以做一个确认停止事件的确认框nextTick : 更新数据后立即操作dom 十五.为什么使用key？当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。 十六.为什么避免 v-if 和 v-for 用在一起当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。 十七.VNode是什么？虚拟 DOM是什么？Vue在 页面上渲染的节点，及其子节点称为“虚拟节点 (Virtual Node)”，简写为“VNode”。“虚拟 DOM”是由 Vue 组件树建立起来的整个 VNode 树的称呼。 十八.active-class是哪个组件的属性？嵌套路由怎么定义？vue-router模块的router-link组件。嵌套路由顾名思义就是路由的多层嵌套。 一级路由里面使用children数组配置子路由，就是嵌套路由。 十九.怎么定义vue-router的动态路由？怎么获取传过来的动态参数？在router目录下的index.js文件中，对path属性加上/:id。 使用router对象的params.id 二十.请说出vue.cli项目中src目录每个文件夹和文件的用法？assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件 二十一.指令v-el的作用是什么?提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例 二十二.请列举出3个Vue中常用的生命周期钩子函数?created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见 mounted: el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 activated::keep-alive组件激活时调用 二十三.怎样理解单向数据流这个概念出现在组件通信。父组件是通过 prop 把数据传递到子组件的，但是这个 prop 只能由父组件修改，子组件不能修改，否则会报错。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。 二十四.各个生命周期的作用beforeCreate 组件实例被创建之初，组件的属性生效之前created 组件实例已经完全出创建，属性也绑定，但是真实 DOM 没有生成，$el 还不可以用beforeMount 在挂载开始之前被调用，相关的render函数首次被调用mounted el 被新创建的 vm.$el 替换，并挂载实例上去调动该钩子beforeUpdate 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前update 组件数据更新之后activated keep-alive 专属，组件被激活时调用deactivated keep-alive 专属，组件被销毁时调用beforeDestory 组件销毁前调用destroyed 组件销毁后调用#Vue 的父组件和子 二十五.在哪个生命周期内调用异步请求？在 钩子函数 created 、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务器点的数据返回进行赋值 二十六.在什么阶段才能访问操作 DOM在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以可以在 mounted 中访问到 DOM 二十七.Proxy 与 Object.defineProperty 优劣对比Proxy 可以直接监听对象而非属性；Proxy 可以直接监听数组的变化；Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利 二十八.使你用过 Vuex 吗？主要包含一下几种模块：#State定义了应用状态的数据结构，可以在这里设置默认的初始化状态。#Getter允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性中。#Mutation是唯一更改 store 中状态的方法，且必须是同步函数。#Action用于提交 mutation，而不是直接变更状态，可以任何异步操作。#Module允许将单一的 Store 拆分为多个 store 且同时保持在单一的状态数中 二十九.使用过 Vue SSR 吗？ 说说 SSRSSR 将 Vue 在客户端将标签渲染成HTML 片段的工作放到了服务端完成，服务端形成的 HTML 片段直接返回给客户端这个过程，叫做服务端渲染 三十.计算属性和methods的区别？为什么要用计算属性而不用methods？它两的执行结果是一样的。计算属性 是只有它的依赖发生变化的时候它会自动的进行计算求值，如果依赖没有发生变化，那么每次访问的时候计算属性都会立刻返回之前的执行结果，而事件函数需要手动调用，并且调用一次触发一次比较粗暴一点，每当重新触发渲染时，调用方法总是再次执行函数。 三十一.vue-router 的原理是什么？vue-router是什么：他可以让单页面应用拥有了多页面应用的效果，一个url对应一个页面。它主要是通过h5新增的history和hash两种模式来实现的hash —— 即地址栏 URL 中的 # 符号。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。每次hash值得变化，会触发hashchange这个时间，通过这个时间我就可以知道hash值发生了哪些变化。然后我们就可以监听hashchange来实现更新页面部分内容的操作。history —— 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。因此可以说，hash 模式和 history 模式都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由. 三十二.插槽的作用：为了让组件更加具有扩展性。抽取共性，保留不同为插槽，让其他组件可以传递自己想展示的标签到预留插槽。它包含具名插槽，匿名插槽、还有作用域插槽。 三十三.keep-alive的作用？缓存组件的状态，在组件还原的时候能够把状态还原到组件上。然后它有3个属性，分别是：include(包括)、exclude(不包括)、max(可缓存的最大组件实例数量)利用keep-alive组件把想要缓存的组件包一下，并且给被缓存的组件添加name属性，在include属性里面写上我们要缓存的组件name 三十四.vuex与全局对象的区别？Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会得到高效更新。不能直接改变store中的状态，改变store中的状态的唯一途径就是显示地提交(commit)mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 三十五.为什么组件里的data是个函数？一个组件被复用多次的话，也就会创建多个实例。本质上， 这些实例都是同一个构造函数如果data是对象的话，对象属于引用类型，会影响到所有的实例所以为了保证组件不同的实例之间data不冲突，data必须是个函数 三十六.vue2.x和vue3.x渲染器的diff算法有什么区别？Vue3.x借鉴了 ivi算法和 inferno算法Vue2的核?Diff算法采?了双端?较的算法，同时从新旧children的两端开始进??较，借助key值找到可复?的节点，再进?相关操作在创建VNode时就确定其类型，以及在mount/patch的过程中采?位运算来判断?个VNode的类型，在这个基础之上再配合核?的Diff算法，使得性能上较Vue2.x有了提升 三十七.那你知道Vue3.x响应式数据原理吗？Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？答：判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？？答：我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。 三十八.nextTick知道吗，实现原理是什么？在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用PromiseMutationObserversetImmediate如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。 三十九.说一下Vue的生命周期beforeCreate是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。created在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。beforeMount发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。mounted在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。beforeUpdate发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。updated发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。beforeDestroy发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。destroyed发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。 四十.说一下v-model的原理?v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。 四十一.Vue事件绑定原理说一下?原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。 四十一.Vue中组件生命周期调用顺序说一下?组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。组件的销毁操作是先父后子，销毁完成的顺序是先子后父。加载渲染过程父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount- &gt;子mounted-&gt;父mounted子组件更新过程父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated父组件更新过程父 beforeUpdate -&gt; 父 updated销毁过程父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed 四十二.Vue2.x组件通信有哪些方式？父子组件通信父-&gt;子props，子-&gt;父 $on、$emit获取父子组件实例 $parent、$childrenRef 获取实例的方式调用组件的属性或者方法Provide、inject 官方不推荐使用，但是写组件库时很常用兄弟组件通信Event Bus 实现跨组件通信 Vue.prototype.$bus = new VueVuex跨级组件通信Vuex$attrs、$listenersProvide、inject 四十三.你都做过哪些Vue的性能优化？编码阶段 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcherv-if和v-for不能连用如果需要使用v-for给每项元素绑定事件时使用事件代理SPA 页面采用keep-alive缓存组件在更多的情况下，使用v-if替代v-showkey保证唯一使用路由懒加载、异步组件防抖、节流第三方模块按需导入长列表滚动到可视区域动态加载图片懒加载SEO优化 预渲染服务端渲染SSR打包优化 压缩代码Tree Shaking/Scope Hoisting使用cdn加载第三方模块多线程打包happypacksplitChunks抽离公共文件sourceMap优化用户体验 骨架屏 PWA 四十四.vue中的修饰符?.stop 阻止事件冒泡.prevent 清除默认行为.once 只触发一次回调.lazy 取代input 监听change 事件.number 输入字符串转为有效的数字.trim 输入首尾空格过滤 四十五.vue中的指令有哪些？v-if、v-else、v-for、v-bind、v-model、v-onv-text 四十六.插槽之间是怎么传值的？可以用作用域插槽进行传值。子组件的slot标签中动态绑定属性，父组件中给template标签绑定(v-slot)值，子组件抛出来的接口，可以通过这个值访问到子组件的数据 四十七.vue中的内置组件有哪些？component、transition、transition-group、keep-alive、slot 四十八.vue中的transfrom组件是什么？使用transfrom可以完成任何元素进入/离开的过渡效果。它的用法是：首先在这个组件内设置一个那么属性，然后再css中用v-enter、v-enter-active、v-leave、v-leave-active来实现整体的效果。 四十九.computed 是什么？实现原理？是：计算属性。基于当前的数据进行简单的加工返回新的数据，当计算属性所依赖的数据发生变化时，它会自动进行计算。写起来像函数，本质是属性。 对大量计算有优化效果。仅仅在依赖的数据发生变化时，才执行。computed 内部实现了一个惰性的 watcher，在实例化的时候不会去求值，其内部通过 dirty 属性标记计算属性是否需要重新求值。当 computed 依赖的任意状态发生改变，都会通知这个惰性的 watcher，让它把 dirty 属性设置为 true，所以，当再次读取这个计算属性的时候，就会重新去求值。惰性的watcher 计算属性在创建时不会去求值的，是在使用时去求值。 computed 本质是一个惰性求值的观察者。 computed 内部实现了一个惰性的 watcher,也就是 computed watcher,computed watcher 不会立刻求值,同时持有一个 dep 实例。 其内部通过 this.dirty 属性标记计算属性是否需要重新求值。 当 computed 的依赖状态发生改变时,就会通知这个惰性的 watcher, computed watcher 通过 this.dep.subs.length 判断有没有订阅者, 有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 (Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染，本质上是一种优化。)没有的话,仅仅把 this.dirty = true。 (当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性。) 五十.为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？Object.defineProperty 本身有一定的监控到数组下标变化的能力,但是在 Vue 中,从性能/体验的性价比考虑,尤大大就弃用了这个特性(Vue 为什么不能检测数组变动 )。为了解决这个问题,经过 vue 内部处理后可以使用以下几种方法来监听数组 react面试题什么是react？它是facebook在2011年发布的一个框架react和vue大体是差不多一个开发框架，支出组件并且可以引入第三方UI库相对vue来说它比较更原生一点，vue相对来说更容易上手。 react有什么特点？它使用虚拟dom而不是真正的dom它可以用服务器端渲染它遵循单向数据流或者数据绑定 vue和react的区别？react严格上针对的是mvc模式的view层，vue则是mvvm模式。操作dom的方式不同，vue使用的是指令操作dom，react是通过js进行操作。数据绑定不同，vue实现的是双向绑定，react的数据流动是单向的。react中state是不能直接改变的，需要使用setState改变。vue中的state不是必须的，数据主要是由data属性在vue对象中管理的。 列出React的一些主要优点？它提高了应用的性能可以方便地在客户端和服务器端使用由于 JSX，代码的可读性很好React 很容易与 Meteor，Angular 等其他框架集成使用React，编写UI测试用例变得非常容易 React有哪些限制？React 只是一个库，而不是一个完整的框架它的库非常庞大，需要时间来理解新手程序员可能很难理解编码变得复杂，因为它使用内联模板和 JSX 什么是虚拟DOM？虚拟 DOM (VDOM)是真实 DOM 在内存中的表示。UI 的表示形式保存在内存中，并与实际的 DOM 同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。 什么是JSX？JSX 是J avaScript XML 的简写。是 React 使用的一种文件，它利用 JavaScript 的表现力和类似 HTML 的模板语法。这使得 HTML 文件非常容易理解。此文件能使应用非常可靠，并能够提高其性能。下面是JSX的一个例子： 为什么不直接更新 state 呢 ?如果试图直接更新 state ，则不会重新渲染组件要使用setState()方法来更新 state。它调度对组件state对象的更新。当state改变时，组件通过重新渲染来响应： 使用 React Hooks 好处是啥？首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 props 的负担。Hooks 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。 Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。 什么是 React Hooks？Hooks是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用state和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。 什么是 React Context?Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。 什么是纯函数？纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。 你了解 Virtual DOM 吗？解释一下它的工作原理？Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。Virtual DOM 工作过程有三个简单的步骤：每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。然后计算之前 DOM 表示与新表示的之间的差异。完成计算后，将只用实际更改的内容更新 real DOM 为什么浏览器无法读取JSX？浏览器只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX。所以为了使浏览器能够读取 JSX，首先，需要用像 Babel 这样的 JSX 转换器将 JSX 文件转换为 JavaScript 对象，然后再将其传给浏览器。 与 ES5 相比，React 的 ES6 语法有何不同？你理解“在React中，一切都是组件”这句话？组件是 React 应用 UI 的构建块。这些组件将整个 UI 分成小的独立并可重用的部分。每个组件彼此独立，而不会影响 UI 的其余部分。 解释 React 中 render() 的目的？每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，例如 、、 等。此函数必须保持纯净，即必须每次调用时都返回相同的结果。 什么是 Props?Props 是 React 中属性的简写。它们是只读组件，必须保持纯，即不可变。它们总是在整个应用中从父组件传递到子组件。子组件永远不能将 prop 送回父组件。这有助于维护单向数据流，通常用于呈现动态生成的数据。 React中的状态是什么？它是如何使用的？状态是 React 组件的核心，是数据的来源，必须尽可能简单。基本上状态是确定组件呈现和行为的对象。与props 不同，它们是可变的，并创建动态和交互式组件。可以通过 this.state() 访问它们 如何更新组件的状态？可以用 this.setState()更新组件的状态。 详细解释 React 组件的生命周期方法。componentWillMount**()** – 在渲染之前执行，在客户端和服务器端都会执行。componentDidMount**()** – 仅在第一次渲染后在客户端执行。componentWillReceiveProps**()** – 当从父类接收到 props 并且在调用另一个渲染器之前调用。shouldComponentUpdate**()** – 根据特定条件返回 true 或 false。如果你希望更新组件，请返回true 否则返回 false。默认情况下，它返回 false。componentWillUpdate**()** – 在 DOM 中进行渲染之前调用。componentDidUpdate**()** – 在渲染发生后立即调用。componentWillUnmount**()** – 从 DOM 卸载组件后调用。用于清理内存空间。 React中的合成事件是什么？合成事件是围绕浏览器原生事件充当跨浏览器包装器的对象。它们将不同浏览器的行为合并为一个 API。这样做是为了确保事件在不同浏览器中显示一致的属性。 你对 React 的 refs 有什么了解？Refs 是 React 中引用的简写。它是一个有助于存储对特定的 React 元素或组件的引用的属性，它将由组件渲染配置函数返回。用于对 render() 返回的特定元素或组件的引用。当需要进行 DOM 测量或向组件添加方法时，它们会派上用场。 什么是高阶组件（HOC）？高阶组件是重用组件逻辑的高级方法，是一种源于 React 的组件模式。 HOC 是自定义组件，在它之内包含另一个组件。它们可以接受子组件提供的任何动态，但不会修改或复制其输入组件中的任何行为。你可以认为 HOC 是“纯（Pure）”组件。 你能用HOC做什么？代码重用，逻辑和引导抽象渲染劫持状态抽象和控制Props 控制 什么是纯组件？纯（Pure） 组件是可以编写的最简单、最快的组件。它们可以替换任何只有 render() 的组件。这些组件增强了代码的简单性和应用的性能。 React 中 key 的重要性是什么？key 用于识别唯一的 Virtual DOM 元素及其驱动 UI 的相应数据。它们通过回收 DOM 中当前所有的元素来帮助 React 优化渲染。这些 key 必须是唯一的数字或字符串，React 只是重新排序元素而不是重新渲染它们。这可以提高应用程序的性能。 MVC框架的主要问题是什么？对 DOM 操作的代价非常高程序运行缓慢且效率低下内存浪费严重由于循环依赖性，组件模型需要围绕 models 和 views 进行创建 解释一下 Flux？Flux 是一种强制单向数据流的架构模式。它控制派生数据，并使用具有所有数据权限的中心 store 实现多个组件之间的通信。整个应用中的数据更新必须只能在此处进行。 Flux 为应用提供稳定性并减少运行时的错误。 什么是Redux？Redux 是当今最热门的前端开发库之一。它是 JavaScript 程序的可预测状态容器，用于整个应用的状态管理。使用 Redux 开发的应用易于测试，可以在不同环境中运行，并显示一致的行为。 Redux遵循的三个原则是什么？单一数据源使用纯函数进行修改状态是只读的 你对“单一事实来源”有什么理解？Redux 使用 “Store” 将程序的整个状态存储在同一个地方。因此所有组件的状态都存储在 Store 中，并且它们从 Store 本身接收更新。单一状态树可以更容易地跟踪随时间的变化，并调试或检查程序。 列出 Redux 的组件。Action – 这是一个用来描述发生了什么事情的对象。Reducer – 这是一个确定状态将如何变化的地方。Store – 整个程序的状态/对象树保存在Store中。View – 只显示 Store 提供的数据。 redux中间件？edux-logger：提供日志输出redux-thunk：处理异步操作redux-promise：处理异步操作，actionCreator的返回值是promise 如何在 Redux 中定义 Action？React 中的 Action 必须具有 type 属性，该属性指示正在执行的 ACTION 的类型。必须将它们定义为字符串常量，并且还可以向其添加更多的属性。在 Redux 中，action 被名为 Action Creators 的函数所创建。以下是 Action 和Action Creator 的示例： 解释 Reducer 的作用？Reducers 是纯函数，它规定应用程序的状态怎样因响应 ACTION 而改变。Reducers 通过接受先前的状态和 action 来工作，然后它返回一个新的状态。它根据操作的类型确定需要执行哪种更新，然后返回新的值。如果不需要完成任务，它会返回原来的状态。 Store 在 Redux 中的意义是什么？Store 是一个 JavaScript 对象，它可以保存程序的状态，并提供一些方法来访问状态、调度操作和注册侦听器。应用程序的整个状态/对象树保存在单一存储中。因此，Redux 非常简单且是可预测的。我们可以将中间件传递到 store 来处理数据，并记录改变存储状态的各种操作。所有操作都通过 reducer 返回一个新状态。 什么是React 路由？React 路由是一个构建在 React 之上的强大的路由库，它有助于向应用程序添加新的屏幕和流。这使 URL 与网页上显示的数据保持同步。它负责维护标准化的结构和行为，并用于开发单页 Web 应用。 React 路由有一个简单的API。 为什么React Router v4中使用 switch 关键字 ？虽然 ** 用于封装 Router 中的多个路由，当你想要仅显示要在多个定义的路线中呈现的单个路线时，可以使用 “switch” 关键字。使用时，** 标记会按顺序将已定义的 URL 与已定义的路由进行匹配。找到第一个匹配项后，它将渲染指定的路径。从而绕过其它路线。 为什么需要 React 中的路由？Router 用于定义多个路由，当用户定义特定的 URL 时，如果此 URL 与 Router 内定义的任何 “路由” 的路径匹配，则用户将重定向到该特定路由。所以基本上我们需要在自己的应用中添加一个 Router 库，允许创建多个路由，每个路由都会向我们提供一个独特的视图 react性能优化的方案？重写shouldComponentUpdate来避免不必要的dom操作。使用 production 版本的react.js。使用key来帮助React识别列表中所有子组件的最小变化。 介绍一下webpack？webpack是一个前端模块化打包工具，主要由入口，出口，loader，plugins四个部分。前端的打包工具还有一个gulp，不过gulp侧重于前端开发的过程，而webpack侧重于模块，例如他会将css文件看作一个模块，通过css-loader将css打包成符合css的静态资源。 react生命周期中，最适合与服务端进行数据交互的是哪个函数？componentDidMount：在这个阶段，实例和dom已经挂载完成，可以进行相关的dom操作。 shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）询问组件是否需要更新的一个钩子函数，判断数据是否需要重新渲染，返回一个布尔值。默认的返回值是true，需要重新render()。若如果返回值是false则不触发渲染,利用这个生命周期函数可以强制关闭不需要更新的子组件来提升渲染性能。 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。 指出(组件)生命周期方法的不同？componentWillMount – 多用于根组件中的应用程序配置componentDidMount – 在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据；如果需要设置事件监听，也可以在这完成componentWillReceiveProps – 这个周期函数作用于特定的 prop 改变导致的 state 转换shouldComponentUpdate – 如果你担心组件过度渲染，shouldComponentUpdate 是一个改善性能的地方，因为如果组件接收了新的 prop， 它可以阻止(组件)重新渲染。shouldComponentUpdate 应该返回一个布尔值来决定组件是否要重新渲染componentWillUpdate – 很少使用。它可以用于代替组件的 componentWillReceiveProps 和 shouldComponentUpdate(但不能访问之前的 props)componentDidUpdate – 常用于更新 DOM，响应 prop 或 state 的改变componentWillUnmount – 在这你可以取消网络请求，或者移除所有与组件相关的事件监听器 调用 setState 之后发生了什么？代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。 经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面；在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染；在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。 react diff 原理（常考，大厂必考）把树形结构按照层级分解，只比较同级元素。列表结构的每个单元添加唯一的 key 属性，方便比较。React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state 除了在构造函数中绑定 this，还有其它方式吗？你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。 setState第二个参数的作用?因为setState是一个异步的过程，所以说执行完setState之后不能立刻更改state里面的值。如果需要对state数据更改监听，setState提供第二个参数，就是用来监听state里面数据的更改，当数据更改完成，调用回调函数。 (在构造函数中)调用 super(props) 的目的是什么?在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。 在 React 当中 Element 和 Component 有何区别？React Element 是描述屏幕上所见内容的数据结构，是对于 UI 的对象表述。典型的 React Element 就是利用 JSX 构建的声明式代码片然后被转化为 createElement 的调用组合。 React Component 是一个函数或一个类，可以接收参数输入，并且返回某个 React Element (组件的)状态(state)和属性(props)之间有何不同?State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。 受控组件和非受控组件区别?受控组件：1.没有维持自己的状态2.数据由父组件控制3.通过 props 获取当前值，然后通过回调通知更改 非受控组件：1、保持着自己的状态2、数据由 DOM 控制3、Refs 用于获取其当前值","categories":[],"tags":[]},{"title":"JS面试题","slug":"JS面试题","date":"2017-10-22T06:35:33.000Z","updated":"2021-02-23T01:36:50.168Z","comments":true,"path":"2017/10/22/JS面试题/","link":"","permalink":"http://example.com/2017/10/22/JS%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别String、Number、Boolean、Null、undefined Object为复杂数据类型 基本数据类型把数据名和值直接存储在栈当中 复杂数据类型在栈中存储数据名和一个堆的地址，在堆中存储属性和值，访问时先从栈中获取地址再到堆中取相应的值 == 和 === 有什么区别==用于一般比较 比较时可以转换数据类型 ===用于严格比较 比较时只要类型不匹配就返回false 例举3种强制类型转换和2种隐式类型转换?强制：通过String（），Number（），Boolean（）函数强制转换 隐式：（乘，除，大于，小于，减，==） split() 和 join() 的区别split() 字符串转数组 如：var str = &quot;hello?word?welcome&quot; console.log(str.split(“？”)) 返回值为 [&quot;hello&quot;, &quot;word&quot;, &quot;welcome&quot;] join() 数组转字符串 如：var arr = new Array() arr[0] = &quot;hello&quot; arr[1] = &quot;world&quot; arr[3] = &quot;welcome&quot; arr.join(&quot;、&quot;) 返回值为 &quot;hello、world、welcome&quot; ajax请求的时候get 和post方式的区别一个在url后面 ，一个放在虚拟载体里面 get有大小限制(只能提交少量参数) 安全问题 应用不同 ，请求数据和提交数据 解释jsonp的原理，以及为什么不是真正的ajaxjsonp的核心原理就是目标页面回调本地页面的方法,并带入参数 动态创建script标签，使用回调函数 Ajax是页面无刷新请求数据操作 call()、bind()、apply()区别三者都是可以改变this的指向 bind() 返回对应函数便于稍后调用；call()、apply()则是立即调用 call() call(thisArg, case1, case2, case3,...) 第一个参数是对象 后面是字符串 apply() apply(thisArg, [case1, case2, case3,...]) 第一个参数是对象 后面是数组 数组有哪些操作方法unshift() 把参数添加到数组开头 shift() 把数组的第一个元素删除 push() 向数组末尾添加一个或多个元素 pop() 把数组的最后一个元素删除 concat() 连接两个或多个数组 join() 数组转成字符串 reverse() 数组倒叙 slice() 截取后返回新数组 [&#39;H&#39;,&#39;el&#39;,&#39;lo&#39;,&#39;wo&#39;,&#39;rld!&#39;].slice(1,3) 返回 [&quot;el&quot;, &quot;lo&quot;] splice() 添加或删除数组中的元素，这种方法会改变原始数组 sort() 数组元素排序 forEach() 遍历数组 filter() 返回符合条件的新数组，arr.filter((item,index,arr)=&gt;&#123;return 测试语句&#125;) Map() 对象有哪些操作方法assign() 合并对像 is() 对象比较是否严格相等 keys() 遍历键名，返回所有键名数组 values() 遍历键值，返回键值数组 什么是闭包,有什么特性，对页面有什么影响可以调用其它函数内部变量的函数 闭包就是能够读取其他函数内部变量的函数,避免变量污染、加强了封装性，逻辑性比较强代码的可读性高；加载到内存中执行效率高,使得函数不被GC回收，如果过多使用闭包，容易导致内存泄露,在内存中，造成了内存浪费，如果滥用闭包是灾难性的； 闭包的好处(1)希望一个变量长期驻扎在内存当中(不被垃圾回收机制回收) (2)避免全局变量的污染 (3)私有成员的存在 (4)安全性提高 怎么创建闭包在函数内部嵌套使用函数 1234567891011121314function fn() &#123; for (var i &#x3D; 0; i &lt; 2; i++) &#123; (function () &#123; var variate &#x3D; i; setTimeout(function () &#123; console.log(&quot;setTimeout执行后:&quot;+variate); &#125;, 1000); &#125;)();&#x2F;&#x2F;闭包,立即执行函数,匿名函数 &#125; console.log(i);&#x2F;&#x2F;2 console.log(variate);&#x2F;&#x2F;variate is not defined &#125; fn(); 如何阻止事件冒泡e.stopPropagation()（IE:window.event.cancelBubble=true） 如何阻止默认事件、阻止标签自带功能e.preventDefault()（IE:window.event.returnValue=false） 0级事件和2级事件0级：dom.on事件名称=function()&#123;&#125; 2级：dom.addEvenListener(&#39;事件类型&#39;,function()&#123;&#125;,布尔值(为true表在捕du获阶段调用处理函数.false在冒泡阶段调用.为了兼zhi,一般都用false)) 添加 删除 替换 插入到某个接点的方法1）创建新节点 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 2）添加、移除、替换、插入 appendChild() //添加 removeChild() //移除 replaceChild() //替换 insertBefore() //插入 3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值 getElementById() //通过元素Id，唯一性 null 和 undefined 的区别null表示没有对象，该处不该有值，转为数值时为0 undefined表示缺少值，该处应该有值，但是未定义，转为数值时为NaN 什么是变量提升变量提升是js的默认行为，变量提升会将所有变量声明移动到当前作用域的顶部，并可以在声明之前使用该变量，初始化不会被提升，提升的仅作用于变量的声明 什么是事件委托利用事件冒泡的原理，把原本需要绑定的事件委托给父元素，让父元素负责事件监听 深拷贝和浅拷贝浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。 深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象 async与defer区别异步(async) 脚本将在其加载完成后立即执行，而 延迟(defer) 脚本将等待 HTML 解析完成后，并按加载顺序执行。 cookies，sessionStorage和localStorage 有什么区别？cookies可以和服务端交互，数据大小不会超过4k，设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭，使用方法需要自己封装不够友好; sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存，虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大，有封装好的方法，可以直接存取值 localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除。 数组去重有哪些方法1new Set() 如：var arr &#x3D; [1,2,3,9,6,3,1,2,6] new set(arr) 利用冒泡for循环嵌套，然后splice()去重 如： 12345678910111213function unique(arr)&#123; for(var i&#x3D;0; i&lt;arr.length; i++)&#123; for(var j&#x3D;i+1; j&lt;arr.length; j++)&#123; if(arr[i]&#x3D;&#x3D;arr[j])&#123; &#x2F;&#x2F;第一个等同于第二个，splice方法删除第二个 arr.splice(j,1); j--; &#125; &#125; &#125;return arr;&#125;var arr &#x3D; [1,2,3,9,6,3,1,2,6]console.log(unique(arr)) indexOf()去重 如：123456789101112131415function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log(&#39;type error!&#39;) return &#125; var array &#x3D; []; for (var i &#x3D; 0; i &lt; arr.length; i++) &#123; if (array .indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) &#123; array .push(arr[i]) &#125; &#125; return array;&#125;var arr &#x3D; [1,2,3,9,6,3,1,2,6] console.log(unique(arr)) sort()去重 如：1234567891011121314151617function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log(&#39;type error!&#39;) return; &#125; arr &#x3D; arr.sort() var arrry&#x3D; [arr[0]]; for (var i &#x3D; 1; i &lt; arr.length; i++) &#123; if (arr[i] !&#x3D;&#x3D; arr[i-1]) &#123; arrry.push(arr[i]); &#125; &#125; return arrry; &#125;var arr &#x3D; [1,2,3,9,6,3,1,2,6]console.log(unique(arr)) filter()去重 如:123456789function unique(arr) &#123; return arr.filter(function(item, index, arr) &#123; return arr.indexOf(item, 0) &#x3D;&#x3D;&#x3D; index; &#125;);&#125;var arr &#x3D; [1,2,3,9,6,3,1,2,6]console.log(unique(arr)) 行代码实现数组去重？1[...new Set([1,2,3,1,&#39;a&#39;,1,&#39;a&#39;])] 冒泡排序1234567891011var array &#x3D; [5, 4, 3, 2, 1];var temp &#x3D; 0;for (var i &#x3D; 0; i &lt;array.length; i++)&#123; for (var j &#x3D; 0; j &lt;array.length - i; j++)&#123; if (array[j] &gt; array[j + 1])&#123; temp &#x3D; array[j + 1]; array[j + 1] &#x3D; array[j]; array[j] &#x3D; temp; &#125; &#125;&#125; 降维数组12345var arr&#x3D;[[1,2],[3,4]];function Jw(obj)&#123; return Array.prototype.concat.apply([],obj);&#125;Jw(arr); GET 和 POST 有什么区别GET请求在浏览器回退和刷新时是无害的，而POST请求会告知用户数据会被重新提交； GET请求可以收藏为书签，POST请求不可以收藏为书签； GET请求可以被缓存，POST请求不可以被缓存，除非在响应头中包含合适的Cache-Control/Expires字段，但是不建议缓存POST请求，其不满足幂等性，每次调用都会对服务器资源造成影响； GET请求一般不具有请求体，因此只能进行url编码，而POST请求支持多种编码方式。 GET请求的参数可以被保留在浏览器的历史中，POST请求不会被保留； GET请求因为是向URL添加数据，不同的浏览器厂商，代理服务器，web服务器都可能会有自己的长度限制，而POST请求无长度限制； GET请求只允许ASCII字符，POST请求无限制，支持二进制数据； GET请求的安全性较差，数据被暴露在浏览器的URL中，所以不能用来传递敏感信息，POST请求的安全性较好，数据不会暴露在URL中； GET请求具有幂等性(多次请求不会对资源造成影响)，POST请求不幂等； GET请求一般不具有请求体，请求中一般不包含100-continue 协议，所以只会发一次请求，而POST请求在发送数据到服务端之前允许双方&quot;握手&quot;，客户端先发送Expect:100-continue消息，询问服务端是否愿意接收数据，接收到服务端正确的100-continue应答后才会将请求体发送给服务端，服务端再响应200返回数据。 跨域有几种解决方案jsonp 适用于get请求 document.domain + iframe 适用于主域相同 子域不同 两个页面都通过js强制设置document.domain为基础主域，就实现了同域 location.hash + iframe window.name + iframe postMessage (data,origin)方法接受两个参数 data：需要传递的数据，html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。 origin：协议+主机+端口号，也可以设置为&quot;*&quot;，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为&quot;/&quot;。 跨域资源共享（CORS） typeof和instanceof有什么区别typeof 判断一个数据是什么数据类型；一般只能返回如下几个结果：&quot;number&quot;、&quot;string&quot;、&quot;boolean&quot;、&quot;object&quot;、&quot;function&quot; 和 &quot;undefined&quot;。 instanceof 判断一个对象是否在另一个对象的原型链上 函数声明与函数表达式的区别？在Javscript中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。 Javascript的事件流模型都有什么?“事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播 “事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的 “DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡 希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)12345678var inputs &#x3D; document.getElementsByTagName(&quot;input&quot;);&#x2F;&#x2F;获取所有的input标签对象var checkboxArray &#x3D; [];&#x2F;&#x2F;初始化空数组，用来存放checkbox对象。for(var i&#x3D;0;i&lt;inputs.length;i++)&#123; var obj &#x3D; inputs[i]; if(obj.type&#x3D;&#x3D;&#39;checkbox&#39;)&#123; checkboxArray.push(obj); &#125;&#125; 如何获取javascript三个数中的最大值和最小值？Math.max(a,b,c);//最大值 Math.min(a,b,c)//最小值 javascript是面向对象的，怎么体现javascript的继承关系？使用prototype原型来实现。 列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型。主要数据类型：string, boolean, number 复合数据类型：function, object 特殊类型：undefined，null 解释什么是Json:(1)JSON 是一种轻量级的数据交换格式。 (2)JSON 独立于语言和平台，JSON 解析器和 JSON 库支持许多不同的编程语言。 (3)JSON的语法表示三种类型值，简单值(字符串，数值，布尔值，null),数组，对象 js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？alert confirm prompt 浏览器的滚动距离：可视区域距离页面顶部的距离 scrollTop=document.documentElement.scrollTop||document.body.scrollTop innerHTML、innerText和outerHTML的区别innerHTML(元素内包含的内容） innerText(元素的文本内容） outerHTML(自己以及元素内的内容） offsetWidth offsetHeight和clientWidth clientHeight的区别(1)offsetWidth （content宽度+padding宽度+border宽度） (2)offsetHeight（content高度+padding高度+border高度） (3)clientWidth（content宽度+padding宽度） (4)clientHeight（content高度+padding高度） 请解释一下什么是语义化的HTML。内容使用特定标签，通过标签就能大概了解整体页面的布局分布 请说出三种减低页面加载时间的方法1、压缩css、js文件 2、合并js、css文件，减少http请求 3、外部js、css文件放在最底下 4、减少dom操作，尽可能用变量替代不必要的dom操作 请解释什么是Javascript的模块模式，并举出实用实例。js模块化mvc（数据层、表现层、控制层） seajs 命名空间 你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？对内：模块模式 对外：继承 你如何优化自己的代码？代码重用 避免全局变量（命名空间，封闭空间，模块化mvc..） 拆分函数避免函数过于臃肿 注释 你能解释一下JavaScript中的继承是如何工作的吗？子构造函数中执行父构造函数，并用call\\apply改变this 克隆父构造函数原型上的方法 最简单的一道题123var a &#x3D; 2, b &#x3D; 3;var c &#x3D; a++ + b; &#x2F;&#x2F; c &#x3D; 5 dom事件委托什么原理，有什么优缺点事件委托原理:事件冒泡机制 优点 1.可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错。 2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适 缺点 事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。 js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型1.基本数据类型（自身不可拆分的）：Undefined、Null、Boolean、Number、String 2.引用数据类型（对象）：Object （Array，Date，RegExp，Function） ES6基本数据类型多了个symbol 据说这道题刷了百分之二十的人 感谢Abbyshen提出 123function gettype(nm)&#123; return Object.prototype.toString.call(nm);&#125; js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处1 标记清除（mark and sweep） 2 引用计数（reference counting） 好处：大幅简化程序的内存管理代码，减轻程序猿负担，并且减少因为长时间运转而带来的内存泄露问题。 坏处：自动回收意味着程序猿无法掌控内存。ECMAScript中没有暴露垃圾回收的借口，我们无法强迫其进行垃圾回收，更加无法干预内存管理。 setTimeout 和 setInterval 细谈常问的点，前者是在一定时间过后将函数添加至执行队列，执行时间=延迟时间+之前函数代码执行时间+执行函数时间。 后者是不管前一次是否执行完毕，每隔一定时间重复执行，用于精准执行互相没有影响的重复操作。 如果需要控制前后执行顺序，最好使用setTimeout模拟setInterval 1234567891011var time &#x3D; 400, times &#x3D; 0, max &#x3D; 10;function func()&#123;times++;if(times &lt; max)&#123; &#x2F;&#x2F;code here setTimeout(func, time);&#125; else &#123; console.log(&quot;finished&quot;);&#125;&#125;setTimeout(func, time); 判断数组123function isArray(arr)&#123; return Object.prototype.toString.call(arr) &#x3D;&#x3D;&#x3D; &#39;[Object Array]&#39;;&#125; window.name即使在页面打开多层iframe后，每个iframe中window.name 属性值都是相同的，以此用作数据传输的工具。 但由于跨域的限制，是无法获取另一个frame中的window.name数据，所以要使用一个同域的代理(proxy.html)： forEach和map的区别相同点都是循环遍历数组中的每一项 forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组） 匿名函数中的this都是指向window 只能遍历数组 都有兼容问题 不同点map速度比foreach快 map会返回一个新数组，不对原数组产生影响,foreach不会产生新数组， map因为返回数组所以可以链式操作，foreach不能","categories":[],"tags":[]},{"title":"居中总结","slug":"居中总结","date":"2017-06-10T11:55:00.000Z","updated":"2020-12-30T11:55:35.913Z","comments":true,"path":"2017/06/10/居中总结/","link":"","permalink":"http://example.com/2017/06/10/%E5%B1%85%E4%B8%AD%E6%80%BB%E7%BB%93/","excerpt":"剧中总结！水平居中 绝对定位+left+margin-left .first{ position: absolute; left: 50%; margin-left: -50px;//也就是1/2width}","text":"剧中总结！水平居中 绝对定位+left+margin-left .first{ position: absolute; left: 50%; margin-left: -50px;//也就是1/2width} ☠️必须得知道物体的宽高 2.绝对定位+left+transform .second{ position: absolute; left:50%; -webkit-transform: translate(-50%); -moz-transform: translate(-50%); -ms-transform: translate(-50%); -o-transform: translate(-50%); transform: translate(-50%);}😍transform的妙用，translate位移是针对自身的，所以可以不知道自身的宽度，是上面的升级版。 3.绝对定位+margin+左右 .third{ margin:auto; position: absolute; left:0; right:0; }😍margin的妙用，如果设置左右为0，那么水平居中，如果设置上下左右都为0，那么就在整个页面居中（也就是水平也居中垂直也居中），换言之，如果值设置上下为0，那么垂直方向居中。 4.flex布局 .box{ display:flex; justify-content:center;}😍很简洁的样子，给父元素设置两行就能做到水平居中了 相对定位+margin .fouth{ position:relative; margin:x auto x;//x代表随意的数值}😍好简洁 5.text-align .box{ text-align:center;}😍text-align属性只对行内元素有效，比如图片、文字、span等，当然也能让它对div奏效，把块级元素设为行内元素就行了。这个属性是设置在父盒子上面的。一般用来设置图片和文字居中比较多。 垂直居中 1.line-height .box{ line-height:50px;}😍设置行高，子元素会垂直居中，不论是行内还是块级子元素都有效。 ☠️只对单行文字有效。 2.多行文字垂直居中 //第一种.box{ display:table; height:200px;}.child{ display:table-sell; vertical-aligh:middle;}//第二种.box{ display:table-sell; height:200px; vertical-align:middle;}.child{ display:inline-block;}👉vertical-align是用来指定行内元素和表格单元格（table-sell）元素的垂直对齐方式","categories":[],"tags":[]}],"categories":[],"tags":[]}