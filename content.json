{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"hook中的useState、useEffect","slug":"Hook","date":"2020-12-26T01:02:04.000Z","updated":"2020-12-27T11:13:49.548Z","comments":true,"path":"2020/12/26/Hook/","link":"","permalink":"http://example.com/2020/12/26/Hook/","excerpt":"","text":"Hook 是React 16.8的新增特性。它可以让你在不编写 class的情况下使用 state 以及其他的 React特性。 Hook是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数 Hook 不能在 class 组件中使用 const [state, setState] = useState(initialState) 返回一个 state,以及更新 state 的函数 当 state 为引用类型，修改时注意要合并其他值，不然会发生错误 多个 state 最好分开写 setState 也可以接收一个函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 function Home()&#123; const [count, setCount] &#x3D; useState(0) &#x2F;&#x2F;也可以在state里写对象 const [person, setPerson] &#x3D; useState(&#123; name:&#39;大黄&#39;, age:&#39;18&#39;, sex:&#39;女&#39; &#125;) const [num,setNum] &#x3D; useState(100) return ( &lt;div&gt; 我是todolist count:&#123;count&#125; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setCount(count+1)&#125;&#125;&gt;加+&lt;&#x2F;button&gt; &#123;&#x2F;* setCount和class组件setState是一样的都是修改state的状态的*&#x2F;&#125; &lt;div&gt; name:&#123;person.name&#125; age:&#123;person.age&#125; sex:&#123;person.sex&#125; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setPerson(&#123;age:19&#125;)&#125;&#125;&gt;给大黄过年&lt;&#x2F;button&gt; &#123;&#x2F;* 这里当我们点击了按钮调用setState，只修改了age,虽然年龄变成了19，但是其他属性都为空了，所以说 在调用setState时，如果它是个引用类型时我们要它另外值合并一下 onClick&#x3D;&#123;()&#x3D;&gt;&#123;setPerson(&#123;age:19,name:person.name,sex:person.sex&#125;)&#125;&#125; 这样写就没问题了 *&#x2F;&#125; &lt;&#x2F;div&gt; &lt;div&gt; 计数：&#123;num&#125; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setNum((oval)&#x3D;&gt;&#123;console.log(oval);return oval+1&#125;)&#125;&#125;&gt;&lt;&#x2F;button&gt; &#123;&#x2F;* setState还可以接收一个函数 *&#x2F;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; ) &#125; export default Home &#x2F;&#x2F;useEffect!! useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;参数是个函数：也叫副作用函数 return ()&#x3D;&gt;&#123;&#125;&#x2F;&#x2F;返回函数 返回的函数式可选的 可以不写返回函数 &#125;,[])&#x2F;&#x2F;这里的数组是依赖参数 依赖也是可选的 作用函数： 1.当useEffect ,没有依赖参数时，副作用函数，会在组件挂载完成及组件更新完成时执行 2.当有依赖参数副作用函数，会在组件挂载完成及改依赖参数修改，引起的组件更新完成之后执行 3.当依赖参数为空数组时，会在组件挂载完成之后执行 4.返回函数在组件更新完成，或即将写在执行，一般返回函数用在即将卸载时 useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;当没有依赖参数和返回函数的时候，现在就相当于class组件的componentDidMount、componentUpdate生命周期 console.log(1,&#39;useEffect&#39;)&#x2F;&#x2F;一直触发btn，一直在打印&#125;)useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;当依赖参数为空和没有返回函数时，只执行了一次，后面在触发btn时，不在执行.相当于componentDidMount console.log(2,&#39;useEffect&#39;)&#125;,[])useEffect(()&#x3D;&gt;&#123; console.log(3,&#39;useEffect&#39;)&#125;,[name])&#x2F;&#x2F;在有依赖参数时，组件挂载完会执行一次，在后面触发btn时，如果依赖参数没有发生改变，不会再打印useEffect(()&#x3D;&gt;&#123; return ()&#x3D;&gt;&#123; console.log(4,&#39;useEffect&#39;) &#125;&#x2F;&#x2F;当没有依赖，有返回函数的时候，初次挂载完返回函数不会执行，但是当触发btn时，就是组件发生改变，它就会执行返回函数的代码&#125;,)&#x2F;&#x2F;如果此处有依赖，但不空，那就当依赖的参数发生改变的时候，返回函数内的代码也会执行useEffect(()&#x3D;&gt;&#123; return ()&#x3D;&gt;&#123; console.log(&#39;更新或者卸载&#39;) &#125;&#125;,[count])&#x2F;&#x2F;也可以有依赖参数并且会更新用返回函数进行卸载或更新&#x2F;&#x2F;缺点：挂载前和更新前的生命周期要用到别的方法来配合使用useEffect。这里更多的是挂载完和更新完","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-12-25T01:36:20.562Z","updated":"2020-12-25T01:36:20.562Z","comments":true,"path":"2020/12/25/hello-world/","link":"","permalink":"http://example.com/2020/12/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"手写Promise","slug":"手写Promise","date":"2018-05-25T14:10:50.000Z","updated":"2020-12-27T12:35:16.339Z","comments":true,"path":"2018/05/25/手写Promise/","link":"","permalink":"http://example.com/2018/05/25/%E6%89%8B%E5%86%99Promise/","excerpt":"","text":"手写Promise 主要是解决回调地狱的问题，在ES6中出现了promise来解决这个问题，但是同样也带来了多个.then()的问题 //随着es7 async和await到来可以说彻底解决回调地狱。 new Promise() //是谁执行了？直接new一个Promise是内置构造Promise执行了，但是它会报错。因为这里缺一个回调函数，平常大家也都是这么用的 new Promise(()=&gt;{ console.log(‘你大爷’)//‘你大爷’会执行吗？：这里new了一个Promose,Promise执行一次，那里面的回调函数也会执行，所以‘你大爷’成功被打印 }) function fn(callBack){ &#125; new fn(()=&gt;&#123; &#125;)//fn执行，但是里面的回调并没有，Promise的回调会执行。 //new Promise 是内置构造函数Promise执行一次 //Promise的回调函数也会执行一次，这个回调函数会给我们提供两个形参（函数）：成功、失败 //Promise的回调函数，又有两个参数分别是：resolve、reject两个函数 //Promise类的实例没有then方法，应该是原型对象的方法 var obj = new Promise((resolve,rejecct)=&gt;&#123; console.log(resolve,reject)//两个函数 &#125;)//obj是Promise的一个实例 // 手写 function myPromise(callBack)&#123;//接受传进来的回调函数 //状态属性 this.status=&#39;pending&#39; //回调函数 callBack(resolve.bind(this),reject.bing(this)) //定义一个成功的函数 function resolve(hello, params)&#123; //那么console.log(hello)肯定是执行的（很早演示时写） //修改状态（后写） if(this.status===&#39;pending&#39;)&#123;//如果出事状态为pengding, this.status=&#39;success&#39;//那就把它改成success成功 //这里还有一个上下文的问题。成功时resolve是怎么调用的？是函数名+小括号，也就是window. //但这里就不该用window，因为将来获取服务器的数据实在.then()里的来获取。所以我们在初始化时就要给 //resolve和reject绑死这个类的实例：resolve.bind(this) reject.bing(this) 走起上面绑死↑ //否则你在调用resolve和reject时他们就会指向window //为什么绑死上下文为这个类的实例？因为我们要借用这个类的实例的成功和失败的方法74行里面成功与失败的回调 //所以↓ this.successCallBack(params)//这个是谁？它就是then的第一个参数也就是成功的回调，所以把参数直接注进来就行了 //失败同样 &#125; &#125; //定义一个失败的函数 function reject(err)&#123; if(this.status===&#39;pending&#39;)&#123; this.status=&#39;faile&#39; this.faileCallBack(err) &#125; &#125; &#125; //调用 new myPromise(()=&gt;&#123;//并且传进去一个回调函数。但是我们在实际运用中肯定要传2个参数进去。resolve,reject,并且37行回调也要接受这个2个函数 //console.log(&#39;我是Promise&#39;)//这里肯定会执行。打印。 //假如这里调用并传参resolve(&#39;hello&#39;) //处理异步,一般promise就是处理异步的 setTimeout(()=&gt;&#123; resolve(&#39;我是promise&#39;) &#125;) &#125;)//假如我们是在处理异步请求那么肯定要在这.then()。但是能直接.then()吗？要注意.then()是在原型上面的。虽然链式语法可以这么写，但是这里并没有这个方法。.then()应该是原型上面类的原型的方法 .then((data)=&gt;&#123; console.log(data) &#125;,()=&gt;&#123;&#125;)//一般我们在调用then()的时候肯定要传2个参数进去，下面接收，就是相当于将then方法里面成功与失败的回调函数当做当前类的实例即可，当前类是谁？promise //所以原型上定义一个then的方法，应该是 myPromise.prototype.then=function(success,faile)&#123;//接收上面调用then时传进来的来个函数。就是将then方法里面成功与失败的回到函数作为当前类的实例即可 this.successCallBack=success//相当于then传进一个成功的函数给了success,就是给myPromise的实例动态添加了属性就是success这个成功的箭头函数。还有一个失败的同样 this.faileCallBack=faile //then()的两个函数相当于作为这个实例的两个方法 &#125; //53行异步成功后执行，就是相当于调用了41行那个方法。失败同样 //因为promise有3中状态，pending、成功、失败。所以此时我去上面给类定义个状态的属性，走起↑ //如果说异步解决成功就调用resolve方法 。resolve就是41行函数执行。但是我们都是在then()来获取成功或失败的数据，(其实就是调用this.successCallBack，this.faileCallBack)。所以走起去上面↑，就是修改promise的状态 12345678910111213141516171819202122232425262728293031323334(()&#x3D;&gt;&#123; window.myPromise&#x3D;function(callBack)&#123; &#x2F;&#x2F;状态属性 this.status&#x3D;&#39;pending&#39; &#x2F;&#x2F;回调函数 callBack(resolve.bind(this),reject.bind(this)) &#x2F;&#x2F; 成功 function resolve(params)&#123; if(this.status&#x3D;&#x3D;&#x3D;&#39;pending&#39;)&#123; this.status&#x3D;&#39;success&#39; this.successCallBack(params) &#125; &#125; &#x2F;&#x2F; 失败 function reject(err)&#123; if(this.status&#x3D;&#x3D;&#x3D;&#39;pending&#39;)&#123; this.status&#x3D;&#39;faile&#39; this.successCallBack(err) &#125; &#125; &#125; &#x2F;&#x2F;原型上定义一个then的方法 myPromise.prototype.then&#x3D;function(success,faile)&#123; this.successCallBack&#x3D;success this.faileCallBack&#x3D;faile &#125;&#125;)()var obj &#x3D; new myPromise((resolve,reject)&#x3D;&gt;&#123; setTimeout(()&#x3D;&gt;&#123; resolve(&#39;你真好&#39;) &#125;,1000)&#125;).then((data)&#x3D;&gt;&#123; console.log(data)&#x2F;&#x2F;成功执行&#125;)","categories":[],"tags":[]}],"categories":[],"tags":[]}