{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"js严格模式","slug":"js严格模式","date":"2021-06-09T10:47:35.000Z","updated":"2020-12-30T11:00:42.499Z","comments":true,"path":"2021/06/09/js严格模式/","link":"","permalink":"http://example.com/2021/06/09/js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"JavaScript 严格模式(use strict)使用 “use strict” 指令“use strict” 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。 它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。 “use strict” 的目的是指定代码在严格条件下执行。 严格模式下你不能使用未声明的变量。支持严格模式的浏览器:Internet Explorer 10 +、 Firefox 4+ Chrome 13+、 Safari 5.1+、 Opera 12+。 严格模式声明严格模式通过在脚本或者函数的头部添加 ‘use static;表达式来声明 123&quot;use strict&quot;;x &#x3D; 3.14; &#x2F;&#x2F; 报错 (x 未定义)严格模式下，需要用var let 或者 const 来声明 1234567&quot;use strict&quot;;myFunction();function myFunction() &#123; y &#x3D; 3.14; &#x2F;&#x2F; 报错 (y 未定义)&#125;在函数内部声明是局部作用域 (只在函数内使用严格模式): 1234567x &#x3D; 3.14; &#x2F;&#x2F; 不报错myFunction();function myFunction() &#123; &quot;use strict&quot;; y &#x3D; 3.14; &#x2F;&#x2F; 报错 (y 未定义)&#125; 为什么使用严格模式: 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;消除代码运行的一些不安全之处，保证代码运行的安全；提高编译器效率，增加运行速度；为未来新版本的Javascript做好铺垫。“严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。 另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。 1234&quot;use strict&quot;;var x &#x3D; 3.14;delete x; 不允许删除变量或对象 123&quot;use strict&quot;;function x(p1, p1) &#123;&#125;; 不允许变量重名 123&quot;use strict&quot;;var x &#x3D; 010; &#x2F;&#x2F; 报错不允许使用八进制 123&quot;use strict&quot;;var x &#x3D; \\010; &#x2F;&#x2F; 报错不允许使用转义字符: 123456&quot;use strict&quot;;var obj &#x3D; &#123;&#125;;Object.defineProperty(obj, &quot;x&quot;, &#123;value:0, writable:false&#125;);obj.x &#x3D; 3.14; &#x2F;&#x2F; 报错不允许对只读属性赋值 12345&quot;use strict&quot;;var obj &#x3D; &#123;get x() &#123;return 0&#125; &#125;;obj.x &#x3D; 3.14; &#x2F;&#x2F; 报错不允许对一个使用getter方法读取的属性进行赋值 123&quot;use strict&quot;;delete Object.prototype; &#x2F;&#x2F; 报错不允许删除一个不允许删除的属性 123&quot;use strict&quot;;var eval &#x3D; 3.14; &#x2F;&#x2F; 报错变量名不能使用 &quot;eval&quot; 字符串: 123&quot;use strict&quot;;var arguments &#x3D; 3.14; &#x2F;&#x2F; 报错变量名不能使用 &quot;arguments&quot; 字符串 123&quot;use strict&quot;;with (Math)&#123;x &#x3D; cos(2)&#125;; &#x2F;&#x2F; 报错\\不允许使用一下语句 1234&quot;use strict&quot;;eval (&quot;var x &#x3D; 2&quot;);alert (x); &#x2F;&#x2F; 报错由于一些安全原因，在作用域 eval() 创建的变量不能被调用： 1234567891011禁止this关键字指向全局对象。function f()&#123; return !this;&#125; &#x2F;&#x2F; 返回false，因为&quot;this&quot;指向全局对象，&quot;!this&quot;就是falsefunction f()&#123; &quot;use strict&quot;; return !this;&#125; &#x2F;&#x2F; 返回true，因为严格模式下，this的值为undefined，所以&quot;!this&quot;为true。 123456因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。function f()&#123; &quot;use strict&quot;; this.a &#x3D; 1;&#125;;f();&#x2F;&#x2F; 报错，this未定义","categories":[],"tags":[]},{"title":"函数的length","slug":"函数的length","date":"2021-01-05T10:36:48.000Z","updated":"2021-01-05T11:25:52.449Z","comments":true,"path":"2021/01/05/函数的length/","link":"","permalink":"http://example.com/2021/01/05/%E5%87%BD%E6%95%B0%E7%9A%84length/","excerpt":"","text":"ES6中的函数length属性ES6中函数的length属性，将返回没有指定默认值的参数个数。也就是说指定了默认值后，length属性将失真。 1234在es6之前函数的length就是指函数声明形参的个数function fn1()&#123;&#125; &#x2F;&#x2F;length为0function fn2(a,b)&#123;&#125; &#x2F;&#x2F;length为1function fn3(a,b,c) &#x2F;&#x2F;length为3 但是在ES6之后，就发生了变化，因为ES6更新了一个新特性，让函数可以给形参设置默认值 12function fn1(a,b&#x3D;10)&#123;&#125;&#x2F;&#x2F;这种写法在ES6之前是不允许的 有了这一新特性之后，length的解释就要修改成这样：length的值是指函数的第一个具有默认值得形参之前的形参的个数！！！写点代码更好理解 123456function fn1(a,b)&#123;&#125; &#x2F;&#x2F;因为a,b 没有默认值，length的值为2！function fn2(a&#x3D;1,b)&#123;&#125; &#x2F;&#x2F;因为a 为‘第一个具有默认值得形参’，而a的前面没有其他形参了，所以length为1function fn3(a,b&#x3D;1,c)&#123;&#125; &#x2F;&#x2F;b为‘第一个具有默认值的形参’，前面还有一个a，length为1 。function fn4(a,b,c&#x3D;1)&#123;&#125; &#x2F;&#x2F;所以length为2 因为‘c为第一个具有默认值的形参’function fn5(a,b&#x3D;1,c,d&#x3D;2)&#123;&#125; &#x2F;&#x2F;length为1。因为‘b为第一个具有默认值的形参’，它前面只有一个a,并且只算&#x2F;&#x2F;具有默认值形参前面的形参的个数，后面的不算所以是1个。 123注意，当函数拥有剩余参数时，比如function fn1(a,...args)&#123;&#125; &#x2F;&#x2F;length为1，剩余参数也有默认值，默认为空数组。前面有只有一个a，所以length为1function fn1(...args)&#123;&#125; &#x2F;&#x2F;如果函数形参只有一个默认参数，那么length为0！","categories":[],"tags":[]},{"title":"Proxy","slug":"Proxy","date":"2020-12-31T00:54:45.000Z","updated":"2020-12-31T05:40:10.862Z","comments":true,"path":"2020/12/31/Proxy/","link":"","permalink":"http://example.com/2020/12/31/Proxy/","excerpt":"","text":"async函数默认返回一个Promise对象proxy 对对象操作进行拦截new Proxy()接受两个参数，第一个是目标对象，另一个是拦截方法12345678910111213let obj &#x3D; &#123; name:&#39;hello&#39;, age:&#39;18&#39; &#125; &#x2F;&#x2F;相当于proxy1代理了obj,需要通过proxy1 去操作代理的obj let proxy1 &#x3D; new Proxy(obj,&#123; get(target,key,proxy)&#123;&#x2F;&#x2F;get 方法只要是对对象进行获取操作就会触发get方法 console.log(arguments)&#x2F;&#x2F;得到target:目标对象和key:name属性名，以及proxy实例 &#x2F;&#x2F;这里return什么，就会返回什么，如果没有return，就是undefined console.log(&#39;触发了&#39;) return target[key]&#x2F;&#x2F;返回属性name的值 &#125;&#125;) console.log(proxy1.name)&#x2F;&#x2F;&#39;触发了&#39; set()12345678910111213141516171819202122232425let obj&#x3D;&#123; name:&#39;hello world&#39;, &#125; let proxy2 &#x3D; new Proxy(obj,&#123; get(target,key,receiver)&#123; return target[key]&#x2F;&#x2F;获取想要得到的属性 &#125;, set(target,key,value,receiver)&#123; console.log(&#39;要设置&#39;) console.log(arguments) &#x2F;&#x2F;key这里就是要设置的那个age属性 target[key]&#x3D;value return true &#x2F;&#x2F;最后返回一个布尔值 &#125;, has(target,key)&#123;&#x2F;&#x2F;拦截in这个操作。接收两个参数，目标对象和判断的那个属性名 if(key.startsWith(&#39;_&#39;))&#123;&#x2F;&#x2F;判断下是否是带__的属性比如&#39;__proto__&#39; return false &#125;else&#123; return key in target &#125; &#125;, &#125;) proxy2.age&#x3D;10&#x2F;&#x2F;这里我们想要给obj设置一个age为10的属性 console.log(obj) console.log(&#39;name&#39; in proxy2) apply()//拦截实例作为函数调用的时候：proxy3()1234567891011121314151617181920212223function query()&#123; console.log(this) return &#123;name:&#39;hello world&#39;&#125; &#125; let obj &#x3D; &#123;name:&#39;北京&#39;&#125; let proxy3 &#x3D; new Proxy(query,&#123; apply(target,object,args)&#123; &#x2F;&#x2F;函数直接执行()、通过call执行、apply执行，都会触发此处。 &#x2F;&#x2F;object 给函数修改this &#x2F;&#x2F; args 函数执行的参数 console.log(&#39;执行&#39;) console.log(target,object,args) if(object)&#123; object.fn&#x3D;target object.fn(...args) delete object.fn &#125;else&#123; target(...args) &#125; &#125; &#125;) proxy3() console.log(proxy3.call(obj,1,2,3))","categories":[],"tags":[]},{"title":"hook中的API","slug":"Hook","date":"2020-12-26T01:02:04.000Z","updated":"2020-12-30T10:41:37.558Z","comments":true,"path":"2020/12/26/Hook/","link":"","permalink":"http://example.com/2020/12/26/Hook/","excerpt":"","text":"Hook 是React 16.8的新增特性。它可以让你在不编写 class的情况下使用 state 以及其他的 React特性。 Hook是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数 Hook 不能在 class 组件中使用 const [state, setState] = useState(initialState) 返回一个 state,以及更新 state 的函数 当 state 为引用类型，修改时注意要合并其他值，不然会发生错误 多个 state 最好分开写 setState 也可以接收一个函数 1234567891011121314151617181920212223242526272829303132333435function Home()&#123; const [count, setCount] &#x3D; useState(0) &#x2F;&#x2F;也可以在state里写对象 const [person, setPerson] &#x3D; useState(&#123; name:&#39;大黄&#39;, age:&#39;18&#39;, sex:&#39;女&#39; &#125;) const [num,setNum] &#x3D; useState(100) return ( &lt;div&gt; 我是todolist count:&#123;count&#125; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setCount(count+1)&#125;&#125;&gt;加+&lt;&#x2F;button&gt; &#123;&#x2F;* setCount和class组件setState是一样的都是修改state的状态的*&#x2F;&#125; &lt;div&gt; name:&#123;person.name&#125; age:&#123;person.age&#125; sex:&#123;person.sex&#125; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setPerson(&#123;age:19&#125;)&#125;&#125;&gt;给大黄过年&lt;&#x2F;button&gt; &#123;&#x2F;* 这里当我们点击了按钮调用setState，只修改了age,虽然年龄变成了19，但是其他属性都为空了，所以说 在调用setState时，如果它是个引用类型时我们要它另外值合并一下 onClick&#x3D;&#123;()&#x3D;&gt;&#123;setPerson(&#123;age:19,name:person.name,sex:person.sex&#125;)&#125;&#125; 这样写就没问题了 *&#x2F;&#125; &lt;&#x2F;div&gt; &lt;div&gt; 计数：&#123;num&#125; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setNum((oval)&#x3D;&gt;&#123;console.log(oval);return oval+1&#125;)&#125;&#125;&gt;&lt;&#x2F;button&gt; &#123;&#x2F;* setState还可以接收一个函数 *&#x2F;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; )&#125;export default Home useEffect12345678910111213141516171819202122232425262728 useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;参数是个函数：也叫副作用函数 return ()&#x3D;&gt;&#123;&#125;&#x2F;&#x2F;返回函数 返回的函数式可选的 可以不写返回函数 &#125;,[])&#x2F;&#x2F;这里的数组是依赖参数 依赖也是可选的 作用函数： 1.当useEffect ,没有依赖参数时，副作用函数，会在组件挂载完成及组件更新完成时执行 2.当有依赖参数副作用函数，会在组件挂载完成及改依赖参数修改，引起的组件更新完成之后执行 3.当依赖参数为空数组时，会在组件挂载完成之后执行 4.返回函数在组件更新完成，或即将写在执行，一般返回函数用在即将卸载时 useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;当没有依赖参数和返回函数的时候，现在就相当于class组件的componentDidMount、componentUpdate生命周期 console.log(1,&#39;useEffect&#39;)&#x2F;&#x2F;一直触发btn，一直在打印&#125;)useEffect(()&#x3D;&gt;&#123;&#x2F;&#x2F;当依赖参数为空和没有返回函数时，只执行了一次，后面在触发btn时，不在执行.相当于componentDidMount console.log(2,&#39;useEffect&#39;)&#125;,[])useEffect(()&#x3D;&gt;&#123; console.log(3,&#39;useEffect&#39;)&#125;,[name])&#x2F;&#x2F;在有依赖参数时，组件挂载完会执行一次，在后面触发btn时，如果依赖参数没有发生改变，不会再打印useEffect(()&#x3D;&gt;&#123; return ()&#x3D;&gt;&#123; console.log(4,&#39;useEffect&#39;) &#125;&#x2F;&#x2F;当没有依赖，有返回函数的时候，初次挂载完返回函数不会执行，但是当触发btn时，就是组件发生改变，它就会执行返回函数的代码&#125;,)&#x2F;&#x2F;如果此处有依赖，但不空，那就当依赖的参数发生改变的时候，返回函数内的代码也会执行useEffect(()&#x3D;&gt;&#123; return ()&#x3D;&gt;&#123; console.log(&#39;更新或者卸载&#39;) &#125;&#125;,[count])&#x2F;&#x2F;也可以有依赖参数并且会更新用返回函数进行卸载或更新&#x2F;&#x2F;缺点：挂载前和更新前的生命周期要用到别的方法来配合使用useEffect。这里更多的是挂载完和更新完 useLayoutEffect其函数签名与useEffect相同，但它会在所有的DOM变更之后同步调用effect。可以使用它来读取DOM布局并同步触发重渲染，在浏览器执行绘制之前，useLayoutEffect内部的更新计划将不同步刷新 useContext123456789101112131415161718192021222324252627282930一个简单的传参案例基本就能明白useContext是在干神马。import React,&#123;createContext, useContext&#125; from &#39;react&#39;const DemoContext &#x3D; createContext(&#123;data:&#39;hello&#39;&#125;)function A ()&#123; return ( &lt;DemoContext.Provider value&#x3D;&#123;&#123;data:value&#125;&#125;&gt; &lt;B&gt;&lt;&#x2F;B&gt; &lt;&#x2F;DemoContext.Provider&gt; )&#125;function B()&#123; return ( &lt;div&gt; 儿子组件 &lt;C&gt;&lt;&#x2F;C&gt; &lt;&#x2F;div&gt; )&#125;function C()&#123; const text &#x3D; useContext(DemoContext) return ( &lt;div&gt; 孙子组件 &#123; text.data &#125; &lt;&#x2F;div&gt; )&#125;export default A useReducer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119在我们的需要处理的数据足够简单时，用useState就能完成。如果数据比较复杂了那么就可以考虑用useReducer这个先说下useReducer跟Store没关系，他只是借用了store的那套思想直接上案例import React, &#123; useState, useEffect, useReducer, useRef &#125; from &#39;react&#39;import &#123; withRouter &#125; from &#39;react-router-dom&#39;import &#123; connect &#125; from &#39;react-redux&#39;import s from &#39;.&#x2F;index.module.scss&#39;let init &#x3D; &#123; list: [&#123; id:1, name:&#39;澳门豆捞&#39;, open:1&#125;] &#125;function reducer(state, action) &#123; switch (action.type) &#123; case &#39;add&#39;: let arr &#x3D; JSON.parse(JSON.stringify(state.list)) arr.push(&#123; id: state.list.length &gt; 0 ? state.list[state.list.length-1].id + 1 : 1, name: action.name, open: 1, &#125;) return &#123;list:arr&#125; case &#39;close&#39;: for(let i&#x3D;0;i&lt;state.list.length;i++)&#123; if(state.list[i].id&#x3D;&#x3D;action.id)&#123; state.list[i].open&#x3D;2 &#125; &#125; return JSON.parse(JSON.stringify(state)) case &#39;open&#39;: for(let i&#x3D;0;i&lt;state.list.length;i++)&#123; if(state.list[i].id&#x3D;&#x3D;action.id)&#123; state.list[i].open&#x3D;1 &#125; &#125; return JSON.parse(JSON.stringify(state)) case &#39;set&#39;: for(let i&#x3D;0;i&lt;state.list.length;i++)&#123; if(state.list[i].id&#x3D;&#x3D;action.id)&#123; state.list[i].open&#x3D;3 &#125; &#125; return JSON.parse(JSON.stringify(state)) case &#39;del&#39;: for(let i&#x3D;0;i&lt;state.list.length;i++)&#123; if(state.list[i].id&#x3D;&#x3D;action.id)&#123; state.list.splice(i,1) &#125; &#125; return JSON.parse(JSON.stringify(state)) default: return state &#125;&#125;function Homet(props) &#123; const inp &#x3D; useRef(null) const [state, dispatch] &#x3D; useReducer(reducer, init) function btn() &#123; if (!inp.current.value) &#123; alert(&#39;输入不能为空&#39;) &#125; else &#123; dispatch(&#123; type: &#39;add&#39;, name: inp.current.value, &#125;) inp.current.value&#x3D;null &#125; &#125; return ( &lt;div className&#x3D;&#123;s.homet&#125;&gt; &lt;div className&#x3D;&#123;s.head&#125;&gt; &lt;span&gt;Todo后台管理&lt;&#x2F;span&gt; &lt;div className&#x3D;&#123;s.inpBox&#125;&gt; &lt;input ref&#x3D;&#123;inp&#125; placeholder&#x3D;&#39;请输入内容&#39; &#x2F;&gt; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; btn()&#125; className&#x3D;&#123;s.btn&#125;&gt;添加&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div className&#x3D;&#123;s.cont&#125;&gt; &#123; state.list.length &gt; 0 ? state.list.map((item, i) &#x3D;&gt; &lt;div className&#x3D;&#123;s.item&#125; key&#x3D;&#123;i&#125;&gt; &lt;img &#x2F;&gt; &lt;div className&#x3D;&#123;s.all&#125;&gt; &lt;span className&#x3D;&#123;s.name&#125;&gt;&#123;item.name&#125;&lt;&#x2F;span&gt; &lt;span&gt;&#123;item.open &#x3D;&#x3D; 1 ? &#39;营业中&#39; : item.open &#x3D;&#x3D; 2 ? &#39;已打烊&#39; : &#39;装修中&#39;&#125;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;div className&#x3D;&#123;s.del&#125;&gt; &#123; item.open &#x3D;&#x3D; 1 ? &lt;div className&#x3D;&#123;s.btnBox&#125;&gt; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;close&#39;,id:item.id&#125;)&#125; className&#x3D;&#123;s.margin&#125;&gt;打烊&lt;&#x2F;button&gt; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;set&#39;,id:item.id&#125;)&#125;&gt;装修&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; : item.open &#x3D;&#x3D; 2 ? &lt;div className&#x3D;&#123;s.btnBox&#125;&gt; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;open&#39;,id:item.id&#125;)&#125; className&#x3D;&#123;s.margin&#125;&gt;营业&lt;&#x2F;button&gt; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;set&#39;,id:item.id&#125;)&#125;&gt;装修&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; : &lt;div className&#x3D;&#123;s.btnBox&#125;&gt; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;open&#39;,id:item.id&#125;)&#125; className&#x3D;&#123;s.margin&#125;&gt;营业&lt;&#x2F;button&gt; &lt;button&gt;待完成&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &#125; &lt;button onClick&#x3D;&#123;()&#x3D;&gt;dispatch(&#123;type:&#39;del&#39;,id:item.id&#125;)&#125; className&#x3D;&#123;s.shan&#125;&gt;删除&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;) : &lt;span className&#x3D;&#123;s.no&#125;&gt;暂无数据&lt;&#x2F;span&gt; &#125; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; )&#125;let mapStateToProps &#x3D; (state) &#x3D;&gt; &#123; console.log(state) return &#123; list: state.list.list &#125;&#125;let mapDispatchToProps &#x3D; (dispatch) &#x3D;&gt; &#123; return &#123; &#125;&#125;Homet &#x3D; withRouter(Homet)export default connect(mapStateToProps, mapDispatchToProps)(Homet)","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-12-25T01:36:20.562Z","updated":"2020-12-25T01:36:20.562Z","comments":true,"path":"2020/12/25/hello-world/","link":"","permalink":"http://example.com/2020/12/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"属性描述符","slug":"属性描述符","date":"2018-10-02T13:59:58.000Z","updated":"2021-01-03T05:51:03.870Z","comments":true,"path":"2018/10/02/属性描述符/","link":"","permalink":"http://example.com/2018/10/02/%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/","excerpt":"","text":"Object.definePropertyObject.defineProperty(obj,prop,desctiptor)接受3个参数。obj:接受一个对象、prop:定义或修改的属性或Smybol、descriptor:属性描述符 123456 let obj &#x3D;&#123; name:&#39;hello&#39;&#125;Object.defineProperty(obj,&#39;sex&#39;,&#123;value:&#39;world&#39;&#125;)console.log(Object.keys(obj))&#x2F;&#x2F;只拿到了name 因为用上面定义的方法给对象添加的属性是不可枚举的所以它并不能被拿到 对象里目前存在属性描述符有两种主要形式：数据描述符合存取描述符。数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。存取描述符是由getter函数和setter函数所描述的属性。一个描述符只能是这两种其中之一，不能同时是两者这两种描述符都是对象。他们共享一下可选键值(默认值是指咋使用Object.definPropety()定义属性时的默认值)configurable当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。enumerable当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。默认为 false。数据描述符还具有以下可选键值： value该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。writable当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变。默认为 false。存取描述符还具有以下可选键值： get属性的 getter 函数，如果没有 getter，则为 undefined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。默认为 undefined。set属性的 setter 函数，如果没有 setter，则为 undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined。 1234567891011121314151617181920212223242526272829303132333435var o &#x3D; &#123;&#125;; &#x2F;&#x2F; 创建一个新对象&#x2F;&#x2F; 在对象中添加一个属性与数据描述符的示例Object.defineProperty(o, &quot;a&quot;, &#123; value : 37, writable : true, enumerable : true, configurable : true&#125;);&#x2F;&#x2F; 对象 o 拥有了属性 a，值为 37&#x2F;&#x2F; 在对象中添加一个设置了存取描述符属性的示例var bValue &#x3D; 38;Object.defineProperty(o, &quot;b&quot;, &#123; &#x2F;&#x2F; 使用了方法名称缩写（ES2015 特性） &#x2F;&#x2F; 下面两个缩写等价于： &#x2F;&#x2F; get : function() &#123; return bValue; &#125;, &#x2F;&#x2F; set : function(newValue) &#123; bValue &#x3D; newValue; &#125;, get() &#123; return bValue; &#125;, set(newValue) &#123; bValue &#x3D; newValue; &#125;, enumerable : true, configurable : true&#125;);o.b; &#x2F;&#x2F; 38&#x2F;&#x2F; 对象 o 拥有了属性 b，值为 38&#x2F;&#x2F; 现在，除非重新定义 o.b，o.b 的值总是与 bValue 相同&#x2F;&#x2F; 数据描述符和存取描述符不能混合使用Object.defineProperty(o, &quot;conflict&quot;, &#123; value: 0x9f91102, get() &#123; return 0xdeadbeef; &#125;&#125;);&#x2F;&#x2F; 抛出错误 TypeError: value appears only in data descriptors, get appears only in accessor descriptors 自定义 Setters 和 Getters下面的例子展示了如何实现一个自存档对象。当设置temperature 属性时，archive 数组会收到日志条目。 1234567891011121314151617181920212223function Archiver() &#123; var temperature &#x3D; null; var archive &#x3D; []; Object.defineProperty(this, &#39;temperature&#39;, &#123; get: function() &#123; console.log(&#39;get!&#39;); return temperature; &#125;, set: function(value) &#123; temperature &#x3D; value; archive.push(&#123; val: temperature &#125;); &#125; &#125;); this.getArchive &#x3D; function() &#123; return archive; &#125;;&#125;var arc &#x3D; new Archiver();arc.temperature; &#x2F;&#x2F; &#39;get!&#39;arc.temperature &#x3D; 11;arc.temperature &#x3D; 13;arc.getArchive(); &#x2F;&#x2F; [&#123; val: 11 &#125;, &#123; val: 13 &#125;] 继承属性如果访问者的属性是被继承的，它的 get 和 set 方法会在子对象的属性被访问或者修改时被调用。如果这些方法用一个变量存值，该值会被所有对象共享。 1234567891011121314151617function myclass() &#123;&#125;var value;Object.defineProperty(myclass.prototype, &quot;x&quot;, &#123; get() &#123; return value; &#125;, set(x) &#123; value &#x3D; x; &#125;&#125;);var a &#x3D; new myclass();var b &#x3D; new myclass();a.x &#x3D; 1;console.log(b.x); &#x2F;&#x2F; 1 Object.assign()Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。 12345678910111213let obj1 &#x3D; &#123; name:&#39;hong&#39;, sex:&#39;女&#39;&#125;let obj2 &#x3D; &#123; age:&#39;18&#39;, get sayName()&#123; return &#39;hong&#39; &#125;&#125;let obj3 &#x3D; Object.assign(&#123;&#125;,obj1,obj2)console.log(obj3)&#x2F;&#x2F;此时合并完，就会把obj2里的存取属性给变成了数据属性&#x2F;&#x2F;应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。 异常会打断后续拷贝任务1234567891011121314const target &#x3D; Object.defineProperty(&#123;&#125;, &quot;foo&quot;, &#123; value: 1, writable: false&#125;); &#x2F;&#x2F; target 的 foo 属性是个只读属性。Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);&#x2F;&#x2F; TypeError: &quot;foo&quot; is read-only&#x2F;&#x2F; 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。console.log(target.bar); &#x2F;&#x2F; 2，说明第一个源对象拷贝成功了。console.log(target.foo2); &#x2F;&#x2F; 3，说明第二个源对象的第一个属性也拷贝成功了。console.log(target.foo); &#x2F;&#x2F; 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。console.log(target.foo3); &#x2F;&#x2F; undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。console.log(target.baz); &#x2F;&#x2F; undefined，第三个源对象更是不会被拷贝到的。 拷贝访问器(手动实现你原来是个存取属性，现在通过Object.assign()拷贝过来还是存取属性)123456789101112131415161718192021222324252627282930313233const obj &#x3D; &#123; foo: 1, get bar() &#123; return 2; &#125;&#125;;let copy &#x3D; Object.assign(&#123;&#125;, obj);console.log(copy); &#x2F;&#x2F; &#123; foo: 1, bar: 2 &#125; copy.bar的值来自obj.bar的getter函数的返回值&#x2F;&#x2F; 下面这个函数会拷贝所有自有属性的属性描述符function completeAssign(target, ...sources) &#123; sources.forEach(source &#x3D;&gt; &#123; let descriptors &#x3D; Object.keys(source).reduce((descriptors, key) &#x3D;&gt; &#123; descriptors[key] &#x3D; Object.getOwnPropertyDescriptor(source, key); return descriptors; &#125;, &#123;&#125;); &#x2F;&#x2F; Object.assign 默认也会拷贝可枚举的Symbols Object.getOwnPropertySymbols(source).forEach(sym &#x3D;&gt; &#123; let descriptor &#x3D; Object.getOwnPropertyDescriptor(source, sym); if (descriptor.enumerable) &#123; descriptors[sym] &#x3D; descriptor; &#125; &#125;); Object.defineProperties(target, descriptors); &#125;); return target;&#125;copy &#x3D; completeAssign(&#123;&#125;, obj);console.log(copy);&#x2F;&#x2F; &#123; foo:1, get bar() &#123; return 2 &#125; &#125;","categories":[],"tags":[]},{"title":"express","slug":"express","date":"2018-08-30T13:57:46.000Z","updated":"2020-12-30T11:58:53.011Z","comments":true,"path":"2018/08/30/express/","link":"","permalink":"http://example.com/2018/08/30/express/","excerpt":"","text":"简单使用express首先安装 npm i express 、body-parser (post请求需要用到) 1.分别引用：import express from ‘express’;(如果没有引用bable,可以用require()引用) import baodyParser from ‘body-parser’; import fs from ‘fs’ import path from ‘path’ const app=express() //创建一个express应用 const post=3000 端口号 用一下body-parser :app.use(bodyParser.json()) app.use(bodyParser.urlencoded({extended:false})) 下面就可以使用 get post 进行请求了 app.post(‘/post’,(req,res)=&gt;{ }) app.get(‘/gett’,(req,res)=&gt;{ }) app.listen(post,()=&gt;{//监听端口号 console.log(post) }) 题外：1.关于express中间件的简单概述：在use(),get(),post()等方法里面是都可以使用中间件的。写法：app.user((req,res,next)=&gt;{ console.log(‘继续往下走’) next()//如果不写next它是不会继续执行下面代码的 由此可简单说一个例子：就是有了这个中间件我们可以把一些公共逻辑放在use()方法中来执行，如果可行就next()继续往下走，否则停止本次请求。因为use()方法不管什么请求都会走进来！我们可以在这里进行账号密码的校验，因为不论登录还是注册都是要校验的，所以不可能登录和注册的接口都要写一遍校验。这个时候我们可以把校验这段逻辑放在use()方法中，如果校验通过就可以继续请求，否则直接停止。所以有了它就可以减少代码冗余问题。 }) 2. express 重定向：使用 express.get(‘*’,(req,res)=&gt;{//就是当所有的请求都找不到时，给它重定向到一个专门的404页面。第一个参数是 *（通配符 所有），后面依然是回调函数 express.redirect(‘404.网页’)//用redirect方法做重定向 }) 3. 请求对象req的方法： req.body :获取post请求体的数据 req.query获取get请求的数据 req.originnalUrl 获取原始url地址、当需要处理路径的时候可以还可以用req.baseUrl，req.path 这三个方法是可以操作url的。 req.get(‘Content-type’)用来获取请求头 4. 响应对象res的方法： res.set(‘key’,value)设置响应头 key:响应头的字段名称 。 value:值。 res.send()发送数据 res.senfFile()发送文件 res.redirect()重新定向 参数是文件的地址 res.download()下载 res.jsonp()以jsonp的方式返回数据","categories":[],"tags":[]},{"title":"手写Promise","slug":"手写Promise","date":"2018-05-25T14:10:50.000Z","updated":"2020-12-27T12:35:16.339Z","comments":true,"path":"2018/05/25/手写Promise/","link":"","permalink":"http://example.com/2018/05/25/%E6%89%8B%E5%86%99Promise/","excerpt":"","text":"手写Promise 主要是解决回调地狱的问题，在ES6中出现了promise来解决这个问题，但是同样也带来了多个.then()的问题 //随着es7 async和await到来可以说彻底解决回调地狱。 new Promise() //是谁执行了？直接new一个Promise是内置构造Promise执行了，但是它会报错。因为这里缺一个回调函数，平常大家也都是这么用的 new Promise(()=&gt;{ console.log(‘你大爷’)//‘你大爷’会执行吗？：这里new了一个Promose,Promise执行一次，那里面的回调函数也会执行，所以‘你大爷’成功被打印 }) function fn(callBack){ &#125; new fn(()=&gt;&#123; &#125;)//fn执行，但是里面的回调并没有，Promise的回调会执行。 //new Promise 是内置构造函数Promise执行一次 //Promise的回调函数也会执行一次，这个回调函数会给我们提供两个形参（函数）：成功、失败 //Promise的回调函数，又有两个参数分别是：resolve、reject两个函数 //Promise类的实例没有then方法，应该是原型对象的方法 var obj = new Promise((resolve,rejecct)=&gt;&#123; console.log(resolve,reject)//两个函数 &#125;)//obj是Promise的一个实例 // 手写 function myPromise(callBack)&#123;//接受传进来的回调函数 //状态属性 this.status=&#39;pending&#39; //回调函数 callBack(resolve.bind(this),reject.bing(this)) //定义一个成功的函数 function resolve(hello, params)&#123; //那么console.log(hello)肯定是执行的（很早演示时写） //修改状态（后写） if(this.status===&#39;pending&#39;)&#123;//如果出事状态为pengding, this.status=&#39;success&#39;//那就把它改成success成功 //这里还有一个上下文的问题。成功时resolve是怎么调用的？是函数名+小括号，也就是window. //但这里就不该用window，因为将来获取服务器的数据实在.then()里的来获取。所以我们在初始化时就要给 //resolve和reject绑死这个类的实例：resolve.bind(this) reject.bing(this) 走起上面绑死↑ //否则你在调用resolve和reject时他们就会指向window //为什么绑死上下文为这个类的实例？因为我们要借用这个类的实例的成功和失败的方法74行里面成功与失败的回调 //所以↓ this.successCallBack(params)//这个是谁？它就是then的第一个参数也就是成功的回调，所以把参数直接注进来就行了 //失败同样 &#125; &#125; //定义一个失败的函数 function reject(err)&#123; if(this.status===&#39;pending&#39;)&#123; this.status=&#39;faile&#39; this.faileCallBack(err) &#125; &#125; &#125; //调用 new myPromise(()=&gt;&#123;//并且传进去一个回调函数。但是我们在实际运用中肯定要传2个参数进去。resolve,reject,并且37行回调也要接受这个2个函数 //console.log(&#39;我是Promise&#39;)//这里肯定会执行。打印。 //假如这里调用并传参resolve(&#39;hello&#39;) //处理异步,一般promise就是处理异步的 setTimeout(()=&gt;&#123; resolve(&#39;我是promise&#39;) &#125;) &#125;)//假如我们是在处理异步请求那么肯定要在这.then()。但是能直接.then()吗？要注意.then()是在原型上面的。虽然链式语法可以这么写，但是这里并没有这个方法。.then()应该是原型上面类的原型的方法 .then((data)=&gt;&#123; console.log(data) &#125;,()=&gt;&#123;&#125;)//一般我们在调用then()的时候肯定要传2个参数进去，下面接收，就是相当于将then方法里面成功与失败的回调函数当做当前类的实例即可，当前类是谁？promise //所以原型上定义一个then的方法，应该是 myPromise.prototype.then=function(success,faile)&#123;//接收上面调用then时传进来的来个函数。就是将then方法里面成功与失败的回到函数作为当前类的实例即可 this.successCallBack=success//相当于then传进一个成功的函数给了success,就是给myPromise的实例动态添加了属性就是success这个成功的箭头函数。还有一个失败的同样 this.faileCallBack=faile //then()的两个函数相当于作为这个实例的两个方法 &#125; //53行异步成功后执行，就是相当于调用了41行那个方法。失败同样 //因为promise有3中状态，pending、成功、失败。所以此时我去上面给类定义个状态的属性，走起↑ //如果说异步解决成功就调用resolve方法 。resolve就是41行函数执行。但是我们都是在then()来获取成功或失败的数据，(其实就是调用this.successCallBack，this.faileCallBack)。所以走起去上面↑，就是修改promise的状态 12345678910111213141516171819202122232425262728293031323334(()&#x3D;&gt;&#123; window.myPromise&#x3D;function(callBack)&#123; &#x2F;&#x2F;状态属性 this.status&#x3D;&#39;pending&#39; &#x2F;&#x2F;回调函数 callBack(resolve.bind(this),reject.bind(this)) &#x2F;&#x2F; 成功 function resolve(params)&#123; if(this.status&#x3D;&#x3D;&#x3D;&#39;pending&#39;)&#123; this.status&#x3D;&#39;success&#39; this.successCallBack(params) &#125; &#125; &#x2F;&#x2F; 失败 function reject(err)&#123; if(this.status&#x3D;&#x3D;&#x3D;&#39;pending&#39;)&#123; this.status&#x3D;&#39;faile&#39; this.successCallBack(err) &#125; &#125; &#125; &#x2F;&#x2F;原型上定义一个then的方法 myPromise.prototype.then&#x3D;function(success,faile)&#123; this.successCallBack&#x3D;success this.faileCallBack&#x3D;faile &#125;&#125;)()var obj &#x3D; new myPromise((resolve,reject)&#x3D;&gt;&#123; setTimeout(()&#x3D;&gt;&#123; resolve(&#39;你真好&#39;) &#125;,1000)&#125;).then((data)&#x3D;&gt;&#123; console.log(data)&#x2F;&#x2F;成功执行&#125;)","categories":[],"tags":[]},{"title":"Class的继承","slug":"Class2","date":"2018-05-16T06:53:04.000Z","updated":"2020-12-30T06:09:50.885Z","comments":true,"path":"2018/05/16/Class2/","link":"","permalink":"http://example.com/2018/05/16/Class2/","excerpt":"","text":"1.简介Class可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承,要清晰和方便很多。 123456class Point&#123;&#125;class Pointwo extends Point&#123; &#125; 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。 1234567891011class Pointwo extends Point&#123; constructor(x,y,color)&#123; super(x,y)&#x2F;&#x2F;调用父类的constructor(x,y) this.color &#x3D; color &#125; toString()&#123; return this.color + &#39;&#39; +super.toString()&#x2F;&#x2F;调用父类的toString() &#125;&#125;代码中，constructor方法和toString方法之中，都出现了super关键字，他在这里表示父类的构造函数，用来新建父类的this对象子类必须在constructor方法中调用super方法，否则新建实例时会报错，这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后对其进行加工，加上子类自己的实例属性和方法，如果不调用super方法，子类就得不到this对象 12345678910111213class Point &#123; &#x2F;* ... *&#x2F; &#125;class ColorPoint extends Point &#123; constructor() &#123; &#125;&#125;let cp &#x3D; new ColorPoint(); &#x2F;&#x2F; ReferenceError上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。 12345678910class ColorPoint extends Point &#123;&#125;&#x2F;&#x2F; 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125;另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。 12345678910111213141516171819202122class Point &#123; constructor(x, y) &#123; this.x &#x3D; x; this.y &#x3D; y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color &#x3D; color; &#x2F;&#x2F; ReferenceError super(x, y); this.color &#x3D; color; &#x2F;&#x2F; 正确 &#125;&#125;上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。下面是生成子类实例的代码。let cp &#x3D; new ColorPoint(25, 8, &#39;green&#39;);cp instanceof ColorPoint &#x2F;&#x2F; truecp instanceof Point &#x2F;&#x2F; true上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。 1最后，父类的静态方法，也会被子类继承。 class A { static hello() { console.log(‘hello world’); }} class B extends A {} B.hello() // hello world上面代码中，hello()是A类的静态方法，B继承A，也继承了A的静态方法。 122.Object.getPrototypeOf()Object.getPrototypeOf()方法可以用来从子类上获取父类 Object.getPrototypeOf(ColorPoint) === Point//true因此，可以使用这个方法判断，一个类是否继承了另一个类 1233.super关键字super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同第一种情况，super作为函数用时，代表父类的构造函数。ES6要求，子类的构造函数必须执行一次super函数。 class A {} class B extends A { constructor() { super(); }}上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。 注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。 12345678910111213141516&#96;&#96;&#96;class A &#123; constructor() &#123; console.log(new.target.name); &#125;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125;new A() &#x2F;&#x2F; Anew B() &#x2F;&#x2F; B上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。 12345678class A &#123;&#125;class B extends A &#123; m() &#123; super(); &#x2F;&#x2F; 报错 &#125;&#125;上面代码中，super()用在B类的m方法之中，就会造成语法错误。 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类 1234567891011121314class A&#123; p()&#123; return 2 &#125;&#125;class B extends A&#123; constructor()&#123; super() console.log(super.p())&#x2F;&#x2F;&#x2F;2 &#125;&#125;let b &#x3D; new B()代码中，子类B当中的super.p(),就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype,所以super.p()就相当于A.prototype.p()注意：由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。 123456789101112131415class A &#123; constructor() &#123; this.p &#x3D; 2; &#125;&#125;class B extends A &#123; get m() &#123; return super.p; &#125;&#125;let b &#x3D; new B();b.m &#x2F;&#x2F; undefined上面代码中，p是父类A实例的属性，super.p就引用不到它。 如果属性定义在父类的原型对象上，super就可以取到 1234567891011class A &#123;&#125;A.prototype.x &#x3D; 2;class B extends A &#123; constructor() &#123; super(); console.log(super.x) &#x2F;&#x2F; 2 &#125;&#125;let b &#x3D; new B();代码中,属性x是定义在A.prototype上面的，所以super.x可以取到它的值 ES6规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例 12345678910111213141516171819202122class A &#123; constructor() &#123; this.x &#x3D; 1; &#125; print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x &#x3D; 2; &#125; m() &#123; super.print(); &#125;&#125;let b &#x3D; new B();b.m() &#x2F;&#x2F; 2代码中，super.print()虽然调用的是A.prototype.print(),但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1.也就是说，实际上执行的是super.print.call(this) 由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性 123456789101112131415161718class A &#123; constructor() &#123; this.x &#x3D; 1; &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x &#x3D; 2; super.x &#x3D; 3; console.log(super.x); &#x2F;&#x2F; undefined console.log(this.x); &#x2F;&#x2F; 3 &#125;&#125;let b &#x3D; new B();代码中，super.x赋值为3，这时等同于对this.x赋值为3.而当读取super.x的时候，读的是A.prototype.x,所以返回undefined 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象 1234567891011121314151617181920class Parent&#123; static myMethod(msg)&#123; console.log(&#39;static&#39;,msg) &#125; myMethod(msg)&#123; console.log(&#39;instance&#39;,msg) &#125;&#125;class Child extends Parent&#123; static myMethod(msg)&#123; super.myMethod(msg) &#125; myMethod(msg)&#123; super.myMethod(msg) &#125;&#125;console.log(Child.myMethod(1))var child &#x3D; new Child()console.log(child.myMethod(2))上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。 另外，在子类的静态方法中通过super调用父类方法时，方法内部的this指向当前的子类，而不是子类的实例 12345678910111213141516171819202122class A &#123; constructor() &#123; this.x &#x3D; 1; &#125; static print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x &#x3D; 2; &#125; static m() &#123; super.print(); &#125;&#125;B.x &#x3D; 3;B.m() &#x2F;&#x2F; 3上面代码中，静态方法B.m里面，super.print指向父类的静态方法。这个方法里面的this指向的是B，而不是B的实例。 12345678910使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super); &#x2F;&#x2F; 报错 &#125;&#125;上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。 1234567891011class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.valueOf() instanceof B); &#x2F;&#x2F; true &#125;&#125;let b &#x3D; new B();上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super使得this指向B的实例，所以super.valueOf()返回的是一个B的实例。 12345678最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。var obj &#x3D; &#123; toString() &#123; return &quot;MyObject: &quot; + super.toString(); &#125;&#125;;obj.toString(); &#x2F;&#x2F; MyObject: [object Object] 4.类的 prototype 属性和__proto__属性大多数浏览器的ES5实现中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性,因此同时存在两条继承链(1) 子类的__proto__属性，表示构造函数的继承，总是指向父类。(2) 子类的prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性 123456789class A&#123;&#125;class B extends A&#123;&#125;B.__proto__ &#x3D;&#x3D;&#x3D; A &#x2F;&#x2F;trueB.prototype.__proto__ &#x3D;&#x3D;&#x3D; A.prototype &#x2F;&#x2F;true代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性 这样的结果是因为，类的继承是按照下面的模式实现的。 12345678910class A&#123;&#125;class B&#123;&#125;Object.setPrototypeOf(B.prototype,A.prototype)&#x2F;&#x2F;B的实例继承A的实例Object.setPrototypeOf(B,A)&#x2F;&#x2F;B继承A的静态属性const b &#x3D; new B()《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。 12345Object.setPrototypeOf &#x3D; function (obj, proto) &#123; obj.__proto__ &#x3D; proto; return obj;&#125;因此就得到了上面这个结果 12345678Object.setPrototypeOf(B.prototype, A.prototype);&#x2F;&#x2F; 等同于B.prototype.__proto__ &#x3D; A.prototype;Object.setPrototypeOf(B, A);&#x2F;&#x2F; 等同于B.__proto__ &#x3D; A;这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。 123B.prototype &#x3D; Object.create(A.prototype);&#x2F;&#x2F; 等同于B.prototype.__proto__ &#x3D; A.prototype; extends关键字后面可以跟多种类型的值 1234class B extends A&#123;&#125;上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。 下面，讨论两种情况。第一种，子类继承Object类。 123456class A extends Object &#123;&#125;A.__proto__ &#x3D;&#x3D;&#x3D; Object &#x2F;&#x2F; trueA.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; true这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。 第二种情况，不存在任何继承。 123456class A &#123;&#125;A.__proto__ &#x3D;&#x3D;&#x3D; Function.prototype &#x2F;&#x2F; trueA.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; true这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。 实例的 proto 属性子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。 123456var p1 &#x3D; new Point(2, 3);var p2 &#x3D; new ColorPoint(2, 3, &#39;red&#39;);p2.__proto__ &#x3D;&#x3D;&#x3D; p1.__proto__ &#x2F;&#x2F; falsep2.__proto__.__proto__ &#x3D;&#x3D;&#x3D; p1.__proto__ &#x2F;&#x2F; true上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。 因此，通过子类实例的proto.__proto__属性，可以修改父类实例的行为。 123456p2.__proto__.__proto__.printName &#x3D; function () &#123; console.log(&#39;Ha&#39;);&#125;;p1.printName() &#x2F;&#x2F; &quot;Ha&quot;上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。","categories":[],"tags":[]},{"title":"Class的基本语法","slug":"Class1","date":"2018-05-15T14:02:45.000Z","updated":"2020-12-29T06:52:30.506Z","comments":true,"path":"2018/05/15/Class1/","link":"","permalink":"http://example.com/2018/05/15/Class1/","excerpt":"","text":"class的基本语法:一.类的由来JS中生成实力对象的传统方法是通过构造函数，下面请看一个例子 123456789function Point(x,y)&#123; this.x&#x3D;x this.y&#x3D;y&#125;Point.prototype.toString&#x3D;function ()&#123; return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39;&#125;var p &#x3D; new Point(1,2)console.log(p) 上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。 ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。 1234567891011class Point&#123; constructor(x,y)&#123; this.x&#x3D;x this.y&#x3D;y &#125; toString()&#123; return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39; &#125;&#125;let p &#x3D;new Point(1,2)console.log(p) 这个是定义了一个类，有一个constructor()方法，就是构造方法而this关键字就是实力的对象。这种新的Class写法，最开始ES5的构造函数Point是一样的。 Point类除了构造方法，还定义了一个toString方法。注意，这里定义toString()方法，是不用加上function关键字的。直接定义就可以，并且不用逗号隔开，加了会报错。 ES6的类，完全可以看做构造函数的另一种写法。 1234567class Point&#123;&#125;console.log(typeof Point)&#x2F;&#x2F;function 说明类的数据类型是函数，类本身就指向构造函数console.log(Point&#x3D;&#x3D;&#x3D;Point.prototype.constructor)&#x2F;&#x2F;true使用的时候也是直接对类使用new 命令，跟构造函数的用法完全一致。 12345678class Bar&#123; todo()&#123; console.log(&#39;类&#39;) &#125;&#125;const b &#x3D; new Bar()b.todo()&#x2F;&#x2F;&#39;类&#39;构造函数的prototype属性，在ES6的 类上面继续存在。事实上，类的所有方法都定义在类的 prototype属性上面 1234567891011121314151617181920212223class Point &#123; constructor() &#123; &#x2F;&#x2F; ... &#125; toString() &#123; &#x2F;&#x2F; ... &#125; toValue() &#123; &#x2F;&#x2F; ... &#125; &#125; &#x2F;&#x2F; 等同于 Point.prototype &#x3D; &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;, &#125;; 上面代码中，所有的方法，其实都是定义在Point.prototype上面 因此，在类的实例上面调用方法，其实就是调用原型上的方法 1234class B&#123;&#125;const b &#x3D; new B()console.log(b.constructor &#x3D;&#x3D;&#x3D; B.prototype.constructor)&#x2F;&#x2F;trueb是B类的实例，b的constructor()方法就是B类原型的constructor()方法 1234567891011由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign()方法可以很方便地一次向类天机多个方法。比如：class Point&#123; constructor()&#123; &#125;&#125;Object.assign(Point.prototype,&#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;) 12prototype对象的constructor()属性，直接指向&#39;类&#39;的本身，这与ES5的行为是一致的。Point.prototype.constructor&#x3D;&#x3D;&#x3D;Point &#x2F;&#x2F;true 另外，类的内部所有定义的方法，都是不可枚举的(non-enumerabal) 1234567891011class Point&#123; constructor(x,y)&#123; &#125; toString()&#123; &#125;&#125;console.log(Object.keys(Point.prototype))&#x2F;&#x2F;[]console.log(Object.getOwnPropertyNames(Point.prototype))&#x2F;&#x2F;[&#39;constructor&#39;,&#39;toString&#39;]这里，toString()方法是Point类 内部定义的方法，它是不可枚举的。这一点与ES5是不一样的 123456789 var Point &#x3D; function (x,y)&#123;&#125;Point.prototype.toString &#x3D; function ()&#123;&#125;console.log(Object.keys(Point.prototype))&#x2F;&#x2F;[&#39;toString&#39;]console.log(Object.getOwnPropertyNames(Point.prototype))&#x2F;&#x2F;[&#39;constructor&#39;,&#39;toString&#39;]这是ES5 的写法，toString()方法就是可枚举的。 Constructor()方法 constructor()方法是类的默认方法，是通过new 命令生成对象实例时，自动调用该方法。一个类必须有constructor() 方法，如果没有显示定义，一个空德constructor()方法也会被默认添加 1234567891011class Ponit&#123; &#125; &#x2F;&#x2F;等同于 class Point&#123; constructor()&#123; &#125; &#125;这里，定义了一个空的类Point,JS引擎会自动给他添加一个空的constructor()方法。constructor()方法默认返回实例对象(即this),完全可以指定返回另一个对象 12345678class Foo&#123; constructor()&#123; return Object.create(null) &#125;&#125;console.log(new Foo() instanceof Foo)&#x2F;&#x2F;false这里，constructor()函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。类必须使用new调用，否则会报错，这是它跟普通构造函数的一个主要区别，后者不用new也可以执行 123456class Foo&#123; constructor()&#123; return Object.create(null) &#125;&#125;Foo()&#x2F;&#x2F;Class constructor Foo cannot be invoked without &#39;new&#39; 类的实例！ 生成类的实例的写法，与ES5 完全一样，也是使用 new命令。如果没有用 new，像函数那样调用class,将会报错 12345class Point&#123; &#125; var point &#x3D; Point(2,3)&#x2F;&#x2F;报错 var point &#x3D; new Point(2,3)&#x2F;&#x2F;正确 与ES5 一样，实例的属性除非显示定义在其本身(即定义在this上)，否则都是定义在原型上(即定义在class上) 1234567891011121314151617class Point&#123; constructor(x,y)&#123; this.x&#x3D;x this.y&#x3D;y &#125; toString()&#123; return &#39;(&#39;+this.x+&#39;,&#39;+this.y+&#39;)&#39; &#125;&#125;var point &#x3D; new Point(2,3)console.log(point.toString(2,3))&#x2F;&#x2F;(2,3)console.log(point.hasOwnProperty(&#39;x&#39;))&#x2F;&#x2F;trueconsole.log(point.hasOwnProperty(&#39;y&#39;))&#x2F;&#x2F;trueconsole.log(point.hasOwnProperty(&#39;toString&#39;))&#x2F;&#x2F;falseconsole.log(point.__proto__.hasOwnProperty(&#39;toString&#39;))&#x2F;&#x2F;true上面代码中，x和y都是实例对象point自身属性(因为定义在this变量上)，所以hasOwnProperty()方法返回true，而toString()是原型对象的属性(因为定义在Point类上)，所以hasOwnProperty()方法返回false,这些都与ES5的行为保持一致 与ES5一样，类的所有实例共享一个原型对象！！！！ 12345var p1 &#x3D; new Point(2,3)var p2 &#x3D; new Point(1,3)p1.__proto&#x3D;&#x3D;&#x3D;p2.__proto__&#x2F;&#x2F;true上面代码中。p1和p2都是Point的实例，他们的原型都是Point.prototype,所以__proto__属性是相等的。这也意味着，可以通过实例的__proto__属性为&#39;类&#39;添加方法 proto 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。 1234567891011var p1 &#x3D; new Point(2,3);var p2 &#x3D; new Point(3,2);p1.__proto__.printName &#x3D; function () &#123; return &#39;Oops&#39; &#125;;p1.printName() &#x2F;&#x2F; &quot;Oops&quot;p2.printName() &#x2F;&#x2F; &quot;Oops&quot;var p3 &#x3D; new Point(4,2);p3.printName() &#x2F;&#x2F; &quot;Oops&quot;上面代码在p1的原型上添加了一个printName()方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。 取值函(getter)和存值函数(setter)与ES5一样，在’类’的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为 123456789101112131415class MyClass&#123; constructor()&#123; &#125; get prop()&#123; return &#39;getter&#39; &#125; set prop(value)&#123; console.log(&#39;setter:&#39;+value) &#125;&#125;let inst &#x3D; new MyClass()console.log(inst.props&#x3D;123)&#x2F;&#x2F;&#39;setter:123&#39;console.log(inst.prop)&#x2F;&#x2F;&#39;getter&#39;上面，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了 存值函数和取值函数式设置在属性的 Desscriptor对象上的。 1234567891011121314151617class CustomHTMLElement &#123; constructor(element)&#123; this.element &#x3D; element &#125; get html()&#123; return thi.element.innerHTML &#125; set html(value)&#123; this.element.innerHTML&#x3D;value &#125;&#125;var descriptor &#x3D; Object.getOwnPropertyDescriptor( CustomHTMLElement.proptotype,&#39;html&#39;)&#39;get&#39; in descriptor&#x2F;&#x2F;true&#39;set&#39; in descriptor&#x2F;&#x2F;true上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。 属性表达式 12345678910let nethodName &#x3D; &#39;getArea&#39;class Square &#123; constructor(length)&#123; &#125; [methodName]()&#123; &#125;&#125;代码中，Square类的方法名getArea,是从表达式得到的。 Class 表达式与函数一样，类也可以使用表达式的形式定义 12345678910111213 const MyClass &#x3D; class Me&#123; getClassName()&#123; return Me.name &#125;&#125;这里使用表达式定义了一个类，类的名字是Me,但是Me只在Class的内部可用，指代当前类。在Class外部，这个类只能用myClass引用let inst &#x3D; new MyClass()console.log(inst.getClassName())&#x2F;&#x2F;MeMe.name&#x2F;&#x2F;Me is not defined这里就可以说明，Me只在Class内部有定义如果类的内部没有用到的话，可以省略Me,也就是可以下面的形式const MyClass &#x3D; class &#123;&#x2F;&#x2F;....&#125; 1234567891011采用Class 表达式，可以写出立即执行的Classlet person &#x3D; new class&#123; constructor(name)&#123; this.name &#x3D; name &#125; sayName()&#123; console.log(this.name) &#125;&#125;(&#39;李华&#39;)person.sayName()这里 person是一个立即执行的类的实例 注意点（1）严格模式 类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。（2）不存在提升累不存在变量提升，这一点与ES5完全不同 123new Foo()class Foo&#123;&#125;上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承者有关，必须保证子类在父类之后定义。 12345&#123; let Foo &#x3D; class&#123;&#125; class Bar extends Foo&#123;&#125;&#125;上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。 （3）name 属性由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。 123class Point&#123;&#125;Point.name&#x2F;&#x2F;&#39;Point&#39;name属性总是返回紧跟在class关键字后面的类。 （4）Generator 方法如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。 1234567891011121314class Foo&#123; constructor(...args)&#123; this.args &#x3D; args &#125; *[Symbol.iterator]()&#123; for(let arg of this.args)&#123; yield arg &#125; &#125;&#125;for(let x of new Foo(&#39;hello&#39;,&#39;world&#39;))&#123; console.log(x)&#125;上面的代码中，Foo类的Symbol.interator方法前有一个星号，表示该方法是一个Generator 函数。Symbol.interator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。 5）this 的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 1234567891011121314151617181920212223242526272829class Logger&#123; printName(name&#x3D;&#39;there&#39;)&#123; this.print(&#96;Hello $&#123;name&#125;&#96;) &#125; print(text)&#123; console.log(text) &#125;&#125;const logger &#x3D; new Logger()const &#123; printName&#125; &#x3D; loggerconsole.log(printName())&#x2F;&#x2F;Cannot read property &#39;print&#39; of undefined上面代码中，printName方法中的this，默认指向Logger类的实例，但是。如果将这个方法提取出来单独使用，this会指向该方法运行是所在的环境(由于class内部是严格模式，所以this实际指向的是undefined),从而导致找不到print方法而报错。一个比较简单的解决方法是，在构造函数中绑定this。这样就不会找不到print方法了。class Logger &#123; constructor() &#123; this.printName &#x3D; this.printName.bind(this); &#125; &#x2F;&#x2F; ...&#125;另一种解决方法是使用箭头函数。class Obj&#123; constructor()&#123; this.getThis &#x3D; () &#x3D;&gt; this &#125;&#125;const myObj &#x3D; new Obj()myObj.getThis() &#x3D;&#x3D;&#x3D; myObj&#x2F;&#x2F;true箭头函数内部的this总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，实在构造函数执行的时候，这时，箭头函数所在的运行环境，肯定是实例对象，所以this会总是指向实例对象 12345678910111213141516171819还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。function selfish (target) &#123; const cache &#x3D; new WeakMap(); const handler &#x3D; &#123; get (target, key) &#123; const value &#x3D; Reflect.get(target, key); if (typeof value !&#x3D;&#x3D; &#39;function&#39;) &#123; return value; &#125; if (!cache.has(value)) &#123; cache.set(value, value.bind(target)); &#125; return cache.get(value); &#125; &#125;; const proxy &#x3D; new Proxy(target, handler); return proxy;&#125;const logger &#x3D; selfish(new Logger()); 2.静态方法类相当于实例的原型。所有在类中定义的方法，都会被实例继承，如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为‘静态方法’ 12345678910class Foo&#123; static classMethod()&#123; return &#39;hello&#39; &#125;&#125;console.log(Foo.classMethod())&#x2F;&#x2F;&#39;hello&#39;var foo &#x3D; new Foo()console.log(foo.classMethod())&#x2F;&#x2F;foo.classMethod is not a function上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用(Foo.classMethod()),而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法 注意：如果静态方法包含this关键字，这个this指的是类，而不是实例 1234567891011121314class Foo&#123; static bar()&#123; this.baz() &#125; static baz()&#123; console.log(&#39;hello&#39;) &#125; baz()&#123; console.log(&#39;world&#39;) &#125;&#125; console.log(Foo.bar())&#x2F;&#x2F;hello上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo的类，而不是Foo的实例，等同于调用Foo.baz.另外，从这个例子还可以看出，静态方法可以与非静态方法重名 父类的静态方法，可以被子类继承 12345678class Foo&#123; static classMethod()&#123; return &#39;hello&#39; &#125;&#125;class Bar extends Foo&#123;&#125;console.log(Bar.classMethod())&#x2F;&#x2F;hello这里，父类Foo有一个静态方法，子类Bar可以调用这个方法 123456789101112静态方法也是可以从super对象上调用的class Foo&#123; static classMethod()&#123; return &#39;hello&#39; &#125;&#125;class Bar extends Foo&#123; static classMethod()&#123; return super.classMethod()+&#39;,too&#39; &#125;&#125;console.log(Bar.classMethod())&#x2F;&#x2F;hello,too 3.实例属性的新写法实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。 12345678910111213class IncreasingCounter&#123; constructor()&#123; this._count &#x3D; 0 &#125; get value()&#123; console.log(&#39;Getting the current value&#39;) return this._count &#125; increment()&#123; this._count++ &#125;&#125;代码中，实例属性this._count定义在constructor()方法里面，另一种写法是，这个属性也可以定义在类的最顶层，其他都不变 123456789101112class IncreasingCounter&#123; _count &#x3D; 0 get value()&#123; console.log(&#39;Getter the current value&#39;) return this._count &#125; increment()&#123; this._count++ &#125;&#125;代码中，实例属性_count与取值函数value()和increment()方法，处于同一层级。这时，不需要在实例属性前面加上this。这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性 12345678class foo&#123; bar &#x3D; &#39;hello&#39; baz &#x3D; &#39;world&#39; constructor()&#123; &#125;&#125;代码中，一眼就能看出，foo类有两个实例属性，一目了然。另外，写起来也比较简洁 4.静态属性静态属性指的是Class 本身的属性，即Class.porpName,而不是定义在实例对象(this)上的属性 123456class Foo&#123;&#125;Foo.prop &#x3D; 1Foo.prop &#x2F;&#x2F;1上面的写法为Foo类定义了一个静态属性prop 目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性。写法是在实例属性的前面，加上static关键字。 12345678class MyClass&#123; static myStaticProp &#x3D; 42 constructor()&#123; console.log(MyClass.myStaticProp) &#125;&#125;new MyClass()这个新写法大大方便了静态属性的表达 12345678class Foo&#123;&#x2F;&#x2F;老写法&#125;Foo.prop &#x3D;1class Foo&#123;&#x2F;&#x2F;新写法 static prop &#x3D;1&#125;上面代码中，老写法的静态属性定义在类的外部，整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative）,而不是赋值处理，语义更好。 5.私有方法和私有属性现在的解决方案私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问，这是常见需求，有利于代码的封装，但ES6不提供，只能通过变通方法模拟实现。一种做法是在命名上加以区别。 1234567891011class Widget&#123; &#x2F;&#x2F;公有方法 foo(baz)&#123; this._bar(baz) &#125; &#x2F;&#x2F;私有属性 _bar(baz)&#123; return this.snaf &#x3D; baz &#125;&#125;上面代码中，_bar()方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是这种命名是不保险的。在类的外部，还是可以调用到这个方法 另一种方法就是索性将私有方法移出类，因为类内部的所有方法都是对外可见的。 123456789101112class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; &#x2F;&#x2F; ...&#125;function bar(baz) &#123; return this.snaf &#x3D; baz;&#125;上面代码中，foo是公开方法，内部调用了bar.call(this, baz)。这使得bar()实际上成为了当前类的私有方法。","categories":[],"tags":[]},{"title":"变量提升","slug":"变量提升","date":"2018-05-08T06:01:41.000Z","updated":"2020-12-30T06:09:49.333Z","comments":true,"path":"2018/05/08/变量提升/","link":"","permalink":"http://example.com/2018/05/08/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/","excerpt":"","text":"var的变量提升es3/es51.变量提升：当栈内存（作用域）形成，JS代码自上而下执行之前，浏览器首先会把所有带var和function关键字的进行提前的声明或定义.这种预先处理机制称之为变量提升。3.声明（declare）：var a或function sum4.定义（defined）:a=12 也就是赋值5.变量提升阶段：6.带var的只声明未定义 12345678910111213console.log(a)&#x2F;&#x2F;undefined var a &#x3D; 12; function b(arr)&#123;&#x2F;&#x2F;变量提升阶段function就完成了声明和赋值，浏览器会在全局作用域声明一个b，然后再形成一个堆内存里面 &#x2F;&#x2F;是函数体里面的代码字符串。这个堆内存会有一个16进制的地址，而全局里面声明的那个b就会指向这个地址 &#x2F;&#x2F;因为函数在变量提升阶段就完成了声明和赋值，所以在代码执行阶段在遇到b这个函数就不会在重复声明赋值，就会直接跳过 for(let i&#x3D;0;i&lt;arr.length;i++)&#123; console.log(i) &#125; &#125; &#x2F;&#x2F;跳过后就会执行下面这个函数调用，传了一个数组进去。 &#x2F;&#x2F;而执行一个函数也就是形成了一个私有栈内存。当私有的作用域形成后也不是立即代码执行，而是先进行变量提升（变量提升前，先形参赋值） b([1,2,3,4]) &#x2F;&#x2F;在ES3和ES5语法规范中,只有全局作用域和函数执行的私有作用域（栈内存），其他大括号不会形成栈内存 带var与不带var在全局作用域下声明一个变量，也相当于给window全局对象设置了一个属性，变量的值就是属性值（私有作用域下声明的私有变量和window没有关系）带function的声明和赋值都完成了变量提升至发生在当前作用域（例如：开始加载页面的时候只对全局作用域下的进行提升，因为此时函数中存储的都是字符串）在全局作用域先声明的函数或者变量是‘全局变量’，同理，在私有作用域下声明的变量是‘私有变量’[带var和function才是声明 123456789101112console.log(i)&#x2F;&#x2F;undefined console.log(window.i)&#x2F;&#x2F;undefined console.log(&#39;i&#39; in window)&#x2F;&#x2F;true 在变量提升阶段，在全局作用域中声明了一个变量i，此时就已经把i当做属性值赋值 &#x2F;&#x2F;给了window了，只不过此时还没有给i赋值，默认是undefined &#x2F;&#x2F; in? ：检测某个属性是否隶属于这个对象 var i &#x3D; 9&#x2F;&#x2F;变量值修改window的值也跟着修改 console.log(i)&#x2F;&#x2F;9 console.log(window.i)&#x2F;&#x2F;9 window的一个属性名为i i&#x3D;13 console.log(window.i)&#x2F;&#x2F;13 window.i&#x3D;14 console.log(i)&#x2F;&#x2F;14 重点：全局变量和window的属性存在‘映射机制’，就是有一个改变另一个也跟着改变 不带var 不带var的本质是window的属性1234567891011121314151617181920212223&#x2F;&#x2F;console.log(j)&#x2F;&#x2F;j is not defined 这里的J是按照变量的来识别的 &#x2F;&#x2F;console.log(window.j)&#x2F;&#x2F;undefined 这里是按照window的属性来识别的，因为对象没有某一个属性返回的就是undefined &#x2F;&#x2F;console.log(window.j)&#x2F;&#x2F;false 不存在这个属性 j&#x3D;10&#x2F;&#x2F; 这里不带var 就相当于给window加了一个属性叫j,值是10 console.log(j)&#x2F;&#x2F;10 console.log(window.a)&#x2F;&#x2F;12 &#x2F;&#x2F; var q &#x3D;10, &#x2F;&#x2F; s &#x3D;11 &#x2F;&#x2F;这样写s是带var &#x2F;&#x2F; var q &#x3D; s &#x3D;11 &#x2F;&#x2F; 这样写不带var &#x2F;&#x2F;在私有作用域中带var和不带var也有区别：带var在私有作用域变量提升阶段都声明为私有变量和外界没有任何关系 &#x2F;&#x2F;不带var 不是私有变量，它会想它的上级作用域查找，看它是否是上级的变量，不是继续向上查找，一直找到window为止 &#x2F;&#x2F;这种查找机制叫‘作用域链’ &#x2F;&#x2F;console.log(n,m)&#x2F;&#x2F;undefined undefined var n &#x3D;13; m &#x3D;13; function fn()&#123; console.log(n,m)&#x2F;&#x2F;变量提升阶段先var了一个n所以是 undefined 但是m不带var，向上级查找所以m是13 ； var n &#x3D; m &#x3D; 14&#x2F;&#x2F;此时都是14 console.log(n,m)&#x2F;&#x2F;14 14 &#125; fn() console.log(a,m)&#x2F;&#x2F; 这里的a是全局的所以是13，b在函数里被重新赋值所以是14 在私有作用域中如果向上级查找变量到window的时候发现window也没有这个属性时又是怎么做的呢？12345678unction f()&#123; b &#x3D; 13 console.log(&#39;b&#39; in window)&#x2F;&#x2F;true 在作用域查找的过程中，如果找到window也没有这个变量，相当于给window设置了 &#x2F;&#x2F;了一个属性b console.log(b)&#x2F;&#x2F;13 &#125; f() console.log(b)&#x2F;&#x2F;13 只对等于号左边进行变量提升1234567891011fnn()&#x2F;&#x2F; fnn is not a function sun()&#x2F;&#x2F;2 var fnn &#x3D; function ()&#123;&#x2F;&#x2F;函数表达式声明 因为是用var关键字声明在变量提升阶段只提升了等号左边的fnn, &#x2F;&#x2F;但是并没有定义或赋值，所以在上面调用时报错 console.log(1) &#125; fnn() function sun ()&#123;&#x2F;&#x2F;普通方式声明的函数在 变量提升阶段就已经声明和定义完毕 所以上面可以直接执行 console.log(2) &#125; sun() 条件判断下变量提升1234567891011121314151617console.log(z) if(1&#x3D;&#x3D;&#x3D;2)&#123;&#x2F;&#x2F;在当前作用域下，不管条件是否成功都要进行变量提升， &#x2F;&#x2F;带var的还是只是声明 &#x2F;&#x2F;带function的在老版本浏览器渲染机制下，声明+定义都处理，但是为了迎合es6中的块级作用域，新版浏览器对于函数 &#x2F;&#x2F;（在条件判断中的函数），不管条件是否成立，都是先声明，没有赋值。 var z &#x3D; 10 &#125; console.log(z) if(1&#x3D;&#x3D;&#x3D;1)&#123; console.log(fs)&#x2F;&#x2F;函数本身：当条件成立，进入到判断体中（ES6中它是以个块级作用域）第一件事并不是变量提升， &#x2F;&#x2F;先把fs声明并定义，也就是判断体中代买执行前，fs就已经赋值了 function fs()&#123; console.log(&#39;ok&#39;) &#125; &#125; console.log(fs)&#x2F;&#x2F;函数本身 ES6中let创建的变量不存在变量提升。不允许重复定义 暂时性死区 ,切断了全局变量和window属性的映射机制1234console.log(a)&#x2F;&#x2F;a is not defined let a &#x3D;12 console.log(window.a)&#x2F;&#x2F;undefined console&#x2F;log(a)&#x2F;&#x2F;12","categories":[],"tags":[]},{"title":"嘛是跨域？","slug":"跨域","date":"2018-03-02T12:00:36.000Z","updated":"2020-12-30T12:47:21.577Z","comments":true,"path":"2018/03/02/跨域/","link":"","permalink":"http://example.com/2018/03/02/%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"资源所在的服务器地址和资源内发起请求的目标服务器地址不同！（两个服务器是不同的） 这里就要说一下浏览器的同源策略问题（服务器之间是没有同源策略的），如果两个URL的协议/主机(域名，IP地址)/端口（默认是80），都相同的话就是同源。如有一个不一样就会发生跨域问题，就是非同源。注意：同源策略是指针对AJXS请求而言，如果不是Ajxs即便非同源也是能请求的。如果用ajxs发起的请求地址和后端地址不同就会跨域","categories":[],"tags":[]},{"title":"居中总结","slug":"居中总结","date":"2017-06-10T11:55:00.000Z","updated":"2020-12-30T11:55:35.913Z","comments":true,"path":"2017/06/10/居中总结/","link":"","permalink":"http://example.com/2017/06/10/%E5%B1%85%E4%B8%AD%E6%80%BB%E7%BB%93/","excerpt":"剧中总结！水平居中 绝对定位+left+margin-left .first{ position: absolute; left: 50%; margin-left: -50px;//也就是1/2width}","text":"剧中总结！水平居中 绝对定位+left+margin-left .first{ position: absolute; left: 50%; margin-left: -50px;//也就是1/2width} ☠️必须得知道物体的宽高 2.绝对定位+left+transform .second{ position: absolute; left:50%; -webkit-transform: translate(-50%); -moz-transform: translate(-50%); -ms-transform: translate(-50%); -o-transform: translate(-50%); transform: translate(-50%);}😍transform的妙用，translate位移是针对自身的，所以可以不知道自身的宽度，是上面的升级版。 3.绝对定位+margin+左右 .third{ margin:auto; position: absolute; left:0; right:0; }😍margin的妙用，如果设置左右为0，那么水平居中，如果设置上下左右都为0，那么就在整个页面居中（也就是水平也居中垂直也居中），换言之，如果值设置上下为0，那么垂直方向居中。 4.flex布局 .box{ display:flex; justify-content:center;}😍很简洁的样子，给父元素设置两行就能做到水平居中了 相对定位+margin .fouth{ position:relative; margin:x auto x;//x代表随意的数值}😍好简洁 5.text-align .box{ text-align:center;}😍text-align属性只对行内元素有效，比如图片、文字、span等，当然也能让它对div奏效，把块级元素设为行内元素就行了。这个属性是设置在父盒子上面的。一般用来设置图片和文字居中比较多。 垂直居中 1.line-height .box{ line-height:50px;}😍设置行高，子元素会垂直居中，不论是行内还是块级子元素都有效。 ☠️只对单行文字有效。 2.多行文字垂直居中 //第一种.box{ display:table; height:200px;}.child{ display:table-sell; vertical-aligh:middle;}//第二种.box{ display:table-sell; height:200px; vertical-align:middle;}.child{ display:inline-block;}👉vertical-align是用来指定行内元素和表格单元格（table-sell）元素的垂直对齐方式","categories":[],"tags":[]}],"categories":[],"tags":[]}